<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>System - API Diff between .NET 6 and .NET 7</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/diff.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/csharp.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">API Diff between .NET 6 and .NET 7</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">.NET 7.0   API Changes</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Microsoft.AspNetCore.App <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0/" class="dropdown-item">API Difference 6.0 vs 7.0</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authentication.Cookies/" class="dropdown-item">Microsoft.AspNetCore.Authentication.Cookies</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authentication/" class="dropdown-item">Microsoft.AspNetCore.Authentication</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization.Infrastructure/" class="dropdown-item">Microsoft.AspNetCore.Authorization.Infrastructure</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization.Policy/" class="dropdown-item">Microsoft.AspNetCore.Authorization.Policy</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization/" class="dropdown-item">Microsoft.AspNetCore.Authorization</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Builder/" class="dropdown-item">Microsoft.AspNetCore.Builder</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.CompilerServices/" class="dropdown-item">Microsoft.AspNetCore.Components.CompilerServices</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Forms/" class="dropdown-item">Microsoft.AspNetCore.Components.Forms</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.RenderTree/" class="dropdown-item">Microsoft.AspNetCore.Components.RenderTree</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Rendering/" class="dropdown-item">Microsoft.AspNetCore.Components.Rendering</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Routing/" class="dropdown-item">Microsoft.AspNetCore.Components.Routing</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Web.Virtualization/" class="dropdown-item">Microsoft.AspNetCore.Components.Web.Virtualization</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Web/" class="dropdown-item">Microsoft.AspNetCore.Components.Web</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components/" class="dropdown-item">Microsoft.AspNetCore.Components</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Connections.Features/" class="dropdown-item">Microsoft.AspNetCore.Connections.Features</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Connections/" class="dropdown-item">Microsoft.AspNetCore.Connections</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel/" class="dropdown-item">Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.DataProtection.Internal/" class="dropdown-item">Microsoft.AspNetCore.DataProtection.Internal</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Diagnostics/" class="dropdown-item">Microsoft.AspNetCore.Diagnostics</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Hosting/" class="dropdown-item">Microsoft.AspNetCore.Hosting</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.Features/" class="dropdown-item">Microsoft.AspNetCore.Http.Features</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.HttpResults/" class="dropdown-item">Microsoft.AspNetCore.Http.HttpResults</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.Metadata/" class="dropdown-item">Microsoft.AspNetCore.Http.Metadata</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http/" class="dropdown-item">Microsoft.AspNetCore.Http</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.HttpLogging/" class="dropdown-item">Microsoft.AspNetCore.HttpLogging</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Identity/" class="dropdown-item">Microsoft.AspNetCore.Identity</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ApplicationModels/" class="dropdown-item">Microsoft.AspNetCore.Mvc.ApplicationModels</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Infrastructure/" class="dropdown-item">Microsoft.AspNetCore.Mvc.Infrastructure</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding.Binders/" class="dropdown-item">Microsoft.AspNetCore.Mvc.ModelBinding.Binders</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding.Metadata/" class="dropdown-item">Microsoft.AspNetCore.Mvc.ModelBinding.Metadata</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding/" class="dropdown-item">Microsoft.AspNetCore.Mvc.ModelBinding</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.RazorPages/" class="dropdown-item">Microsoft.AspNetCore.Mvc.RazorPages</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Rendering/" class="dropdown-item">Microsoft.AspNetCore.Mvc.Rendering</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Routing/" class="dropdown-item">Microsoft.AspNetCore.Mvc.Routing</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ViewFeatures/" class="dropdown-item">Microsoft.AspNetCore.Mvc.ViewFeatures</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc/" class="dropdown-item">Microsoft.AspNetCore.Mvc</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.OutputCaching/" class="dropdown-item">Microsoft.AspNetCore.OutputCaching</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.RateLimiting/" class="dropdown-item">Microsoft.AspNetCore.RateLimiting</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.RequestDecompression/" class="dropdown-item">Microsoft.AspNetCore.RequestDecompression</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.ResponseCompression/" class="dropdown-item">Microsoft.AspNetCore.ResponseCompression</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Routing.Patterns/" class="dropdown-item">Microsoft.AspNetCore.Routing.Patterns</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Routing/" class="dropdown-item">Microsoft.AspNetCore.Routing</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.IIS.Core/" class="dropdown-item">Microsoft.AspNetCore.Server.IIS.Core</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Core/" class="dropdown-item">Microsoft.AspNetCore.Server.Kestrel.Core</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Https/" class="dropdown-item">Microsoft.AspNetCore.Server.Kestrel.Https</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Transport.Quic/" class="dropdown-item">Microsoft.AspNetCore.Server.Kestrel.Transport.Quic</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.SignalR.Protocol/" class="dropdown-item">Microsoft.AspNetCore.SignalR.Protocol</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.SignalR/" class="dropdown-item">Microsoft.AspNetCore.SignalR</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.WebUtilities/" class="dropdown-item">Microsoft.AspNetCore.WebUtilities</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Caching.Distributed/" class="dropdown-item">Microsoft.Extensions.Caching.Distributed</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Caching.Memory/" class="dropdown-item">Microsoft.Extensions.Caching.Memory</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.CommandLine/" class="dropdown-item">Microsoft.Extensions.Configuration.CommandLine</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.EnvironmentVariables/" class="dropdown-item">Microsoft.Extensions.Configuration.EnvironmentVariables</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Ini/" class="dropdown-item">Microsoft.Extensions.Configuration.Ini</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Memory/" class="dropdown-item">Microsoft.Extensions.Configuration.Memory</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Xml/" class="dropdown-item">Microsoft.Extensions.Configuration.Xml</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration/" class="dropdown-item">Microsoft.Extensions.Configuration</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.DependencyInjection.Extensions/" class="dropdown-item">Microsoft.Extensions.DependencyInjection.Extensions</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.DependencyInjection/" class="dropdown-item">Microsoft.Extensions.DependencyInjection</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileProviders.Physical/" class="dropdown-item">Microsoft.Extensions.FileProviders.Physical</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileProviders/" class="dropdown-item">Microsoft.Extensions.FileProviders</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Abstractions/" class="dropdown-item">Microsoft.Extensions.FileSystemGlobbing.Abstractions</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments/" class="dropdown-item">Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts/" class="dropdown-item">Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing/" class="dropdown-item">Microsoft.Extensions.FileSystemGlobbing</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Hosting.Internal/" class="dropdown-item">Microsoft.Extensions.Hosting.Internal</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Hosting/" class="dropdown-item">Microsoft.Extensions.Hosting</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Http/" class="dropdown-item">Microsoft.Extensions.Http</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Abstractions/" class="dropdown-item">Microsoft.Extensions.Logging.Abstractions</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Configuration/" class="dropdown-item">Microsoft.Extensions.Logging.Configuration</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Console/" class="dropdown-item">Microsoft.Extensions.Logging.Console</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.EventLog/" class="dropdown-item">Microsoft.Extensions.Logging.EventLog</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.TraceSource/" class="dropdown-item">Microsoft.Extensions.Logging.TraceSource</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging/" class="dropdown-item">Microsoft.Extensions.Logging</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.ObjectPool/" class="dropdown-item">Microsoft.Extensions.ObjectPool</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Options/" class="dropdown-item">Microsoft.Extensions.Options</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Primitives/" class="dropdown-item">Microsoft.Extensions.Primitives</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.JSInterop.Infrastructure/" class="dropdown-item">Microsoft.JSInterop.Infrastructure</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.JSInterop/" class="dropdown-item">Microsoft.JSInterop</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_Microsoft.Net.Http.Headers/" class="dropdown-item">Microsoft.Net.Http.Headers</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_System.Diagnostics.Eventing.Reader/" class="dropdown-item">System.Diagnostics.Eventing.Reader</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_System.Security.Claims/" class="dropdown-item">System.Security.Claims</a>
</li>
                                    
<li>
    <a href="../../Microsoft.AspNetCore.App/7.0_System.Threading.RateLimiting/" class="dropdown-item">System.Threading.RateLimiting</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Microsoft.NETCore.App <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../7.0/" class="dropdown-item">API Difference 6.0 vs 7.0</a>
</li>
                                    
<li>
    <a href="../7.0_Microsoft.VisualBasic.FileIO/" class="dropdown-item">Microsoft.VisualBasic.FileIO</a>
</li>
                                    
<li>
    <a href="../7.0_Microsoft.Win32.SafeHandles/" class="dropdown-item">Microsoft.Win32.SafeHandles</a>
</li>
                                    
<li>
    <a href="../7.0_Microsoft.Win32/" class="dropdown-item">Microsoft.Win32</a>
</li>
                                    
<li>
    <a href="../7.0_System.Buffers/" class="dropdown-item">System.Buffers</a>
</li>
                                    
<li>
    <a href="../7.0_System.CodeDom.Compiler/" class="dropdown-item">System.CodeDom.Compiler</a>
</li>
                                    
<li>
    <a href="../7.0_System.Collections.Generic/" class="dropdown-item">System.Collections.Generic</a>
</li>
                                    
<li>
    <a href="../7.0_System.Collections.Immutable/" class="dropdown-item">System.Collections.Immutable</a>
</li>
                                    
<li>
    <a href="../7.0_System.Collections.Specialized/" class="dropdown-item">System.Collections.Specialized</a>
</li>
                                    
<li>
    <a href="../7.0_System.Collections/" class="dropdown-item">System.Collections</a>
</li>
                                    
<li>
    <a href="../7.0_System.ComponentModel.DataAnnotations/" class="dropdown-item">System.ComponentModel.DataAnnotations</a>
</li>
                                    
<li>
    <a href="../7.0_System.ComponentModel.Design.Serialization/" class="dropdown-item">System.ComponentModel.Design.Serialization</a>
</li>
                                    
<li>
    <a href="../7.0_System.ComponentModel/" class="dropdown-item">System.ComponentModel</a>
</li>
                                    
<li>
    <a href="../7.0_System.Data.Common/" class="dropdown-item">System.Data.Common</a>
</li>
                                    
<li>
    <a href="../7.0_System.Data.SqlTypes/" class="dropdown-item">System.Data.SqlTypes</a>
</li>
                                    
<li>
    <a href="../7.0_System.Data/" class="dropdown-item">System.Data</a>
</li>
                                    
<li>
    <a href="../7.0_System.Diagnostics.CodeAnalysis/" class="dropdown-item">System.Diagnostics.CodeAnalysis</a>
</li>
                                    
<li>
    <a href="../7.0_System.Diagnostics.Metrics/" class="dropdown-item">System.Diagnostics.Metrics</a>
</li>
                                    
<li>
    <a href="../7.0_System.Diagnostics.SymbolStore/" class="dropdown-item">System.Diagnostics.SymbolStore</a>
</li>
                                    
<li>
    <a href="../7.0_System.Diagnostics/" class="dropdown-item">System.Diagnostics</a>
</li>
                                    
<li>
    <a href="../7.0_System.Drawing/" class="dropdown-item">System.Drawing</a>
</li>
                                    
<li>
    <a href="../7.0_System.Formats.Asn1/" class="dropdown-item">System.Formats.Asn1</a>
</li>
                                    
<li>
    <a href="../7.0_System.Formats.Tar/" class="dropdown-item">System.Formats.Tar</a>
</li>
                                    
<li>
    <a href="../7.0_System.IO.Compression/" class="dropdown-item">System.IO.Compression</a>
</li>
                                    
<li>
    <a href="../7.0_System.IO.Pipes/" class="dropdown-item">System.IO.Pipes</a>
</li>
                                    
<li>
    <a href="../7.0_System.IO/" class="dropdown-item">System.IO</a>
</li>
                                    
<li>
    <a href="../7.0_System.Linq/" class="dropdown-item">System.Linq</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.Http.Headers/" class="dropdown-item">System.Net.Http.Headers</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.Http.Json/" class="dropdown-item">System.Net.Http.Json</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.Http/" class="dropdown-item">System.Net.Http</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.Mail/" class="dropdown-item">System.Net.Mail</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.NetworkInformation/" class="dropdown-item">System.Net.NetworkInformation</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.Quic/" class="dropdown-item">System.Net.Quic</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.Security/" class="dropdown-item">System.Net.Security</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.Sockets/" class="dropdown-item">System.Net.Sockets</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net.WebSockets/" class="dropdown-item">System.Net.WebSockets</a>
</li>
                                    
<li>
    <a href="../7.0_System.Net/" class="dropdown-item">System.Net</a>
</li>
                                    
<li>
    <a href="../7.0_System.Numerics/" class="dropdown-item">System.Numerics</a>
</li>
                                    
<li>
    <a href="../7.0_System.Reflection.Emit/" class="dropdown-item">System.Reflection.Emit</a>
</li>
                                    
<li>
    <a href="../7.0_System.Reflection.Metadata.Ecma335/" class="dropdown-item">System.Reflection.Metadata.Ecma335</a>
</li>
                                    
<li>
    <a href="../7.0_System.Reflection.Metadata/" class="dropdown-item">System.Reflection.Metadata</a>
</li>
                                    
<li>
    <a href="../7.0_System.Reflection.PortableExecutable/" class="dropdown-item">System.Reflection.PortableExecutable</a>
</li>
                                    
<li>
    <a href="../7.0_System.Reflection/" class="dropdown-item">System.Reflection</a>
</li>
                                    
<li>
    <a href="../7.0_System.Resources/" class="dropdown-item">System.Resources</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.CompilerServices/" class="dropdown-item">System.Runtime.CompilerServices</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.InteropServices.ComTypes/" class="dropdown-item">System.Runtime.InteropServices.ComTypes</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.InteropServices.JavaScript/" class="dropdown-item">System.Runtime.InteropServices.JavaScript</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.InteropServices.Marshalling/" class="dropdown-item">System.Runtime.InteropServices.Marshalling</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.InteropServices/" class="dropdown-item">System.Runtime.InteropServices</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.Intrinsics.Arm/" class="dropdown-item">System.Runtime.Intrinsics.Arm</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.Intrinsics.X86/" class="dropdown-item">System.Runtime.Intrinsics.X86</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.Intrinsics/" class="dropdown-item">System.Runtime.Intrinsics</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.Serialization.DataContracts/" class="dropdown-item">System.Runtime.Serialization.DataContracts</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.Serialization.Json/" class="dropdown-item">System.Runtime.Serialization.Json</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.Serialization/" class="dropdown-item">System.Runtime.Serialization</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime.Versioning/" class="dropdown-item">System.Runtime.Versioning</a>
</li>
                                    
<li>
    <a href="../7.0_System.Runtime/" class="dropdown-item">System.Runtime</a>
</li>
                                    
<li>
    <a href="../7.0_System.Security.Authentication.ExtendedProtection/" class="dropdown-item">System.Security.Authentication.ExtendedProtection</a>
</li>
                                    
<li>
    <a href="../7.0_System.Security.Authentication/" class="dropdown-item">System.Security.Authentication</a>
</li>
                                    
<li>
    <a href="../7.0_System.Security.Cryptography.X509Certificates/" class="dropdown-item">System.Security.Cryptography.X509Certificates</a>
</li>
                                    
<li>
    <a href="../7.0_System.Security.Cryptography/" class="dropdown-item">System.Security.Cryptography</a>
</li>
                                    
<li>
    <a href="../7.0_System.Security.Policy/" class="dropdown-item">System.Security.Policy</a>
</li>
                                    
<li>
    <a href="../7.0_System.Security/" class="dropdown-item">System.Security</a>
</li>
                                    
<li>
    <a href="../7.0_System.Text.Json.Nodes/" class="dropdown-item">System.Text.Json.Nodes</a>
</li>
                                    
<li>
    <a href="../7.0_System.Text.Json.Serialization.Metadata/" class="dropdown-item">System.Text.Json.Serialization.Metadata</a>
</li>
                                    
<li>
    <a href="../7.0_System.Text.Json.Serialization/" class="dropdown-item">System.Text.Json.Serialization</a>
</li>
                                    
<li>
    <a href="../7.0_System.Text.Json/" class="dropdown-item">System.Text.Json</a>
</li>
                                    
<li>
    <a href="../7.0_System.Text.RegularExpressions/" class="dropdown-item">System.Text.RegularExpressions</a>
</li>
                                    
<li>
    <a href="../7.0_System.Text.Unicode/" class="dropdown-item">System.Text.Unicode</a>
</li>
                                    
<li>
    <a href="../7.0_System.Text/" class="dropdown-item">System.Text</a>
</li>
                                    
<li>
    <a href="../7.0_System.Threading.Tasks.Dataflow/" class="dropdown-item">System.Threading.Tasks.Dataflow</a>
</li>
                                    
<li>
    <a href="../7.0_System.Threading.Tasks/" class="dropdown-item">System.Threading.Tasks</a>
</li>
                                    
<li>
    <a href="../7.0_System.Threading/" class="dropdown-item">System.Threading</a>
</li>
                                    
<li>
    <a href="../7.0_System.Timers/" class="dropdown-item">System.Timers</a>
</li>
                                    
<li>
    <a href="../7.0_System.Transactions/" class="dropdown-item">System.Transactions</a>
</li>
                                    
<li>
    <a href="../7.0_System.Web/" class="dropdown-item">System.Web</a>
</li>
                                    
<li>
    <a href="../7.0_System.Xml.Linq/" class="dropdown-item">System.Xml.Linq</a>
</li>
                                    
<li>
    <a href="../7.0_System.Xml.Schema/" class="dropdown-item">System.Xml.Schema</a>
</li>
                                    
<li>
    <a href="../7.0_System.Xml.Serialization/" class="dropdown-item">System.Xml.Serialization</a>
</li>
                                    
<li>
    <a href="../7.0_System.Xml.XPath/" class="dropdown-item">System.Xml.XPath</a>
</li>
                                    
<li>
    <a href="../7.0_System.Xml.Xsl/" class="dropdown-item">System.Xml.Xsl</a>
</li>
                                    
<li>
    <a href="../7.0_System.Xml/" class="dropdown-item">System.Xml</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">System</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Microsoft.WindowsDesktop.App <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0/" class="dropdown-item">API Difference 6.0 vs 7.0</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Diagnostics.Eventing.Reader/" class="dropdown-item">System.Diagnostics.Eventing.Reader</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Diagnostics/" class="dropdown-item">System.Diagnostics</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Drawing.Design/" class="dropdown-item">System.Drawing.Design</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Drawing.Imaging/" class="dropdown-item">System.Drawing.Imaging</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Drawing.Printing/" class="dropdown-item">System.Drawing.Printing</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Drawing/" class="dropdown-item">System.Drawing</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Resources.Tools/" class="dropdown-item">System.Resources.Tools</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Security.Cryptography.Pkcs/" class="dropdown-item">System.Security.Cryptography.Pkcs</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Security.Cryptography.X509Certificates/" class="dropdown-item">System.Security.Cryptography.X509Certificates</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Security.Permissions/" class="dropdown-item">System.Security.Permissions</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Security.Policy/" class="dropdown-item">System.Security.Policy</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.Design/" class="dropdown-item">System.Windows.Forms.Design</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.Layout/" class="dropdown-item">System.Windows.Forms.Layout</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.PropertyGridInternal/" class="dropdown-item">System.Windows.Forms.PropertyGridInternal</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms/" class="dropdown-item">System.Windows.Forms</a>
</li>
                                    
<li>
    <a href="../../Microsoft.WindowsDesktop.App/7.0_System.Xaml.Permissions/" class="dropdown-item">System.Xaml.Permissions</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../7.0_System.Xml/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../../Microsoft.WindowsDesktop.App/7.0/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#system" class="nav-link">System</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="system">System</h1>
<pre><code class="language-diff"> namespace System {
     public static class AppContext {
+        public static void SetData(string name, object? data);
     }
     public sealed class AppDomain : MarshalByRefObject {
         public static int GetCurrentThreadId();
     }
     public class ArgumentException : SystemException {
+        public static void ThrowIfNullOrEmpty(string argument, string paramName = null);
     }
     public class ArgumentNullException : ArgumentException {
+        public unsafe static void ThrowIfNull(void* argument, string? paramName = null);
     }
     public abstract class Array : ICloneable, ICollection, IEnumerable, IList, IStructuralComparable, IStructuralEquatable {
         public static Array CreateInstance(Type elementType, int length);
         public static Array CreateInstance(Type elementType, params int[] lengths);
         public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds);
         public static Array CreateInstance(Type elementType, params long[] lengths);
     }
-    public readonly struct Byte : IComparable, IComparable&lt;byte&gt;, IConvertible, IEquatable&lt;byte&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Byte : IAdditionOperators&lt;byte, byte, byte&gt;, IAdditiveIdentity&lt;byte, byte&gt;, IBinaryInteger&lt;byte&gt;, IBinaryNumber&lt;byte&gt;, IBitwiseOperators&lt;byte, byte, byte&gt;, IComparable, IComparable&lt;byte&gt;, IComparisonOperators&lt;byte, byte, bool&gt;, IConvertible, IDecrementOperators&lt;byte&gt;, IDivisionOperators&lt;byte, byte, byte&gt;, IEqualityOperators&lt;byte, byte, bool&gt;, IEquatable&lt;byte&gt;, IFormattable, IIncrementOperators&lt;byte&gt;, IMinMaxValue&lt;byte&gt;, IModulusOperators&lt;byte, byte, byte&gt;, IMultiplicativeIdentity&lt;byte, byte&gt;, IMultiplyOperators&lt;byte, byte, byte&gt;, INumber&lt;byte&gt;, INumberBase&lt;byte&gt;, IParsable&lt;byte&gt;, IShiftOperators&lt;byte, int, byte&gt;, ISpanFormattable, ISpanParsable&lt;byte&gt;, ISubtractionOperators&lt;byte, byte, byte&gt;, IUnaryNegationOperators&lt;byte, byte&gt;, IUnaryPlusOperators&lt;byte, byte&gt;, IUnsignedNumber&lt;byte&gt; {
+        static byte System.Numerics.IAdditiveIdentity&lt;System.Byte,System.Byte&gt;.AdditiveIdentity { get; }
+        static byte System.Numerics.IBinaryNumber&lt;System.Byte&gt;.AllBitsSet { get; }
+        static byte System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MaxValue { get; }
+        static byte System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MinValue { get; }
+        static byte System.Numerics.IMultiplicativeIdentity&lt;System.Byte,System.Byte&gt;.MultiplicativeIdentity { get; }
+        static byte System.Numerics.INumberBase&lt;System.Byte&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Byte&gt;.Radix { get; }
+        static byte System.Numerics.INumberBase&lt;System.Byte&gt;.Zero { get; }
+        public static byte Clamp(byte value, byte min, byte max);
+        public static byte CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static byte CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static byte CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (byte Quotient, byte Remainder) DivRem(byte left, byte right);
+        public static bool IsEvenInteger(byte value);
+        public static bool IsOddInteger(byte value);
+        public static bool IsPow2(byte value);
+        public static byte LeadingZeroCount(byte value);
+        public static byte Log2(byte value);
+        public static byte Max(byte x, byte y);
+        public static byte Min(byte x, byte y);
+        public static byte Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static byte PopCount(byte value);
+        public static byte RotateLeft(byte value, int rotateAmount);
+        public static byte RotateRight(byte value, int rotateAmount);
+        public static int Sign(byte value);
+        static byte IAdditionOperators&lt;byte, byte, byte&gt;.operator +(byte left, byte right);
+        static byte IAdditionOperators&lt;byte, byte, byte&gt;.operator checked +(byte left, byte right);
+        int IBinaryInteger&lt;byte&gt;.GetByteCount();
+        int IBinaryInteger&lt;byte&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;byte&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out byte value);
+        static bool IBinaryInteger&lt;byte&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out byte value);
+        bool IBinaryInteger&lt;byte&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;byte&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static byte IBitwiseOperators&lt;byte, byte, byte&gt;.operator &amp;(byte left, byte right);
+        static byte IBitwiseOperators&lt;byte, byte, byte&gt;.operator |(byte left, byte right);
+        static byte IBitwiseOperators&lt;byte, byte, byte&gt;.operator ^(byte left, byte right);
+        static byte IBitwiseOperators&lt;byte, byte, byte&gt;.operator ~(byte value);
+        static bool IComparisonOperators&lt;byte, byte, bool&gt;.operator &gt;(byte left, byte right);
+        static bool IComparisonOperators&lt;byte, byte, bool&gt;.operator &gt;=(byte left, byte right);
+        static bool IComparisonOperators&lt;byte, byte, bool&gt;.operator &lt;(byte left, byte right);
+        static bool IComparisonOperators&lt;byte, byte, bool&gt;.operator &lt;=(byte left, byte right);
+        static byte IDecrementOperators&lt;byte&gt;.operator checked --(byte value);
+        static byte IDecrementOperators&lt;byte&gt;.operator --(byte value);
+        static byte IDivisionOperators&lt;byte, byte, byte&gt;.operator /(byte left, byte right);
+        static bool IEqualityOperators&lt;byte, byte, bool&gt;.operator ==(byte left, byte right);
+        static bool IEqualityOperators&lt;byte, byte, bool&gt;.operator !=(byte left, byte right);
+        static byte IIncrementOperators&lt;byte&gt;.operator checked ++(byte value);
+        static byte IIncrementOperators&lt;byte&gt;.operator ++(byte value);
+        static byte IModulusOperators&lt;byte, byte, byte&gt;.operator %(byte left, byte right);
+        static byte IMultiplyOperators&lt;byte, byte, byte&gt;.operator checked *(byte left, byte right);
+        static byte IMultiplyOperators&lt;byte, byte, byte&gt;.operator *(byte left, byte right);
+        static byte INumber&lt;byte&gt;.CopySign(byte value, byte sign);
+        static byte INumber&lt;byte&gt;.MaxNumber(byte x, byte y);
+        static byte INumber&lt;byte&gt;.MinNumber(byte x, byte y);
+        static byte INumberBase&lt;byte&gt;.Abs(byte value);
+        static bool INumberBase&lt;byte&gt;.IsCanonical(byte value);
+        static bool INumberBase&lt;byte&gt;.IsComplexNumber(byte value);
+        static bool INumberBase&lt;byte&gt;.IsFinite(byte value);
+        static bool INumberBase&lt;byte&gt;.IsImaginaryNumber(byte value);
+        static bool INumberBase&lt;byte&gt;.IsInfinity(byte value);
+        static bool INumberBase&lt;byte&gt;.IsInteger(byte value);
+        static bool INumberBase&lt;byte&gt;.IsNaN(byte value);
+        static bool INumberBase&lt;byte&gt;.IsNegative(byte value);
+        static bool INumberBase&lt;byte&gt;.IsNegativeInfinity(byte value);
+        static bool INumberBase&lt;byte&gt;.IsNormal(byte value);
+        static bool INumberBase&lt;byte&gt;.IsPositive(byte value);
+        static bool INumberBase&lt;byte&gt;.IsPositiveInfinity(byte value);
+        static bool INumberBase&lt;byte&gt;.IsRealNumber(byte value);
+        static bool INumberBase&lt;byte&gt;.IsSubnormal(byte value);
+        static bool INumberBase&lt;byte&gt;.IsZero(byte value);
+        static byte INumberBase&lt;byte&gt;.MaxMagnitude(byte x, byte y);
+        static byte INumberBase&lt;byte&gt;.MaxMagnitudeNumber(byte x, byte y);
+        static byte INumberBase&lt;byte&gt;.MinMagnitude(byte x, byte y);
+        static byte INumberBase&lt;byte&gt;.MinMagnitudeNumber(byte x, byte y);
+        static bool INumberBase&lt;byte&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out byte result);
+        static bool INumberBase&lt;byte&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out byte result);
+        static bool INumberBase&lt;byte&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out byte result);
+        static bool INumberBase&lt;byte&gt;.TryConvertToChecked&lt;TOther&gt;(byte value, out TOther result);
+        static bool INumberBase&lt;byte&gt;.TryConvertToSaturating&lt;TOther&gt;(byte value, out TOther result);
+        static bool INumberBase&lt;byte&gt;.TryConvertToTruncating&lt;TOther&gt;(byte value, out TOther result);
+        static byte IShiftOperators&lt;byte, int, byte&gt;.operator &lt;&lt;(byte value, int shiftAmount);
+        static byte IShiftOperators&lt;byte, int, byte&gt;.operator &gt;&gt;(byte value, int shiftAmount);
+        static byte IShiftOperators&lt;byte, int, byte&gt;.operator &gt;&gt;&gt;(byte value, int shiftAmount);
+        static byte ISubtractionOperators&lt;byte, byte, byte&gt;.operator checked -(byte left, byte right);
+        static byte ISubtractionOperators&lt;byte, byte, byte&gt;.operator -(byte left, byte right);
+        static byte IUnaryNegationOperators&lt;byte, byte&gt;.operator checked -(byte value);
+        static byte IUnaryNegationOperators&lt;byte, byte&gt;.operator -(byte value);
+        static byte IUnaryPlusOperators&lt;byte, byte&gt;.operator +(byte value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static byte TrailingZeroCount(byte value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out byte result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out byte result);
     }
-    public readonly struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Char : IAdditionOperators&lt;char, char, char&gt;, IAdditiveIdentity&lt;char, char&gt;, IBinaryInteger&lt;char&gt;, IBinaryNumber&lt;char&gt;, IBitwiseOperators&lt;char, char, char&gt;, IComparable, IComparable&lt;char&gt;, IComparisonOperators&lt;char, char, bool&gt;, IConvertible, IDecrementOperators&lt;char&gt;, IDivisionOperators&lt;char, char, char&gt;, IEqualityOperators&lt;char, char, bool&gt;, IEquatable&lt;char&gt;, IFormattable, IIncrementOperators&lt;char&gt;, IMinMaxValue&lt;char&gt;, IModulusOperators&lt;char, char, char&gt;, IMultiplicativeIdentity&lt;char, char&gt;, IMultiplyOperators&lt;char, char, char&gt;, INumber&lt;char&gt;, INumberBase&lt;char&gt;, IParsable&lt;char&gt;, IShiftOperators&lt;char, int, char&gt;, ISpanFormattable, ISpanParsable&lt;char&gt;, ISubtractionOperators&lt;char, char, char&gt;, IUnaryNegationOperators&lt;char, char&gt;, IUnaryPlusOperators&lt;char, char&gt;, IUnsignedNumber&lt;char&gt; {
+        static char System.Numerics.IAdditiveIdentity&lt;System.Char,System.Char&gt;.AdditiveIdentity { get; }
+        static char System.Numerics.IBinaryNumber&lt;System.Char&gt;.AllBitsSet { get; }
+        static char System.Numerics.IMinMaxValue&lt;System.Char&gt;.MaxValue { get; }
+        static char System.Numerics.IMinMaxValue&lt;System.Char&gt;.MinValue { get; }
+        static char System.Numerics.IMultiplicativeIdentity&lt;System.Char,System.Char&gt;.MultiplicativeIdentity { get; }
+        static char System.Numerics.INumberBase&lt;System.Char&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Char&gt;.Radix { get; }
+        static char System.Numerics.INumberBase&lt;System.Char&gt;.Zero { get; }
+        public static bool IsAsciiDigit(char c);
+        public static bool IsAsciiHexDigit(char c);
+        public static bool IsAsciiHexDigitLower(char c);
+        public static bool IsAsciiHexDigitUpper(char c);
+        public static bool IsAsciiLetter(char c);
+        public static bool IsAsciiLetterLower(char c);
+        public static bool IsAsciiLetterOrDigit(char c);
+        public static bool IsAsciiLetterUpper(char c);
+        public static bool IsBetween(char c, char minInclusive, char maxInclusive);
+        static char IParsable&lt;char&gt;.Parse(string s, IFormatProvider provider);
+        static bool IParsable&lt;char&gt;.TryParse(string s, IFormatProvider provider, out char result);
+        static char ISpanParsable&lt;char&gt;.Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider provider);
+        static bool ISpanParsable&lt;char&gt;.TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider provider, out char result);
+        static char IAdditionOperators&lt;char, char, char&gt;.operator +(char left, char right);
+        static char IAdditionOperators&lt;char, char, char&gt;.operator checked +(char left, char right);
+        int IBinaryInteger&lt;char&gt;.GetByteCount();
+        int IBinaryInteger&lt;char&gt;.GetShortestBitLength();
+        static char IBinaryInteger&lt;char&gt;.LeadingZeroCount(char value);
+        static char IBinaryInteger&lt;char&gt;.PopCount(char value);
+        static char IBinaryInteger&lt;char&gt;.RotateLeft(char value, int rotateAmount);
+        static char IBinaryInteger&lt;char&gt;.RotateRight(char value, int rotateAmount);
+        static char IBinaryInteger&lt;char&gt;.TrailingZeroCount(char value);
+        static bool IBinaryInteger&lt;char&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out char value);
+        static bool IBinaryInteger&lt;char&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out char value);
+        bool IBinaryInteger&lt;char&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;char&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static bool IBinaryNumber&lt;char&gt;.IsPow2(char value);
+        static char IBinaryNumber&lt;char&gt;.Log2(char value);
+        static char IBitwiseOperators&lt;char, char, char&gt;.operator &amp;(char left, char right);
+        static char IBitwiseOperators&lt;char, char, char&gt;.operator |(char left, char right);
+        static char IBitwiseOperators&lt;char, char, char&gt;.operator ^(char left, char right);
+        static char IBitwiseOperators&lt;char, char, char&gt;.operator ~(char value);
+        static bool IComparisonOperators&lt;char, char, bool&gt;.operator &gt;(char left, char right);
+        static bool IComparisonOperators&lt;char, char, bool&gt;.operator &gt;=(char left, char right);
+        static bool IComparisonOperators&lt;char, char, bool&gt;.operator &lt;(char left, char right);
+        static bool IComparisonOperators&lt;char, char, bool&gt;.operator &lt;=(char left, char right);
+        static char IDecrementOperators&lt;char&gt;.operator checked --(char value);
+        static char IDecrementOperators&lt;char&gt;.operator --(char value);
+        static char IDivisionOperators&lt;char, char, char&gt;.operator /(char left, char right);
+        static bool IEqualityOperators&lt;char, char, bool&gt;.operator ==(char left, char right);
+        static bool IEqualityOperators&lt;char, char, bool&gt;.operator !=(char left, char right);
+        static char IIncrementOperators&lt;char&gt;.operator checked ++(char value);
+        static char IIncrementOperators&lt;char&gt;.operator ++(char value);
+        static char IModulusOperators&lt;char, char, char&gt;.operator %(char left, char right);
+        static char IMultiplyOperators&lt;char, char, char&gt;.operator checked *(char left, char right);
+        static char IMultiplyOperators&lt;char, char, char&gt;.operator *(char left, char right);
+        static char INumberBase&lt;char&gt;.Abs(char value);
+        static bool INumberBase&lt;char&gt;.IsCanonical(char value);
+        static bool INumberBase&lt;char&gt;.IsComplexNumber(char value);
+        static bool INumberBase&lt;char&gt;.IsEvenInteger(char value);
+        static bool INumberBase&lt;char&gt;.IsFinite(char value);
+        static bool INumberBase&lt;char&gt;.IsImaginaryNumber(char value);
+        static bool INumberBase&lt;char&gt;.IsInfinity(char value);
+        static bool INumberBase&lt;char&gt;.IsInteger(char value);
+        static bool INumberBase&lt;char&gt;.IsNaN(char value);
+        static bool INumberBase&lt;char&gt;.IsNegative(char value);
+        static bool INumberBase&lt;char&gt;.IsNegativeInfinity(char value);
+        static bool INumberBase&lt;char&gt;.IsNormal(char value);
+        static bool INumberBase&lt;char&gt;.IsOddInteger(char value);
+        static bool INumberBase&lt;char&gt;.IsPositive(char value);
+        static bool INumberBase&lt;char&gt;.IsPositiveInfinity(char value);
+        static bool INumberBase&lt;char&gt;.IsRealNumber(char value);
+        static bool INumberBase&lt;char&gt;.IsSubnormal(char value);
+        static bool INumberBase&lt;char&gt;.IsZero(char value);
+        static char INumberBase&lt;char&gt;.MaxMagnitude(char x, char y);
+        static char INumberBase&lt;char&gt;.MaxMagnitudeNumber(char x, char y);
+        static char INumberBase&lt;char&gt;.MinMagnitude(char x, char y);
+        static char INumberBase&lt;char&gt;.MinMagnitudeNumber(char x, char y);
+        static char INumberBase&lt;char&gt;.Parse(ReadOnlySpan&lt;char&gt; s, NumberStyles style, IFormatProvider provider);
+        static char INumberBase&lt;char&gt;.Parse(string s, NumberStyles style, IFormatProvider provider);
+        static bool INumberBase&lt;char&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out char result);
+        static bool INumberBase&lt;char&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out char result);
+        static bool INumberBase&lt;char&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out char result);
+        static bool INumberBase&lt;char&gt;.TryConvertToChecked&lt;TOther&gt;(char value, out TOther result);
+        static bool INumberBase&lt;char&gt;.TryConvertToSaturating&lt;TOther&gt;(char value, out TOther result);
+        static bool INumberBase&lt;char&gt;.TryConvertToTruncating&lt;TOther&gt;(char value, out TOther result);
+        static bool INumberBase&lt;char&gt;.TryParse(ReadOnlySpan&lt;char&gt; s, NumberStyles style, IFormatProvider provider, out char result);
+        static bool INumberBase&lt;char&gt;.TryParse(string s, NumberStyles style, IFormatProvider provider, out char result);
+        static char IShiftOperators&lt;char, int, char&gt;.operator &lt;&lt;(char value, int shiftAmount);
+        static char IShiftOperators&lt;char, int, char&gt;.operator &gt;&gt;(char value, int shiftAmount);
+        static char IShiftOperators&lt;char, int, char&gt;.operator &gt;&gt;&gt;(char value, int shiftAmount);
+        static char ISubtractionOperators&lt;char, char, char&gt;.operator checked -(char left, char right);
+        static char ISubtractionOperators&lt;char, char, char&gt;.operator -(char left, char right);
+        static char IUnaryNegationOperators&lt;char, char&gt;.operator checked -(char value);
+        static char IUnaryNegationOperators&lt;char, char&gt;.operator -(char value);
+        static char IUnaryPlusOperators&lt;char, char&gt;.operator +(char value);
     }
     public static class Console {
         public static void Write(string format, object? arg0);
         public static void Write(string format, object? arg0, object? arg1);
         public static void Write(string format, object? arg0, object? arg1, object? arg2);
         public static void Write(string format, params object?[]? arg);
         public static void WriteLine(string format, object? arg0);
         public static void WriteLine(string format, object? arg0, object? arg1);
         public static void WriteLine(string format, object? arg0, object? arg1, object? arg2);
         public static void WriteLine(string format, params object?[]? arg);
     }
-    public readonly struct DateOnly : IComparable, IComparable&lt;DateOnly&gt;, IEquatable&lt;DateOnly&gt;, IFormattable, ISpanFormattable {
+    public readonly struct DateOnly : IComparable, IComparable&lt;DateOnly&gt;, IEquatable&lt;DateOnly&gt;, IFormattable, IParsable&lt;DateOnly&gt;, ISpanFormattable, ISpanParsable&lt;DateOnly&gt; {
+        public static DateOnly Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static DateOnly Parse(string s, IFormatProvider? provider);
         public static DateOnly ParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider = null, DateTimeStyles style = DateTimeStyles.None);
         public static DateOnly ParseExact(ReadOnlySpan&lt;char&gt; s, string[] formats);
         public static DateOnly ParseExact(ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public static DateOnly ParseExact(string s, string format);
         public static DateOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public static DateOnly ParseExact(string s, string[] formats);
         public static DateOnly ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out DateOnly result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out DateOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, out DateOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider, DateTimeStyles style, out DateOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, string?[]? formats, out DateOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly result);
         public static bool TryParseExact(string? s, string? format, out DateOnly result);
         public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out DateOnly result);
         public static bool TryParseExact(string? s, string?[]? formats, out DateOnly result);
         public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly result);
     }
-    public readonly struct DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, ISerializable, ISpanFormattable {
+    public readonly struct DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, IParsable&lt;DateTime&gt;, ISerializable, ISpanFormattable, ISpanParsable&lt;DateTime&gt; {
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, DateTimeKind kind);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, DateTimeKind kind);
+        public int Microsecond { get; }
+        public int Nanosecond { get; }
+        public DateTime AddMicroseconds(double value);
+        public static DateTime Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
         public static DateTime ParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public static DateTime ParseExact(ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public static DateTime ParseExact(string s, string format, IFormatProvider? provider);
         public static DateTime ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style);
         public static DateTime ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out DateTime result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out DateTime result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider, DateTimeStyles style, out DateTime result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateTime result);
         public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out DateTime result);
         public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateTime result);
     }
-    public readonly struct DateTimeOffset : IComparable, IComparable&lt;DateTimeOffset&gt;, IDeserializationCallback, IEquatable&lt;DateTimeOffset&gt;, IFormattable, ISerializable, ISpanFormattable {
+    public readonly struct DateTimeOffset : IComparable, IComparable&lt;DateTimeOffset&gt;, IDeserializationCallback, IEquatable&lt;DateTimeOffset&gt;, IFormattable, IParsable&lt;DateTimeOffset&gt;, ISerializable, ISpanFormattable, ISpanParsable&lt;DateTimeOffset&gt; {
+        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, TimeSpan offset);
+        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, TimeSpan offset);
+        public int Microsecond { get; }
+        public int Nanosecond { get; }
+        public DateTimeOffset AddMicroseconds(double microseconds);
+        public static DateTimeOffset Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
         public static DateTimeOffset ParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider? formatProvider, DateTimeStyles styles = DateTimeStyles.None);
         public static DateTimeOffset ParseExact(ReadOnlySpan&lt;char&gt; input, string[] formats, IFormatProvider? formatProvider, DateTimeStyles styles = DateTimeStyles.None);
         public static DateTimeOffset ParseExact(string input, string format, IFormatProvider? formatProvider);
         public static DateTimeOffset ParseExact(string input, string format, IFormatProvider? formatProvider, DateTimeStyles styles);
         public static DateTimeOffset ParseExact(string input, string[] formats, IFormatProvider? formatProvider, DateTimeStyles styles);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? formatProvider);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? formatProvider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out DateTimeOffset result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out DateTimeOffset result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, string?[]? formats, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result);
         public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result);
         public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result);
     }
-    public readonly struct Decimal : IComparable, IComparable&lt;decimal&gt;, IConvertible, IDeserializationCallback, IEquatable&lt;decimal&gt;, IFormattable, ISerializable, ISpanFormattable {
+    public readonly struct Decimal : IAdditionOperators&lt;decimal, decimal, decimal&gt;, IAdditiveIdentity&lt;decimal, decimal&gt;, IComparable, IComparable&lt;decimal&gt;, IComparisonOperators&lt;decimal, decimal, bool&gt;, IConvertible, IDecrementOperators&lt;decimal&gt;, IDeserializationCallback, IDivisionOperators&lt;decimal, decimal, decimal&gt;, IEqualityOperators&lt;decimal, decimal, bool&gt;, IEquatable&lt;decimal&gt;, IFloatingPoint&lt;decimal&gt;, IFloatingPointConstants&lt;decimal&gt;, IFormattable, IIncrementOperators&lt;decimal&gt;, IMinMaxValue&lt;decimal&gt;, IModulusOperators&lt;decimal, decimal, decimal&gt;, IMultiplicativeIdentity&lt;decimal, decimal&gt;, IMultiplyOperators&lt;decimal, decimal, decimal&gt;, INumber&lt;decimal&gt;, INumberBase&lt;decimal&gt;, IParsable&lt;decimal&gt;, ISerializable, ISignedNumber&lt;decimal&gt;, ISpanFormattable, ISpanParsable&lt;decimal&gt;, ISubtractionOperators&lt;decimal, decimal, decimal&gt;, IUnaryNegationOperators&lt;decimal, decimal&gt;, IUnaryPlusOperators&lt;decimal, decimal&gt; {
+        public byte Scale { get; }
+        static decimal System.Numerics.IAdditiveIdentity&lt;System.Decimal,System.Decimal&gt;.AdditiveIdentity { get; }
+        static decimal System.Numerics.IFloatingPointConstants&lt;System.Decimal&gt;.E { get; }
+        static decimal System.Numerics.IFloatingPointConstants&lt;System.Decimal&gt;.Pi { get; }
+        static decimal System.Numerics.IFloatingPointConstants&lt;System.Decimal&gt;.Tau { get; }
+        static decimal System.Numerics.IMinMaxValue&lt;System.Decimal&gt;.MaxValue { get; }
+        static decimal System.Numerics.IMinMaxValue&lt;System.Decimal&gt;.MinValue { get; }
+        static decimal System.Numerics.IMultiplicativeIdentity&lt;System.Decimal,System.Decimal&gt;.MultiplicativeIdentity { get; }
+        static decimal System.Numerics.INumberBase&lt;System.Decimal&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Decimal&gt;.Radix { get; }
+        static decimal System.Numerics.INumberBase&lt;System.Decimal&gt;.Zero { get; }
+        static decimal System.Numerics.ISignedNumber&lt;System.Decimal&gt;.NegativeOne { get; }
+        public static decimal Abs(decimal value);
+        public static decimal Clamp(decimal value, decimal min, decimal max);
+        public static decimal CopySign(decimal value, decimal sign);
+        public static decimal CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static decimal CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static decimal CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static bool IsCanonical(decimal value);
+        public static bool IsEvenInteger(decimal value);
+        public static bool IsInteger(decimal value);
+        public static bool IsNegative(decimal value);
+        public static bool IsOddInteger(decimal value);
+        public static bool IsPositive(decimal value);
+        public static decimal Max(decimal x, decimal y);
+        public static decimal MaxMagnitude(decimal x, decimal y);
+        public static decimal Min(decimal x, decimal y);
+        public static decimal MinMagnitude(decimal x, decimal y);
+        public static decimal Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static int Sign(decimal d);
+        int IFloatingPoint&lt;decimal&gt;.GetExponentByteCount();
+        int IFloatingPoint&lt;decimal&gt;.GetExponentShortestBitLength();
+        int IFloatingPoint&lt;decimal&gt;.GetSignificandBitLength();
+        int IFloatingPoint&lt;decimal&gt;.GetSignificandByteCount();
+        bool IFloatingPoint&lt;decimal&gt;.TryWriteExponentBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;decimal&gt;.TryWriteExponentLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;decimal&gt;.TryWriteSignificandBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;decimal&gt;.TryWriteSignificandLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static decimal INumber&lt;decimal&gt;.MaxNumber(decimal x, decimal y);
+        static decimal INumber&lt;decimal&gt;.MinNumber(decimal x, decimal y);
+        static bool INumberBase&lt;decimal&gt;.IsComplexNumber(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsFinite(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsImaginaryNumber(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsInfinity(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsNaN(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsNegativeInfinity(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsNormal(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsPositiveInfinity(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsRealNumber(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsSubnormal(decimal value);
+        static bool INumberBase&lt;decimal&gt;.IsZero(decimal value);
+        static decimal INumberBase&lt;decimal&gt;.MaxMagnitudeNumber(decimal x, decimal y);
+        static decimal INumberBase&lt;decimal&gt;.MinMagnitudeNumber(decimal x, decimal y);
+        static bool INumberBase&lt;decimal&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out decimal result);
+        static bool INumberBase&lt;decimal&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out decimal result);
+        static bool INumberBase&lt;decimal&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out decimal result);
+        static bool INumberBase&lt;decimal&gt;.TryConvertToChecked&lt;TOther&gt;(decimal value, out TOther result);
+        static bool INumberBase&lt;decimal&gt;.TryConvertToSaturating&lt;TOther&gt;(decimal value, out TOther result);
+        static bool INumberBase&lt;decimal&gt;.TryConvertToTruncating&lt;TOther&gt;(decimal value, out TOther result);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out decimal result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out decimal result);
     }
-    public readonly struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Double : IAdditionOperators&lt;double, double, double&gt;, IAdditiveIdentity&lt;double, double&gt;, IBinaryFloatingPointIeee754&lt;double&gt;, IBinaryNumber&lt;double&gt;, IBitwiseOperators&lt;double, double, double&gt;, IComparable, IComparable&lt;double&gt;, IComparisonOperators&lt;double, double, bool&gt;, IConvertible, IDecrementOperators&lt;double&gt;, IDivisionOperators&lt;double, double, double&gt;, IEqualityOperators&lt;double, double, bool&gt;, IEquatable&lt;double&gt;, IExponentialFunctions&lt;double&gt;, IFloatingPoint&lt;double&gt;, IFloatingPointConstants&lt;double&gt;, IFloatingPointIeee754&lt;double&gt;, IFormattable, IHyperbolicFunctions&lt;double&gt;, IIncrementOperators&lt;double&gt;, ILogarithmicFunctions&lt;double&gt;, IMinMaxValue&lt;double&gt;, IModulusOperators&lt;double, double, double&gt;, IMultiplicativeIdentity&lt;double, double&gt;, IMultiplyOperators&lt;double, double, double&gt;, INumber&lt;double&gt;, INumberBase&lt;double&gt;, IParsable&lt;double&gt;, IPowerFunctions&lt;double&gt;, IRootFunctions&lt;double&gt;, ISignedNumber&lt;double&gt;, ISpanFormattable, ISpanParsable&lt;double&gt;, ISubtractionOperators&lt;double, double, double&gt;, ITrigonometricFunctions&lt;double&gt;, IUnaryNegationOperators&lt;double, double&gt;, IUnaryPlusOperators&lt;double, double&gt; {
+        public const double E = 2.718281828459045;
+        public const double NegativeZero = 0;
+        public const double Pi = 3.141592653589793;
+        public const double Tau = 6.283185307179586;
+        static double System.Numerics.IAdditiveIdentity&lt;System.Double,System.Double&gt;.AdditiveIdentity { get; }
+        static double System.Numerics.IBinaryNumber&lt;System.Double&gt;.AllBitsSet { get; }
+        static double System.Numerics.IFloatingPointConstants&lt;System.Double&gt;.E { get; }
+        static double System.Numerics.IFloatingPointConstants&lt;System.Double&gt;.Pi { get; }
+        static double System.Numerics.IFloatingPointConstants&lt;System.Double&gt;.Tau { get; }
+        static double System.Numerics.IFloatingPointIeee754&lt;System.Double&gt;.Epsilon { get; }
+        static double System.Numerics.IFloatingPointIeee754&lt;System.Double&gt;.NaN { get; }
+        static double System.Numerics.IFloatingPointIeee754&lt;System.Double&gt;.NegativeInfinity { get; }
+        static double System.Numerics.IFloatingPointIeee754&lt;System.Double&gt;.NegativeZero { get; }
+        static double System.Numerics.IFloatingPointIeee754&lt;System.Double&gt;.PositiveInfinity { get; }
+        static double System.Numerics.IMinMaxValue&lt;System.Double&gt;.MaxValue { get; }
+        static double System.Numerics.IMinMaxValue&lt;System.Double&gt;.MinValue { get; }
+        static double System.Numerics.IMultiplicativeIdentity&lt;System.Double,System.Double&gt;.MultiplicativeIdentity { get; }
+        static double System.Numerics.INumberBase&lt;System.Double&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Double&gt;.Radix { get; }
+        static double System.Numerics.INumberBase&lt;System.Double&gt;.Zero { get; }
+        static double System.Numerics.ISignedNumber&lt;System.Double&gt;.NegativeOne { get; }
+        public static double Abs(double value);
+        public static double Acos(double x);
+        public static double Acosh(double x);
+        public static double AcosPi(double x);
+        public static double Asin(double x);
+        public static double Asinh(double x);
+        public static double AsinPi(double x);
+        public static double Atan(double x);
+        public static double Atan2(double y, double x);
+        public static double Atan2Pi(double y, double x);
+        public static double Atanh(double x);
+        public static double AtanPi(double x);
+        public static double BitDecrement(double x);
+        public static double BitIncrement(double x);
+        public static double Cbrt(double x);
+        public static double Ceiling(double x);
+        public static double Clamp(double value, double min, double max);
+        public static double CopySign(double value, double sign);
+        public static double Cos(double x);
+        public static double Cosh(double x);
+        public static double CosPi(double x);
+        public static double CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static double CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static double CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static double Exp(double x);
+        public static double Exp10(double x);
+        public static double Exp10M1(double x);
+        public static double Exp2(double x);
+        public static double Exp2M1(double x);
+        public static double ExpM1(double x);
+        public static double Floor(double x);
+        public static double FusedMultiplyAdd(double left, double right, double addend);
+        public static double Hypot(double x, double y);
+        public static double Ieee754Remainder(double left, double right);
+        public static int ILogB(double x);
+        public static bool IsEvenInteger(double value);
+        public static bool IsInteger(double value);
+        public static bool IsOddInteger(double value);
+        public static bool IsPositive(double value);
+        public static bool IsPow2(double value);
+        public static bool IsRealNumber(double value);
+        public static double Log(double x);
+        public static double Log(double x, double newBase);
+        public static double Log10(double x);
+        public static double Log10P1(double x);
+        public static double Log2(double value);
+        public static double Log2P1(double x);
+        public static double LogP1(double x);
+        public static double Max(double x, double y);
+        public static double MaxMagnitude(double x, double y);
+        public static double MaxMagnitudeNumber(double x, double y);
+        public static double MaxNumber(double x, double y);
+        public static double Min(double x, double y);
+        public static double MinMagnitude(double x, double y);
+        public static double MinMagnitudeNumber(double x, double y);
+        public static double MinNumber(double x, double y);
+        public static double Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static double Pow(double x, double y);
+        public static double ReciprocalEstimate(double x);
+        public static double ReciprocalSqrtEstimate(double x);
+        public static double RootN(double x, int n);
+        public static double Round(double x);
+        public static double Round(double x, int digits);
+        public static double Round(double x, int digits, MidpointRounding mode);
+        public static double Round(double x, MidpointRounding mode);
+        public static double ScaleB(double x, int n);
+        public static int Sign(double value);
+        public static double Sin(double x);
+        public static (double Sin, double Cos) SinCos(double x);
+        public static (double SinPi, double CosPi) SinCosPi(double x);
+        public static double Sinh(double x);
+        public static double SinPi(double x);
+        public static double Sqrt(double x);
+        static double IAdditionOperators&lt;double, double, double&gt;.operator +(double left, double right);
+        static double IBitwiseOperators&lt;double, double, double&gt;.operator &amp;(double left, double right);
+        static double IBitwiseOperators&lt;double, double, double&gt;.operator |(double left, double right);
+        static double IBitwiseOperators&lt;double, double, double&gt;.operator ^(double left, double right);
+        static double IBitwiseOperators&lt;double, double, double&gt;.operator ~(double value);
+        static double IDecrementOperators&lt;double&gt;.operator --(double value);
+        static double IDivisionOperators&lt;double, double, double&gt;.operator /(double left, double right);
+        int IFloatingPoint&lt;double&gt;.GetExponentByteCount();
+        int IFloatingPoint&lt;double&gt;.GetExponentShortestBitLength();
+        int IFloatingPoint&lt;double&gt;.GetSignificandBitLength();
+        int IFloatingPoint&lt;double&gt;.GetSignificandByteCount();
+        bool IFloatingPoint&lt;double&gt;.TryWriteExponentBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;double&gt;.TryWriteExponentLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;double&gt;.TryWriteSignificandBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;double&gt;.TryWriteSignificandLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static double IIncrementOperators&lt;double&gt;.operator ++(double value);
+        static double IModulusOperators&lt;double, double, double&gt;.operator %(double left, double right);
+        static double IMultiplyOperators&lt;double, double, double&gt;.operator *(double left, double right);
+        static bool INumberBase&lt;double&gt;.IsCanonical(double value);
+        static bool INumberBase&lt;double&gt;.IsComplexNumber(double value);
+        static bool INumberBase&lt;double&gt;.IsImaginaryNumber(double value);
+        static bool INumberBase&lt;double&gt;.IsZero(double value);
+        static bool INumberBase&lt;double&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out double result);
+        static bool INumberBase&lt;double&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out double result);
+        static bool INumberBase&lt;double&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out double result);
+        static bool INumberBase&lt;double&gt;.TryConvertToChecked&lt;TOther&gt;(double value, out TOther result);
+        static bool INumberBase&lt;double&gt;.TryConvertToSaturating&lt;TOther&gt;(double value, out TOther result);
+        static bool INumberBase&lt;double&gt;.TryConvertToTruncating&lt;TOther&gt;(double value, out TOther result);
+        static double ISubtractionOperators&lt;double, double, double&gt;.operator -(double left, double right);
+        static double IUnaryNegationOperators&lt;double, double&gt;.operator -(double value);
+        static double IUnaryPlusOperators&lt;double, double&gt;.operator +(double value);
+        public static double Tan(double x);
+        public static double Tanh(double x);
+        public static double TanPi(double x);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static double Truncate(double x);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out double result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out double result);
     }
     public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable {
         public static string Format(Type enumType, object value, string format);
         public static Array GetValues(Type enumType);
+        public static Array GetValuesAsUnderlyingType(Type enumType);
+        public static Array GetValuesAsUnderlyingType&lt;TEnum&gt;() where TEnum : struct;
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
         public static bool TryParse(Type enumType, ReadOnlySpan&lt;char&gt; value, bool ignoreCase, out object? result);
         public static bool TryParse(Type enumType, ReadOnlySpan&lt;char&gt; value, out object? result);
         public static bool TryParse(Type enumType, string? value, bool ignoreCase, out object? result);
         public static bool TryParse(Type enumType, string? value, out object? result);
     }
     public class Exception : ISerializable {
         public MethodBase TargetSite { get; }
     }
     public abstract class FormattableString : IFormattable {
         public abstract string Format { get; }
     }
     public static class GC {
+        public static IReadOnlyDictionary&lt;string, object&gt; GetConfigurationVariables();
+        public static TimeSpan GetTotalPauseDuration();
+        public static GCNotificationStatus WaitForFullGCApproach(TimeSpan timeout);
+        public static GCNotificationStatus WaitForFullGCComplete(TimeSpan timeout);
     }
     public enum GCCollectionMode {
+        Aggressive = 3,
     }
-    public readonly struct Guid : IComparable, IComparable&lt;Guid&gt;, IEquatable&lt;Guid&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Guid : IComparable, IComparable&lt;Guid&gt;, IEquatable&lt;Guid&gt;, IFormattable, IParsable&lt;Guid&gt;, ISpanFormattable, ISpanParsable&lt;Guid&gt; {
+        public static bool operator &gt;(Guid left, Guid right);
+        public static bool operator &gt;=(Guid left, Guid right);
+        public static bool operator &lt;(Guid left, Guid right);
+        public static bool operator &lt;=(Guid left, Guid right);
+        public static Guid Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static Guid Parse(string s, IFormatProvider? provider);
         public static Guid ParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format);
         public static Guid ParseExact(string input, string format);
         bool ISpanFormattable.TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;));
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out Guid result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out Guid result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, out Guid result);
         public static bool TryParseExact(string? input, string? format, out Guid result);
     }
-    public readonly struct Half : IComparable, IComparable&lt;Half&gt;, IEquatable&lt;Half&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Half : IAdditionOperators&lt;Half, Half, Half&gt;, IAdditiveIdentity&lt;Half, Half&gt;, IBinaryFloatingPointIeee754&lt;Half&gt;, IBinaryNumber&lt;Half&gt;, IBitwiseOperators&lt;Half, Half, Half&gt;, IComparable, IComparable&lt;Half&gt;, IComparisonOperators&lt;Half, Half, bool&gt;, IDecrementOperators&lt;Half&gt;, IDivisionOperators&lt;Half, Half, Half&gt;, IEqualityOperators&lt;Half, Half, bool&gt;, IEquatable&lt;Half&gt;, IExponentialFunctions&lt;Half&gt;, IFloatingPoint&lt;Half&gt;, IFloatingPointConstants&lt;Half&gt;, IFloatingPointIeee754&lt;Half&gt;, IFormattable, IHyperbolicFunctions&lt;Half&gt;, IIncrementOperators&lt;Half&gt;, ILogarithmicFunctions&lt;Half&gt;, IMinMaxValue&lt;Half&gt;, IModulusOperators&lt;Half, Half, Half&gt;, IMultiplicativeIdentity&lt;Half, Half&gt;, IMultiplyOperators&lt;Half, Half, Half&gt;, INumber&lt;Half&gt;, INumberBase&lt;Half&gt;, IParsable&lt;Half&gt;, IPowerFunctions&lt;Half&gt;, IRootFunctions&lt;Half&gt;, ISignedNumber&lt;Half&gt;, ISpanFormattable, ISpanParsable&lt;Half&gt;, ISubtractionOperators&lt;Half, Half, Half&gt;, ITrigonometricFunctions&lt;Half&gt;, IUnaryNegationOperators&lt;Half, Half&gt;, IUnaryPlusOperators&lt;Half, Half&gt; {
+        public static Half E { get; }
+        public static Half MultiplicativeIdentity { get; }
+        public static Half NegativeOne { get; }
+        public static Half NegativeZero { get; }
+        public static Half One { get; }
+        public static Half Pi { get; }
+        static Half System.Numerics.IAdditiveIdentity&lt;System.Half,System.Half&gt;.AdditiveIdentity { get; }
+        static Half System.Numerics.IBinaryNumber&lt;System.Half&gt;.AllBitsSet { get; }
+        static int System.Numerics.INumberBase&lt;System.Half&gt;.Radix { get; }
+        public static Half Tau { get; }
+        public static Half Zero { get; }
+        public static Half Abs(Half value);
+        public static Half Acos(Half x);
+        public static Half Acosh(Half x);
+        public static Half AcosPi(Half x);
+        public static Half Asin(Half x);
+        public static Half Asinh(Half x);
+        public static Half AsinPi(Half x);
+        public static Half Atan(Half x);
+        public static Half Atan2(Half y, Half x);
+        public static Half Atan2Pi(Half y, Half x);
+        public static Half Atanh(Half x);
+        public static Half AtanPi(Half x);
+        public static Half BitDecrement(Half x);
+        public static Half BitIncrement(Half x);
+        public static Half Cbrt(Half x);
+        public static Half Ceiling(Half x);
+        public static Half Clamp(Half value, Half min, Half max);
+        public static Half CopySign(Half value, Half sign);
+        public static Half Cos(Half x);
+        public static Half Cosh(Half x);
+        public static Half CosPi(Half x);
+        public static Half CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static Half CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static Half CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static Half Exp(Half x);
+        public static Half Exp10(Half x);
+        public static Half Exp10M1(Half x);
+        public static Half Exp2(Half x);
+        public static Half Exp2M1(Half x);
+        public static Half ExpM1(Half x);
+        public static Half Floor(Half x);
+        public static Half FusedMultiplyAdd(Half left, Half right, Half addend);
+        public static Half Hypot(Half x, Half y);
+        public static Half Ieee754Remainder(Half left, Half right);
+        public static int ILogB(Half x);
+        public static bool IsEvenInteger(Half value);
+        public static bool IsInteger(Half value);
+        public static bool IsOddInteger(Half value);
+        public static bool IsPositive(Half value);
+        public static bool IsPow2(Half value);
+        public static bool IsRealNumber(Half value);
+        public static Half Log(Half x);
+        public static Half Log(Half x, Half newBase);
+        public static Half Log10(Half x);
+        public static Half Log10P1(Half x);
+        public static Half Log2(Half value);
+        public static Half Log2P1(Half x);
+        public static Half LogP1(Half x);
+        public static Half Max(Half x, Half y);
+        public static Half MaxMagnitude(Half x, Half y);
+        public static Half MaxMagnitudeNumber(Half x, Half y);
+        public static Half MaxNumber(Half x, Half y);
+        public static Half Min(Half x, Half y);
+        public static Half MinMagnitude(Half x, Half y);
+        public static Half MinMagnitudeNumber(Half x, Half y);
+        public static Half MinNumber(Half x, Half y);
+        public static Half operator +(Half left, Half right);
+        public static explicit operator checked byte (Half value);
+        public static explicit operator checked char (Half value);
+        public static explicit operator checked short (Half value);
+        public static explicit operator checked int (Half value);
+        public static explicit operator checked long (Half value);
+        public static explicit operator checked Int128 (Half value);
+        public static explicit operator checked IntPtr (Half value);
+        public static explicit operator checked sbyte (Half value);
+        public static explicit operator checked ushort (Half value);
+        public static explicit operator checked uint (Half value);
+        public static explicit operator checked ulong (Half value);
+        public static explicit operator checked UInt128 (Half value);
+        public static explicit operator checked UIntPtr (Half value);
+        public static Half operator --(Half value);
+        public static Half operator /(Half left, Half right);
+        public static explicit operator Half (char value);
+        public static explicit operator Half (decimal value);
+        public static explicit operator byte (Half value);
+        public static explicit operator char (Half value);
+        public static explicit operator decimal (Half value);
+        public static explicit operator Int128 (Half value);
+        public static explicit operator short (Half value);
+        public static explicit operator int (Half value);
+        public static explicit operator long (Half value);
+        public static explicit operator IntPtr (Half value);
+        public static explicit operator sbyte (Half value);
+        public static explicit operator UInt128 (Half value);
+        public static explicit operator ushort (Half value);
+        public static explicit operator uint (Half value);
+        public static explicit operator ulong (Half value);
+        public static explicit operator UIntPtr (Half value);
+        public static explicit operator Half (short value);
+        public static explicit operator Half (int value);
+        public static explicit operator Half (long value);
+        public static explicit operator Half (IntPtr value);
+        public static explicit operator Half (ushort value);
+        public static explicit operator Half (uint value);
+        public static explicit operator Half (ulong value);
+        public static explicit operator Half (UIntPtr value);
+        public static implicit operator Half (byte value);
+        public static implicit operator Half (sbyte value);
+        public static Half operator ++(Half value);
+        public static Half operator %(Half left, Half right);
+        public static Half operator *(Half left, Half right);
+        public static Half operator -(Half left, Half right);
+        public static Half operator -(Half value);
+        public static Half operator +(Half value);
+        public static Half Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static Half Pow(Half x, Half y);
+        public static Half ReciprocalEstimate(Half x);
+        public static Half ReciprocalSqrtEstimate(Half x);
+        public static Half RootN(Half x, int n);
+        public static Half Round(Half x);
+        public static Half Round(Half x, int digits);
+        public static Half Round(Half x, int digits, MidpointRounding mode);
+        public static Half Round(Half x, MidpointRounding mode);
+        public static Half ScaleB(Half x, int n);
+        public static int Sign(Half value);
+        public static Half Sin(Half x);
+        public static (Half Sin, Half Cos) SinCos(Half x);
+        public static (Half SinPi, Half CosPi) SinCosPi(Half x);
+        public static Half Sinh(Half x);
+        public static Half SinPi(Half x);
+        public static Half Sqrt(Half x);
+        static Half IBitwiseOperators&lt;Half, Half, Half&gt;.operator &amp;(Half left, Half right);
+        static Half IBitwiseOperators&lt;Half, Half, Half&gt;.operator |(Half left, Half right);
+        static Half IBitwiseOperators&lt;Half, Half, Half&gt;.operator ^(Half left, Half right);
+        static Half IBitwiseOperators&lt;Half, Half, Half&gt;.operator ~(Half value);
+        int IFloatingPoint&lt;Half&gt;.GetExponentByteCount();
+        int IFloatingPoint&lt;Half&gt;.GetExponentShortestBitLength();
+        int IFloatingPoint&lt;Half&gt;.GetSignificandBitLength();
+        int IFloatingPoint&lt;Half&gt;.GetSignificandByteCount();
+        bool IFloatingPoint&lt;Half&gt;.TryWriteExponentBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;Half&gt;.TryWriteExponentLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;Half&gt;.TryWriteSignificandBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;Half&gt;.TryWriteSignificandLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static bool INumberBase&lt;Half&gt;.IsCanonical(Half value);
+        static bool INumberBase&lt;Half&gt;.IsComplexNumber(Half value);
+        static bool INumberBase&lt;Half&gt;.IsImaginaryNumber(Half value);
+        static bool INumberBase&lt;Half&gt;.IsZero(Half value);
+        static bool INumberBase&lt;Half&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out Half result);
+        static bool INumberBase&lt;Half&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out Half result);
+        static bool INumberBase&lt;Half&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out Half result);
+        static bool INumberBase&lt;Half&gt;.TryConvertToChecked&lt;TOther&gt;(Half value, out TOther result);
+        static bool INumberBase&lt;Half&gt;.TryConvertToSaturating&lt;TOther&gt;(Half value, out TOther result);
+        static bool INumberBase&lt;Half&gt;.TryConvertToTruncating&lt;TOther&gt;(Half value, out TOther result);
+        public static Half Tan(Half x);
+        public static Half Tanh(Half x);
+        public static Half TanPi(Half x);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static Half Truncate(Half x);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out Half result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out Half result);
     }
+    public readonly struct Int128 : IAdditionOperators&lt;Int128, Int128, Int128&gt;, IAdditiveIdentity&lt;Int128, Int128&gt;, IBinaryInteger&lt;Int128&gt;, IBinaryNumber&lt;Int128&gt;, IBitwiseOperators&lt;Int128, Int128, Int128&gt;, IComparable, IComparable&lt;Int128&gt;, IComparisonOperators&lt;Int128, Int128, bool&gt;, IDecrementOperators&lt;Int128&gt;, IDivisionOperators&lt;Int128, Int128, Int128&gt;, IEqualityOperators&lt;Int128, Int128, bool&gt;, IEquatable&lt;Int128&gt;, IFormattable, IIncrementOperators&lt;Int128&gt;, IMinMaxValue&lt;Int128&gt;, IModulusOperators&lt;Int128, Int128, Int128&gt;, IMultiplicativeIdentity&lt;Int128, Int128&gt;, IMultiplyOperators&lt;Int128, Int128, Int128&gt;, INumber&lt;Int128&gt;, INumberBase&lt;Int128&gt;, IParsable&lt;Int128&gt;, IShiftOperators&lt;Int128, int, Int128&gt;, ISignedNumber&lt;Int128&gt;, ISpanFormattable, ISpanParsable&lt;Int128&gt;, ISubtractionOperators&lt;Int128, Int128, Int128&gt;, IUnaryNegationOperators&lt;Int128, Int128&gt;, IUnaryPlusOperators&lt;Int128, Int128&gt; {
+        public Int128(ulong upper, ulong lower);
+        public static Int128 MaxValue { get; }
+        public static Int128 MinValue { get; }
+        public static Int128 NegativeOne { get; }
+        public static Int128 One { get; }
+        static Int128 System.Numerics.IAdditiveIdentity&lt;System.Int128,System.Int128&gt;.AdditiveIdentity { get; }
+        static Int128 System.Numerics.IBinaryNumber&lt;System.Int128&gt;.AllBitsSet { get; }
+        static Int128 System.Numerics.IMultiplicativeIdentity&lt;System.Int128,System.Int128&gt;.MultiplicativeIdentity { get; }
+        static int System.Numerics.INumberBase&lt;System.Int128&gt;.Radix { get; }
+        public static Int128 Zero { get; }
+        public static Int128 Abs(Int128 value);
+        public static Int128 Clamp(Int128 value, Int128 min, Int128 max);
+        public int CompareTo(Int128 value);
+        public int CompareTo(object? value);
+        public static Int128 CopySign(Int128 value, Int128 sign);
+        public static Int128 CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static Int128 CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static Int128 CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (Int128 Quotient, Int128 Remainder) DivRem(Int128 left, Int128 right);
+        public bool Equals(Int128 other);
+        public override bool Equals(object? obj);
+        public override int GetHashCode();
+        public static bool IsEvenInteger(Int128 value);
+        public static bool IsNegative(Int128 value);
+        public static bool IsOddInteger(Int128 value);
+        public static bool IsPositive(Int128 value);
+        public static bool IsPow2(Int128 value);
+        public static Int128 LeadingZeroCount(Int128 value);
+        public static Int128 Log2(Int128 value);
+        public static Int128 Max(Int128 x, Int128 y);
+        public static Int128 MaxMagnitude(Int128 x, Int128 y);
+        public static Int128 Min(Int128 x, Int128 y);
+        public static Int128 MinMagnitude(Int128 x, Int128 y);
+        public static Int128 operator +(Int128 left, Int128 right);
+        public static Int128 operator &amp;(Int128 left, Int128 right);
+        public static Int128 operator |(Int128 left, Int128 right);
+        public static Int128 operator checked +(Int128 left, Int128 right);
+        public static Int128 operator checked --(Int128 value);
+        public static Int128 operator checked /(Int128 left, Int128 right);
+        public static explicit operator checked Int128 (double value);
+        public static explicit operator checked byte (Int128 value);
+        public static explicit operator checked char (Int128 value);
+        public static explicit operator checked short (Int128 value);
+        public static explicit operator checked int (Int128 value);
+        public static explicit operator checked long (Int128 value);
+        public static explicit operator checked IntPtr (Int128 value);
+        public static explicit operator checked sbyte (Int128 value);
+        public static explicit operator checked ushort (Int128 value);
+        public static explicit operator checked uint (Int128 value);
+        public static explicit operator checked ulong (Int128 value);
+        public static explicit operator checked UInt128 (Int128 value);
+        public static explicit operator checked UIntPtr (Int128 value);
+        public static explicit operator checked Int128 (float value);
+        public static Int128 operator checked ++(Int128 value);
+        public static Int128 operator checked *(Int128 left, Int128 right);
+        public static Int128 operator checked -(Int128 left, Int128 right);
+        public static Int128 operator checked -(Int128 value);
+        public static Int128 operator --(Int128 value);
+        public static Int128 operator /(Int128 left, Int128 right);
+        public static bool operator ==(Int128 left, Int128 right);
+        public static Int128 operator ^(Int128 left, Int128 right);
+        public static explicit operator Int128 (decimal value);
+        public static explicit operator Int128 (double value);
+        public static explicit operator byte (Int128 value);
+        public static explicit operator char (Int128 value);
+        public static explicit operator decimal (Int128 value);
+        public static explicit operator double (Int128 value);
+        public static explicit operator Half (Int128 value);
+        public static explicit operator short (Int128 value);
+        public static explicit operator int (Int128 value);
+        public static explicit operator long (Int128 value);
+        public static explicit operator IntPtr (Int128 value);
+        public static explicit operator sbyte (Int128 value);
+        public static explicit operator float (Int128 value);
+        public static explicit operator UInt128 (Int128 value);
+        public static explicit operator ushort (Int128 value);
+        public static explicit operator uint (Int128 value);
+        public static explicit operator ulong (Int128 value);
+        public static explicit operator UIntPtr (Int128 value);
+        public static explicit operator Int128 (float value);
+        public static bool operator &gt;(Int128 left, Int128 right);
+        public static bool operator &gt;=(Int128 left, Int128 right);
+        public static implicit operator Int128 (byte value);
+        public static implicit operator Int128 (char value);
+        public static implicit operator Int128 (short value);
+        public static implicit operator Int128 (int value);
+        public static implicit operator Int128 (long value);
+        public static implicit operator Int128 (IntPtr value);
+        public static implicit operator Int128 (sbyte value);
+        public static implicit operator Int128 (ushort value);
+        public static implicit operator Int128 (uint value);
+        public static implicit operator Int128 (ulong value);
+        public static implicit operator Int128 (UIntPtr value);
+        public static Int128 operator ++(Int128 value);
+        public static bool operator !=(Int128 left, Int128 right);
+        public static Int128 operator &lt;&lt;(Int128 value, int shiftAmount);
+        public static bool operator &lt;(Int128 left, Int128 right);
+        public static bool operator &lt;=(Int128 left, Int128 right);
+        public static Int128 operator %(Int128 left, Int128 right);
+        public static Int128 operator *(Int128 left, Int128 right);
+        public static Int128 operator ~(Int128 value);
+        public static Int128 operator &gt;&gt;(Int128 value, int shiftAmount);
+        public static Int128 operator -(Int128 left, Int128 right);
+        public static Int128 operator -(Int128 value);
+        public static Int128 operator +(Int128 value);
+        public static Int128 operator &gt;&gt;&gt;(Int128 value, int shiftAmount);
+        public static Int128 Parse(ReadOnlySpan&lt;char&gt; s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null);
+        public static Int128 Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static Int128 Parse(string s);
+        public static Int128 Parse(string s, NumberStyles style);
+        public static Int128 Parse(string s, NumberStyles style, IFormatProvider? provider);
+        public static Int128 Parse(string s, IFormatProvider? provider);
+        public static Int128 PopCount(Int128 value);
+        public static Int128 RotateLeft(Int128 value, int rotateAmount);
+        public static Int128 RotateRight(Int128 value, int rotateAmount);
+        public static int Sign(Int128 value);
+        int IBinaryInteger&lt;Int128&gt;.GetByteCount();
+        int IBinaryInteger&lt;Int128&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;Int128&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out Int128 value);
+        static bool IBinaryInteger&lt;Int128&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out Int128 value);
+        bool IBinaryInteger&lt;Int128&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;Int128&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static Int128 INumber&lt;Int128&gt;.MaxNumber(Int128 x, Int128 y);
+        static Int128 INumber&lt;Int128&gt;.MinNumber(Int128 x, Int128 y);
+        static bool INumberBase&lt;Int128&gt;.IsCanonical(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsComplexNumber(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsFinite(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsImaginaryNumber(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsInfinity(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsInteger(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsNaN(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsNegativeInfinity(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsNormal(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsPositiveInfinity(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsRealNumber(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsSubnormal(Int128 value);
+        static bool INumberBase&lt;Int128&gt;.IsZero(Int128 value);
+        static Int128 INumberBase&lt;Int128&gt;.MaxMagnitudeNumber(Int128 x, Int128 y);
+        static Int128 INumberBase&lt;Int128&gt;.MinMagnitudeNumber(Int128 x, Int128 y);
+        static bool INumberBase&lt;Int128&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out Int128 result);
+        static bool INumberBase&lt;Int128&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out Int128 result);
+        static bool INumberBase&lt;Int128&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out Int128 result);
+        static bool INumberBase&lt;Int128&gt;.TryConvertToChecked&lt;TOther&gt;(Int128 value, out TOther result);
+        static bool INumberBase&lt;Int128&gt;.TryConvertToSaturating&lt;TOther&gt;(Int128 value, out TOther result);
+        static bool INumberBase&lt;Int128&gt;.TryConvertToTruncating&lt;TOther&gt;(Int128 value, out TOther result);
+        public override string ToString();
+        public string ToString(IFormatProvider? provider);
+        public string ToString(string? format);
+        public string ToString(string? format, IFormatProvider? provider);
+        public static Int128 TrailingZeroCount(Int128 value);
+        public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, NumberStyles style, IFormatProvider? provider, out Int128 result);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out Int128 result);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, out Int128 result);
+        public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out Int128 result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out Int128 result);
+        public static bool TryParse(string? s, out Int128 result);
+    }
-    public readonly struct Int16 : IComparable, IComparable&lt;short&gt;, IConvertible, IEquatable&lt;short&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Int16 : IAdditionOperators&lt;short, short, short&gt;, IAdditiveIdentity&lt;short, short&gt;, IBinaryInteger&lt;short&gt;, IBinaryNumber&lt;short&gt;, IBitwiseOperators&lt;short, short, short&gt;, IComparable, IComparable&lt;short&gt;, IComparisonOperators&lt;short, short, bool&gt;, IConvertible, IDecrementOperators&lt;short&gt;, IDivisionOperators&lt;short, short, short&gt;, IEqualityOperators&lt;short, short, bool&gt;, IEquatable&lt;short&gt;, IFormattable, IIncrementOperators&lt;short&gt;, IMinMaxValue&lt;short&gt;, IModulusOperators&lt;short, short, short&gt;, IMultiplicativeIdentity&lt;short, short&gt;, IMultiplyOperators&lt;short, short, short&gt;, INumber&lt;short&gt;, INumberBase&lt;short&gt;, IParsable&lt;short&gt;, IShiftOperators&lt;short, int, short&gt;, ISignedNumber&lt;short&gt;, ISpanFormattable, ISpanParsable&lt;short&gt;, ISubtractionOperators&lt;short, short, short&gt;, IUnaryNegationOperators&lt;short, short&gt;, IUnaryPlusOperators&lt;short, short&gt; {
+        static short System.Numerics.IAdditiveIdentity&lt;System.Int16,System.Int16&gt;.AdditiveIdentity { get; }
+        static short System.Numerics.IBinaryNumber&lt;System.Int16&gt;.AllBitsSet { get; }
+        static short System.Numerics.IMinMaxValue&lt;System.Int16&gt;.MaxValue { get; }
+        static short System.Numerics.IMinMaxValue&lt;System.Int16&gt;.MinValue { get; }
+        static short System.Numerics.IMultiplicativeIdentity&lt;System.Int16,System.Int16&gt;.MultiplicativeIdentity { get; }
+        static short System.Numerics.INumberBase&lt;System.Int16&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Int16&gt;.Radix { get; }
+        static short System.Numerics.INumberBase&lt;System.Int16&gt;.Zero { get; }
+        static short System.Numerics.ISignedNumber&lt;System.Int16&gt;.NegativeOne { get; }
+        public static short Abs(short value);
+        public static short Clamp(short value, short min, short max);
+        public static short CopySign(short value, short sign);
+        public static short CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static short CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static short CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (short Quotient, short Remainder) DivRem(short left, short right);
+        public static bool IsEvenInteger(short value);
+        public static bool IsNegative(short value);
+        public static bool IsOddInteger(short value);
+        public static bool IsPositive(short value);
+        public static bool IsPow2(short value);
+        public static short LeadingZeroCount(short value);
+        public static short Log2(short value);
+        public static short Max(short x, short y);
+        public static short MaxMagnitude(short x, short y);
+        public static short Min(short x, short y);
+        public static short MinMagnitude(short x, short y);
+        public static short Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static short PopCount(short value);
+        public static short RotateLeft(short value, int rotateAmount);
+        public static short RotateRight(short value, int rotateAmount);
+        public static int Sign(short value);
+        static short IAdditionOperators&lt;short, short, short&gt;.operator +(short left, short right);
+        static short IAdditionOperators&lt;short, short, short&gt;.operator checked +(short left, short right);
+        int IBinaryInteger&lt;short&gt;.GetByteCount();
+        int IBinaryInteger&lt;short&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;short&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out short value);
+        static bool IBinaryInteger&lt;short&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out short value);
+        bool IBinaryInteger&lt;short&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;short&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static short IBitwiseOperators&lt;short, short, short&gt;.operator &amp;(short left, short right);
+        static short IBitwiseOperators&lt;short, short, short&gt;.operator |(short left, short right);
+        static short IBitwiseOperators&lt;short, short, short&gt;.operator ^(short left, short right);
+        static short IBitwiseOperators&lt;short, short, short&gt;.operator ~(short value);
+        static bool IComparisonOperators&lt;short, short, bool&gt;.operator &gt;(short left, short right);
+        static bool IComparisonOperators&lt;short, short, bool&gt;.operator &gt;=(short left, short right);
+        static bool IComparisonOperators&lt;short, short, bool&gt;.operator &lt;(short left, short right);
+        static bool IComparisonOperators&lt;short, short, bool&gt;.operator &lt;=(short left, short right);
+        static short IDecrementOperators&lt;short&gt;.operator checked --(short value);
+        static short IDecrementOperators&lt;short&gt;.operator --(short value);
+        static short IDivisionOperators&lt;short, short, short&gt;.operator /(short left, short right);
+        static bool IEqualityOperators&lt;short, short, bool&gt;.operator ==(short left, short right);
+        static bool IEqualityOperators&lt;short, short, bool&gt;.operator !=(short left, short right);
+        static short IIncrementOperators&lt;short&gt;.operator checked ++(short value);
+        static short IIncrementOperators&lt;short&gt;.operator ++(short value);
+        static short IModulusOperators&lt;short, short, short&gt;.operator %(short left, short right);
+        static short IMultiplyOperators&lt;short, short, short&gt;.operator checked *(short left, short right);
+        static short IMultiplyOperators&lt;short, short, short&gt;.operator *(short left, short right);
+        static short INumber&lt;short&gt;.MaxNumber(short x, short y);
+        static short INumber&lt;short&gt;.MinNumber(short x, short y);
+        static bool INumberBase&lt;short&gt;.IsCanonical(short value);
+        static bool INumberBase&lt;short&gt;.IsComplexNumber(short value);
+        static bool INumberBase&lt;short&gt;.IsFinite(short value);
+        static bool INumberBase&lt;short&gt;.IsImaginaryNumber(short value);
+        static bool INumberBase&lt;short&gt;.IsInfinity(short value);
+        static bool INumberBase&lt;short&gt;.IsInteger(short value);
+        static bool INumberBase&lt;short&gt;.IsNaN(short value);
+        static bool INumberBase&lt;short&gt;.IsNegativeInfinity(short value);
+        static bool INumberBase&lt;short&gt;.IsNormal(short value);
+        static bool INumberBase&lt;short&gt;.IsPositiveInfinity(short value);
+        static bool INumberBase&lt;short&gt;.IsRealNumber(short value);
+        static bool INumberBase&lt;short&gt;.IsSubnormal(short value);
+        static bool INumberBase&lt;short&gt;.IsZero(short value);
+        static short INumberBase&lt;short&gt;.MaxMagnitudeNumber(short x, short y);
+        static short INumberBase&lt;short&gt;.MinMagnitudeNumber(short x, short y);
+        static bool INumberBase&lt;short&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out short result);
+        static bool INumberBase&lt;short&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out short result);
+        static bool INumberBase&lt;short&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out short result);
+        static bool INumberBase&lt;short&gt;.TryConvertToChecked&lt;TOther&gt;(short value, out TOther result);
+        static bool INumberBase&lt;short&gt;.TryConvertToSaturating&lt;TOther&gt;(short value, out TOther result);
+        static bool INumberBase&lt;short&gt;.TryConvertToTruncating&lt;TOther&gt;(short value, out TOther result);
+        static short IShiftOperators&lt;short, int, short&gt;.operator &lt;&lt;(short value, int shiftAmount);
+        static short IShiftOperators&lt;short, int, short&gt;.operator &gt;&gt;(short value, int shiftAmount);
+        static short IShiftOperators&lt;short, int, short&gt;.operator &gt;&gt;&gt;(short value, int shiftAmount);
+        static short ISubtractionOperators&lt;short, short, short&gt;.operator checked -(short left, short right);
+        static short ISubtractionOperators&lt;short, short, short&gt;.operator -(short left, short right);
+        static short IUnaryNegationOperators&lt;short, short&gt;.operator checked -(short value);
+        static short IUnaryNegationOperators&lt;short, short&gt;.operator -(short value);
+        static short IUnaryPlusOperators&lt;short, short&gt;.operator +(short value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static short TrailingZeroCount(short value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out short result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out short result);
     }
-    public readonly struct Int32 : IComparable, IComparable&lt;int&gt;, IConvertible, IEquatable&lt;int&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Int32 : IAdditionOperators&lt;int, int, int&gt;, IAdditiveIdentity&lt;int, int&gt;, IBinaryInteger&lt;int&gt;, IBinaryNumber&lt;int&gt;, IBitwiseOperators&lt;int, int, int&gt;, IComparable, IComparable&lt;int&gt;, IComparisonOperators&lt;int, int, bool&gt;, IConvertible, IDecrementOperators&lt;int&gt;, IDivisionOperators&lt;int, int, int&gt;, IEqualityOperators&lt;int, int, bool&gt;, IEquatable&lt;int&gt;, IFormattable, IIncrementOperators&lt;int&gt;, IMinMaxValue&lt;int&gt;, IModulusOperators&lt;int, int, int&gt;, IMultiplicativeIdentity&lt;int, int&gt;, IMultiplyOperators&lt;int, int, int&gt;, INumber&lt;int&gt;, INumberBase&lt;int&gt;, IParsable&lt;int&gt;, IShiftOperators&lt;int, int, int&gt;, ISignedNumber&lt;int&gt;, ISpanFormattable, ISpanParsable&lt;int&gt;, ISubtractionOperators&lt;int, int, int&gt;, IUnaryNegationOperators&lt;int, int&gt;, IUnaryPlusOperators&lt;int, int&gt; {
+        static int System.Numerics.IAdditiveIdentity&lt;System.Int32,System.Int32&gt;.AdditiveIdentity { get; }
+        static int System.Numerics.IBinaryNumber&lt;System.Int32&gt;.AllBitsSet { get; }
+        static int System.Numerics.IMinMaxValue&lt;System.Int32&gt;.MaxValue { get; }
+        static int System.Numerics.IMinMaxValue&lt;System.Int32&gt;.MinValue { get; }
+        static int System.Numerics.IMultiplicativeIdentity&lt;System.Int32,System.Int32&gt;.MultiplicativeIdentity { get; }
+        static int System.Numerics.INumberBase&lt;System.Int32&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Int32&gt;.Radix { get; }
+        static int System.Numerics.INumberBase&lt;System.Int32&gt;.Zero { get; }
+        static int System.Numerics.ISignedNumber&lt;System.Int32&gt;.NegativeOne { get; }
+        public static int Abs(int value);
+        public static int Clamp(int value, int min, int max);
+        public static int CopySign(int value, int sign);
+        public static int CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static int CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static int CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (int Quotient, int Remainder) DivRem(int left, int right);
+        public static bool IsEvenInteger(int value);
+        public static bool IsNegative(int value);
+        public static bool IsOddInteger(int value);
+        public static bool IsPositive(int value);
+        public static bool IsPow2(int value);
+        public static int LeadingZeroCount(int value);
+        public static int Log2(int value);
+        public static int Max(int x, int y);
+        public static int MaxMagnitude(int x, int y);
+        public static int Min(int x, int y);
+        public static int MinMagnitude(int x, int y);
+        public static int Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static int PopCount(int value);
+        public static int RotateLeft(int value, int rotateAmount);
+        public static int RotateRight(int value, int rotateAmount);
+        public static int Sign(int value);
+        static int IAdditionOperators&lt;int, int, int&gt;.operator +(int left, int right);
+        static int IAdditionOperators&lt;int, int, int&gt;.operator checked +(int left, int right);
+        int IBinaryInteger&lt;int&gt;.GetByteCount();
+        int IBinaryInteger&lt;int&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;int&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out int value);
+        static bool IBinaryInteger&lt;int&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out int value);
+        bool IBinaryInteger&lt;int&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;int&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static int IBitwiseOperators&lt;int, int, int&gt;.operator &amp;(int left, int right);
+        static int IBitwiseOperators&lt;int, int, int&gt;.operator |(int left, int right);
+        static int IBitwiseOperators&lt;int, int, int&gt;.operator ^(int left, int right);
+        static int IBitwiseOperators&lt;int, int, int&gt;.operator ~(int value);
+        static bool IComparisonOperators&lt;int, int, bool&gt;.operator &gt;(int left, int right);
+        static bool IComparisonOperators&lt;int, int, bool&gt;.operator &gt;=(int left, int right);
+        static bool IComparisonOperators&lt;int, int, bool&gt;.operator &lt;(int left, int right);
+        static bool IComparisonOperators&lt;int, int, bool&gt;.operator &lt;=(int left, int right);
+        static int IDecrementOperators&lt;int&gt;.operator checked --(int value);
+        static int IDecrementOperators&lt;int&gt;.operator --(int value);
+        static int IDivisionOperators&lt;int, int, int&gt;.operator /(int left, int right);
+        static bool IEqualityOperators&lt;int, int, bool&gt;.operator ==(int left, int right);
+        static bool IEqualityOperators&lt;int, int, bool&gt;.operator !=(int left, int right);
+        static int IIncrementOperators&lt;int&gt;.operator checked ++(int value);
+        static int IIncrementOperators&lt;int&gt;.operator ++(int value);
+        static int IModulusOperators&lt;int, int, int&gt;.operator %(int left, int right);
+        static int IMultiplyOperators&lt;int, int, int&gt;.operator checked *(int left, int right);
+        static int IMultiplyOperators&lt;int, int, int&gt;.operator *(int left, int right);
+        static int INumber&lt;int&gt;.MaxNumber(int x, int y);
+        static int INumber&lt;int&gt;.MinNumber(int x, int y);
+        static bool INumberBase&lt;int&gt;.IsCanonical(int value);
+        static bool INumberBase&lt;int&gt;.IsComplexNumber(int value);
+        static bool INumberBase&lt;int&gt;.IsFinite(int value);
+        static bool INumberBase&lt;int&gt;.IsImaginaryNumber(int value);
+        static bool INumberBase&lt;int&gt;.IsInfinity(int value);
+        static bool INumberBase&lt;int&gt;.IsInteger(int value);
+        static bool INumberBase&lt;int&gt;.IsNaN(int value);
+        static bool INumberBase&lt;int&gt;.IsNegativeInfinity(int value);
+        static bool INumberBase&lt;int&gt;.IsNormal(int value);
+        static bool INumberBase&lt;int&gt;.IsPositiveInfinity(int value);
+        static bool INumberBase&lt;int&gt;.IsRealNumber(int value);
+        static bool INumberBase&lt;int&gt;.IsSubnormal(int value);
+        static bool INumberBase&lt;int&gt;.IsZero(int value);
+        static int INumberBase&lt;int&gt;.MaxMagnitudeNumber(int x, int y);
+        static int INumberBase&lt;int&gt;.MinMagnitudeNumber(int x, int y);
+        static bool INumberBase&lt;int&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out int result);
+        static bool INumberBase&lt;int&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out int result);
+        static bool INumberBase&lt;int&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out int result);
+        static bool INumberBase&lt;int&gt;.TryConvertToChecked&lt;TOther&gt;(int value, out TOther result);
+        static bool INumberBase&lt;int&gt;.TryConvertToSaturating&lt;TOther&gt;(int value, out TOther result);
+        static bool INumberBase&lt;int&gt;.TryConvertToTruncating&lt;TOther&gt;(int value, out TOther result);
+        static int IShiftOperators&lt;int, int, int&gt;.operator &lt;&lt;(int value, int shiftAmount);
+        static int IShiftOperators&lt;int, int, int&gt;.operator &gt;&gt;(int value, int shiftAmount);
+        static int IShiftOperators&lt;int, int, int&gt;.operator &gt;&gt;&gt;(int value, int shiftAmount);
+        static int ISubtractionOperators&lt;int, int, int&gt;.operator checked -(int left, int right);
+        static int ISubtractionOperators&lt;int, int, int&gt;.operator -(int left, int right);
+        static int IUnaryNegationOperators&lt;int, int&gt;.operator checked -(int value);
+        static int IUnaryNegationOperators&lt;int, int&gt;.operator -(int value);
+        static int IUnaryPlusOperators&lt;int, int&gt;.operator +(int value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static int TrailingZeroCount(int value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out int result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out int result);
     }
-    public readonly struct Int64 : IComparable, IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Int64 : IAdditionOperators&lt;long, long, long&gt;, IAdditiveIdentity&lt;long, long&gt;, IBinaryInteger&lt;long&gt;, IBinaryNumber&lt;long&gt;, IBitwiseOperators&lt;long, long, long&gt;, IComparable, IComparable&lt;long&gt;, IComparisonOperators&lt;long, long, bool&gt;, IConvertible, IDecrementOperators&lt;long&gt;, IDivisionOperators&lt;long, long, long&gt;, IEqualityOperators&lt;long, long, bool&gt;, IEquatable&lt;long&gt;, IFormattable, IIncrementOperators&lt;long&gt;, IMinMaxValue&lt;long&gt;, IModulusOperators&lt;long, long, long&gt;, IMultiplicativeIdentity&lt;long, long&gt;, IMultiplyOperators&lt;long, long, long&gt;, INumber&lt;long&gt;, INumberBase&lt;long&gt;, IParsable&lt;long&gt;, IShiftOperators&lt;long, int, long&gt;, ISignedNumber&lt;long&gt;, ISpanFormattable, ISpanParsable&lt;long&gt;, ISubtractionOperators&lt;long, long, long&gt;, IUnaryNegationOperators&lt;long, long&gt;, IUnaryPlusOperators&lt;long, long&gt; {
+        static long System.Numerics.IAdditiveIdentity&lt;System.Int64,System.Int64&gt;.AdditiveIdentity { get; }
+        static long System.Numerics.IBinaryNumber&lt;System.Int64&gt;.AllBitsSet { get; }
+        static long System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MaxValue { get; }
+        static long System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MinValue { get; }
+        static long System.Numerics.IMultiplicativeIdentity&lt;System.Int64,System.Int64&gt;.MultiplicativeIdentity { get; }
+        static long System.Numerics.INumberBase&lt;System.Int64&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Int64&gt;.Radix { get; }
+        static long System.Numerics.INumberBase&lt;System.Int64&gt;.Zero { get; }
+        static long System.Numerics.ISignedNumber&lt;System.Int64&gt;.NegativeOne { get; }
+        public static long Abs(long value);
+        public static long Clamp(long value, long min, long max);
+        public static long CopySign(long value, long sign);
+        public static long CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static long CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static long CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (long Quotient, long Remainder) DivRem(long left, long right);
+        public static bool IsEvenInteger(long value);
+        public static bool IsNegative(long value);
+        public static bool IsOddInteger(long value);
+        public static bool IsPositive(long value);
+        public static bool IsPow2(long value);
+        public static long LeadingZeroCount(long value);
+        public static long Log2(long value);
+        public static long Max(long x, long y);
+        public static long MaxMagnitude(long x, long y);
+        public static long Min(long x, long y);
+        public static long MinMagnitude(long x, long y);
+        public static long Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static long PopCount(long value);
+        public static long RotateLeft(long value, int rotateAmount);
+        public static long RotateRight(long value, int rotateAmount);
+        public static int Sign(long value);
+        static long IAdditionOperators&lt;long, long, long&gt;.operator +(long left, long right);
+        static long IAdditionOperators&lt;long, long, long&gt;.operator checked +(long left, long right);
+        int IBinaryInteger&lt;long&gt;.GetByteCount();
+        int IBinaryInteger&lt;long&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;long&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out long value);
+        static bool IBinaryInteger&lt;long&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out long value);
+        bool IBinaryInteger&lt;long&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;long&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static long IBitwiseOperators&lt;long, long, long&gt;.operator &amp;(long left, long right);
+        static long IBitwiseOperators&lt;long, long, long&gt;.operator |(long left, long right);
+        static long IBitwiseOperators&lt;long, long, long&gt;.operator ^(long left, long right);
+        static long IBitwiseOperators&lt;long, long, long&gt;.operator ~(long value);
+        static bool IComparisonOperators&lt;long, long, bool&gt;.operator &gt;(long left, long right);
+        static bool IComparisonOperators&lt;long, long, bool&gt;.operator &gt;=(long left, long right);
+        static bool IComparisonOperators&lt;long, long, bool&gt;.operator &lt;(long left, long right);
+        static bool IComparisonOperators&lt;long, long, bool&gt;.operator &lt;=(long left, long right);
+        static long IDecrementOperators&lt;long&gt;.operator checked --(long value);
+        static long IDecrementOperators&lt;long&gt;.operator --(long value);
+        static long IDivisionOperators&lt;long, long, long&gt;.operator /(long left, long right);
+        static bool IEqualityOperators&lt;long, long, bool&gt;.operator ==(long left, long right);
+        static bool IEqualityOperators&lt;long, long, bool&gt;.operator !=(long left, long right);
+        static long IIncrementOperators&lt;long&gt;.operator checked ++(long value);
+        static long IIncrementOperators&lt;long&gt;.operator ++(long value);
+        static long IModulusOperators&lt;long, long, long&gt;.operator %(long left, long right);
+        static long IMultiplyOperators&lt;long, long, long&gt;.operator checked *(long left, long right);
+        static long IMultiplyOperators&lt;long, long, long&gt;.operator *(long left, long right);
+        static long INumber&lt;long&gt;.MaxNumber(long x, long y);
+        static long INumber&lt;long&gt;.MinNumber(long x, long y);
+        static bool INumberBase&lt;long&gt;.IsCanonical(long value);
+        static bool INumberBase&lt;long&gt;.IsComplexNumber(long value);
+        static bool INumberBase&lt;long&gt;.IsFinite(long value);
+        static bool INumberBase&lt;long&gt;.IsImaginaryNumber(long value);
+        static bool INumberBase&lt;long&gt;.IsInfinity(long value);
+        static bool INumberBase&lt;long&gt;.IsInteger(long value);
+        static bool INumberBase&lt;long&gt;.IsNaN(long value);
+        static bool INumberBase&lt;long&gt;.IsNegativeInfinity(long value);
+        static bool INumberBase&lt;long&gt;.IsNormal(long value);
+        static bool INumberBase&lt;long&gt;.IsPositiveInfinity(long value);
+        static bool INumberBase&lt;long&gt;.IsRealNumber(long value);
+        static bool INumberBase&lt;long&gt;.IsSubnormal(long value);
+        static bool INumberBase&lt;long&gt;.IsZero(long value);
+        static long INumberBase&lt;long&gt;.MaxMagnitudeNumber(long x, long y);
+        static long INumberBase&lt;long&gt;.MinMagnitudeNumber(long x, long y);
+        static bool INumberBase&lt;long&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out long result);
+        static bool INumberBase&lt;long&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out long result);
+        static bool INumberBase&lt;long&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out long result);
+        static bool INumberBase&lt;long&gt;.TryConvertToChecked&lt;TOther&gt;(long value, out TOther result);
+        static bool INumberBase&lt;long&gt;.TryConvertToSaturating&lt;TOther&gt;(long value, out TOther result);
+        static bool INumberBase&lt;long&gt;.TryConvertToTruncating&lt;TOther&gt;(long value, out TOther result);
+        static long IShiftOperators&lt;long, int, long&gt;.operator &lt;&lt;(long value, int shiftAmount);
+        static long IShiftOperators&lt;long, int, long&gt;.operator &gt;&gt;(long value, int shiftAmount);
+        static long IShiftOperators&lt;long, int, long&gt;.operator &gt;&gt;&gt;(long value, int shiftAmount);
+        static long ISubtractionOperators&lt;long, long, long&gt;.operator checked -(long left, long right);
+        static long ISubtractionOperators&lt;long, long, long&gt;.operator -(long left, long right);
+        static long IUnaryNegationOperators&lt;long, long&gt;.operator checked -(long value);
+        static long IUnaryNegationOperators&lt;long, long&gt;.operator -(long value);
+        static long IUnaryPlusOperators&lt;long, long&gt;.operator +(long value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static long TrailingZeroCount(long value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out long result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out long result);
     }
-    public readonly struct IntPtr : IComparable, IComparable&lt;IntPtr&gt;, IEquatable&lt;IntPtr&gt;, IFormattable, ISerializable, ISpanFormattable {
+    public readonly struct IntPtr : IAdditionOperators&lt;IntPtr, IntPtr, IntPtr&gt;, IAdditiveIdentity&lt;IntPtr, IntPtr&gt;, IBinaryInteger&lt;IntPtr&gt;, IBinaryNumber&lt;IntPtr&gt;, IBitwiseOperators&lt;IntPtr, IntPtr, IntPtr&gt;, IComparable, IComparable&lt;IntPtr&gt;, IComparisonOperators&lt;IntPtr, IntPtr, bool&gt;, IDecrementOperators&lt;IntPtr&gt;, IDivisionOperators&lt;IntPtr, IntPtr, IntPtr&gt;, IEqualityOperators&lt;IntPtr, IntPtr, bool&gt;, IEquatable&lt;IntPtr&gt;, IFormattable, IIncrementOperators&lt;IntPtr&gt;, IMinMaxValue&lt;IntPtr&gt;, IModulusOperators&lt;IntPtr, IntPtr, IntPtr&gt;, IMultiplicativeIdentity&lt;IntPtr, IntPtr&gt;, IMultiplyOperators&lt;IntPtr, IntPtr, IntPtr&gt;, INumber&lt;IntPtr&gt;, INumberBase&lt;IntPtr&gt;, IParsable&lt;IntPtr&gt;, ISerializable, IShiftOperators&lt;IntPtr, int, IntPtr&gt;, ISignedNumber&lt;IntPtr&gt;, ISpanFormattable, ISpanParsable&lt;IntPtr&gt;, ISubtractionOperators&lt;IntPtr, IntPtr, IntPtr&gt;, IUnaryNegationOperators&lt;IntPtr, IntPtr&gt;, IUnaryPlusOperators&lt;IntPtr, IntPtr&gt; {
+        static IntPtr System.Numerics.IAdditiveIdentity&lt;nint,nint&gt;.AdditiveIdentity { get; }
+        static IntPtr System.Numerics.IBinaryNumber&lt;nint&gt;.AllBitsSet { get; }
+        static IntPtr System.Numerics.IMinMaxValue&lt;nint&gt;.MaxValue { get; }
+        static IntPtr System.Numerics.IMinMaxValue&lt;nint&gt;.MinValue { get; }
+        static IntPtr System.Numerics.IMultiplicativeIdentity&lt;nint,nint&gt;.MultiplicativeIdentity { get; }
+        static IntPtr System.Numerics.INumberBase&lt;nint&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;nint&gt;.Radix { get; }
+        static IntPtr System.Numerics.INumberBase&lt;nint&gt;.Zero { get; }
+        static IntPtr System.Numerics.ISignedNumber&lt;nint&gt;.NegativeOne { get; }
+        public static IntPtr Abs(IntPtr value);
+        public static IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max);
+        public static IntPtr CopySign(IntPtr value, IntPtr sign);
+        public static IntPtr CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static IntPtr CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static IntPtr CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (IntPtr Quotient, IntPtr Remainder) DivRem(IntPtr left, IntPtr right);
+        public static bool IsEvenInteger(IntPtr value);
+        public static bool IsNegative(IntPtr value);
+        public static bool IsOddInteger(IntPtr value);
+        public static bool IsPositive(IntPtr value);
+        public static bool IsPow2(IntPtr value);
+        public static IntPtr LeadingZeroCount(IntPtr value);
+        public static IntPtr Log2(IntPtr value);
+        public static IntPtr Max(IntPtr x, IntPtr y);
+        public static IntPtr MaxMagnitude(IntPtr x, IntPtr y);
+        public static IntPtr Min(IntPtr x, IntPtr y);
+        public static IntPtr MinMagnitude(IntPtr x, IntPtr y);
+        public static IntPtr Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static IntPtr PopCount(IntPtr value);
+        public static IntPtr RotateLeft(IntPtr value, int rotateAmount);
+        public static IntPtr RotateRight(IntPtr value, int rotateAmount);
+        public static int Sign(IntPtr value);
+        static IntPtr IAdditionOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator +(IntPtr left, IntPtr right);
+        static IntPtr IAdditionOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator checked +(IntPtr left, IntPtr right);
+        int IBinaryInteger&lt;IntPtr&gt;.GetByteCount();
+        int IBinaryInteger&lt;IntPtr&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;IntPtr&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out IntPtr value);
+        static bool IBinaryInteger&lt;IntPtr&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out IntPtr value);
+        bool IBinaryInteger&lt;IntPtr&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;IntPtr&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static IntPtr IBitwiseOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator &amp;(IntPtr left, IntPtr right);
+        static IntPtr IBitwiseOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator |(IntPtr left, IntPtr right);
+        static IntPtr IBitwiseOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator ^(IntPtr left, IntPtr right);
+        static IntPtr IBitwiseOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator ~(IntPtr value);
+        static bool IComparisonOperators&lt;IntPtr, IntPtr, bool&gt;.operator &gt;(IntPtr left, IntPtr right);
+        static bool IComparisonOperators&lt;IntPtr, IntPtr, bool&gt;.operator &gt;=(IntPtr left, IntPtr right);
+        static bool IComparisonOperators&lt;IntPtr, IntPtr, bool&gt;.operator &lt;(IntPtr left, IntPtr right);
+        static bool IComparisonOperators&lt;IntPtr, IntPtr, bool&gt;.operator &lt;=(IntPtr left, IntPtr right);
+        static IntPtr IDecrementOperators&lt;IntPtr&gt;.operator checked --(IntPtr value);
+        static IntPtr IDecrementOperators&lt;IntPtr&gt;.operator --(IntPtr value);
+        static IntPtr IDivisionOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator /(IntPtr left, IntPtr right);
+        static IntPtr IIncrementOperators&lt;IntPtr&gt;.operator checked ++(IntPtr value);
+        static IntPtr IIncrementOperators&lt;IntPtr&gt;.operator ++(IntPtr value);
+        static IntPtr IModulusOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator %(IntPtr left, IntPtr right);
+        static IntPtr IMultiplyOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator checked *(IntPtr left, IntPtr right);
+        static IntPtr IMultiplyOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator *(IntPtr left, IntPtr right);
+        static IntPtr INumber&lt;IntPtr&gt;.MaxNumber(IntPtr x, IntPtr y);
+        static IntPtr INumber&lt;IntPtr&gt;.MinNumber(IntPtr x, IntPtr y);
+        static bool INumberBase&lt;IntPtr&gt;.IsCanonical(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsComplexNumber(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsFinite(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsImaginaryNumber(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsInfinity(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsInteger(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsNaN(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsNegativeInfinity(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsNormal(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsPositiveInfinity(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsRealNumber(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsSubnormal(IntPtr value);
+        static bool INumberBase&lt;IntPtr&gt;.IsZero(IntPtr value);
+        static IntPtr INumberBase&lt;IntPtr&gt;.MaxMagnitudeNumber(IntPtr x, IntPtr y);
+        static IntPtr INumberBase&lt;IntPtr&gt;.MinMagnitudeNumber(IntPtr x, IntPtr y);
+        static bool INumberBase&lt;IntPtr&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out IntPtr result);
+        static bool INumberBase&lt;IntPtr&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out IntPtr result);
+        static bool INumberBase&lt;IntPtr&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out IntPtr result);
+        static bool INumberBase&lt;IntPtr&gt;.TryConvertToChecked&lt;TOther&gt;(IntPtr value, out TOther result);
+        static bool INumberBase&lt;IntPtr&gt;.TryConvertToSaturating&lt;TOther&gt;(IntPtr value, out TOther result);
+        static bool INumberBase&lt;IntPtr&gt;.TryConvertToTruncating&lt;TOther&gt;(IntPtr value, out TOther result);
+        static IntPtr IShiftOperators&lt;IntPtr, int, IntPtr&gt;.operator &lt;&lt;(IntPtr value, int shiftAmount);
+        static IntPtr IShiftOperators&lt;IntPtr, int, IntPtr&gt;.operator &gt;&gt;(IntPtr value, int shiftAmount);
+        static IntPtr IShiftOperators&lt;IntPtr, int, IntPtr&gt;.operator &gt;&gt;&gt;(IntPtr value, int shiftAmount);
+        static IntPtr ISubtractionOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator checked -(IntPtr left, IntPtr right);
+        static IntPtr ISubtractionOperators&lt;IntPtr, IntPtr, IntPtr&gt;.operator -(IntPtr left, IntPtr right);
+        static IntPtr IUnaryNegationOperators&lt;IntPtr, IntPtr&gt;.operator checked -(IntPtr value);
+        static IntPtr IUnaryNegationOperators&lt;IntPtr, IntPtr&gt;.operator -(IntPtr value);
+        static IntPtr IUnaryPlusOperators&lt;IntPtr, IntPtr&gt;.operator +(IntPtr value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static IntPtr TrailingZeroCount(IntPtr value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out IntPtr result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out IntPtr result);
     }
+    public interface IParsable&lt;TSelf&gt; where TSelf : IParsable&lt;TSelf&gt;? {
+        static abstract TSelf Parse(string s, IFormatProvider? provider);
+        static abstract bool TryParse(string? s, IFormatProvider? provider, out TSelf result);
+    }
+    public interface ISpanParsable&lt;TSelf&gt; : IParsable&lt;TSelf&gt; where TSelf : ISpanParsable&lt;TSelf&gt;? {
+        static abstract TSelf Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        static abstract bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out TSelf result);
+    }
     public static class MemoryExtensions {
+        public static int CommonPrefixLength&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);
+        public static int CommonPrefixLength&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, IEqualityComparer&lt;T&gt;? comparer);
+        public static int CommonPrefixLength&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);
+        public static int CommonPrefixLength&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, IEqualityComparer&lt;T&gt;? comparer);
-        public static bool Contains&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;
+        public static bool Contains&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
-        public static bool Contains&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;
+        public static bool Contains&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
-        public static bool EndsWith&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static bool EndsWith&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;?;
-        public static bool EndsWith&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static bool EndsWith&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static int IndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;
+        public static int IndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOf&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static int IndexOf&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOf&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;
+        public static int IndexOf&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;
+        public static int IndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;
+        public static int IndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;
+        public static int IndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;
+        public static int IndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;
+        public static int IndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
-        public static int IndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;
+        public static int IndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
+        public static int IndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOf&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOf&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOf&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T?&gt;;
-        public static int LastIndexOf&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOf&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOfAny&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
-        public static int LastIndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;
+        public static int LastIndexOfAny&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;?;
+        public static int LastIndexOfAnyExcept&lt;T&gt;(this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;?;
-        public static int SequenceCompareTo&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;
+        public static int SequenceCompareTo&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;?;
-        public static int SequenceCompareTo&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;
+        public static int SequenceCompareTo&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;?;
-        public static bool SequenceEqual&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;
+        public static bool SequenceEqual&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;?;
-        public static bool SequenceEqual&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;
+        public static bool SequenceEqual&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;?;
-        public static bool StartsWith&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static bool StartsWith&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;?;
-        public static bool StartsWith&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;
+        public static bool StartsWith&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;?;
-        public static Memory&lt;T&gt; Trim&lt;T&gt;(this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static Memory&lt;T&gt; Trim&lt;T&gt;(this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static Memory&lt;T&gt; Trim&lt;T&gt;(this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static Memory&lt;T&gt; Trim&lt;T&gt;(this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static Span&lt;T&gt; Trim&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static Span&lt;T&gt; Trim&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static Span&lt;T&gt; Trim&lt;T&gt;(this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static Span&lt;T&gt; Trim&lt;T&gt;(this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static Memory&lt;T&gt; TrimEnd&lt;T&gt;(this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static Memory&lt;T&gt; TrimEnd&lt;T&gt;(this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static Memory&lt;T&gt; TrimEnd&lt;T&gt;(this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static Memory&lt;T&gt; TrimEnd&lt;T&gt;(this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static Span&lt;T&gt; TrimEnd&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static Span&lt;T&gt; TrimEnd&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static Span&lt;T&gt; TrimEnd&lt;T&gt;(this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static Span&lt;T&gt; TrimEnd&lt;T&gt;(this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static Memory&lt;T&gt; TrimStart&lt;T&gt;(this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static Memory&lt;T&gt; TrimStart&lt;T&gt;(this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static Memory&lt;T&gt; TrimStart&lt;T&gt;(this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static Memory&lt;T&gt; TrimStart&lt;T&gt;(this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt;(this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;?;
-        public static Span&lt;T&gt; TrimStart&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;
+        public static Span&lt;T&gt; TrimStart&lt;T&gt;(this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;?;
-        public static Span&lt;T&gt; TrimStart&lt;T&gt;(this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;
+        public static Span&lt;T&gt; TrimStart&lt;T&gt;(this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;?;
     }
-    public struct ModuleHandle
+    public struct ModuleHandle : IEquatable&lt;ModuleHandle&gt;
     public static class Nullable {
+        public static ref readonly T GetValueRefOrDefaultRef&lt;T&gt;(in T? nullable) where T : struct;
     }
     public class ObjectDisposedException : InvalidOperationException {
+        public static void ThrowIf(bool condition, object instance);
+        public static void ThrowIf(bool condition, Type type);
     }
     public readonly ref struct ReadOnlySpan&lt;T&gt; {
+        public ReadOnlySpan(in T reference);
     }
-    public struct RuntimeFieldHandle : ISerializable {
+    public struct RuntimeFieldHandle : IEquatable&lt;RuntimeFieldHandle&gt;, ISerializable {
+        public static RuntimeFieldHandle FromIntPtr(IntPtr value);
+        public static IntPtr ToIntPtr(RuntimeFieldHandle value);
     }
-    public struct RuntimeMethodHandle : ISerializable {
+    public struct RuntimeMethodHandle : IEquatable&lt;RuntimeMethodHandle&gt;, ISerializable {
+        public static RuntimeMethodHandle FromIntPtr(IntPtr value);
+        public static IntPtr ToIntPtr(RuntimeMethodHandle value);
     }
-    public struct RuntimeTypeHandle : ISerializable {
+    public struct RuntimeTypeHandle : IEquatable&lt;RuntimeTypeHandle&gt;, ISerializable {
+        public static RuntimeTypeHandle FromIntPtr(IntPtr value);
+        public static IntPtr ToIntPtr(RuntimeTypeHandle value);
     }
-    public readonly struct SByte : IComparable, IComparable&lt;sbyte&gt;, IConvertible, IEquatable&lt;sbyte&gt;, IFormattable, ISpanFormattable {
+    public readonly struct SByte : IAdditionOperators&lt;sbyte, sbyte, sbyte&gt;, IAdditiveIdentity&lt;sbyte, sbyte&gt;, IBinaryInteger&lt;sbyte&gt;, IBinaryNumber&lt;sbyte&gt;, IBitwiseOperators&lt;sbyte, sbyte, sbyte&gt;, IComparable, IComparable&lt;sbyte&gt;, IComparisonOperators&lt;sbyte, sbyte, bool&gt;, IConvertible, IDecrementOperators&lt;sbyte&gt;, IDivisionOperators&lt;sbyte, sbyte, sbyte&gt;, IEqualityOperators&lt;sbyte, sbyte, bool&gt;, IEquatable&lt;sbyte&gt;, IFormattable, IIncrementOperators&lt;sbyte&gt;, IMinMaxValue&lt;sbyte&gt;, IModulusOperators&lt;sbyte, sbyte, sbyte&gt;, IMultiplicativeIdentity&lt;sbyte, sbyte&gt;, IMultiplyOperators&lt;sbyte, sbyte, sbyte&gt;, INumber&lt;sbyte&gt;, INumberBase&lt;sbyte&gt;, IParsable&lt;sbyte&gt;, IShiftOperators&lt;sbyte, int, sbyte&gt;, ISignedNumber&lt;sbyte&gt;, ISpanFormattable, ISpanParsable&lt;sbyte&gt;, ISubtractionOperators&lt;sbyte, sbyte, sbyte&gt;, IUnaryNegationOperators&lt;sbyte, sbyte&gt;, IUnaryPlusOperators&lt;sbyte, sbyte&gt; {
+        static sbyte System.Numerics.IAdditiveIdentity&lt;System.SByte,System.SByte&gt;.AdditiveIdentity { get; }
+        static sbyte System.Numerics.IBinaryNumber&lt;System.SByte&gt;.AllBitsSet { get; }
+        static sbyte System.Numerics.IMinMaxValue&lt;System.SByte&gt;.MaxValue { get; }
+        static sbyte System.Numerics.IMinMaxValue&lt;System.SByte&gt;.MinValue { get; }
+        static sbyte System.Numerics.IMultiplicativeIdentity&lt;System.SByte,System.SByte&gt;.MultiplicativeIdentity { get; }
+        static sbyte System.Numerics.INumberBase&lt;System.SByte&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.SByte&gt;.Radix { get; }
+        static sbyte System.Numerics.INumberBase&lt;System.SByte&gt;.Zero { get; }
+        static sbyte System.Numerics.ISignedNumber&lt;System.SByte&gt;.NegativeOne { get; }
+        public static sbyte Abs(sbyte value);
+        public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
+        public static sbyte CopySign(sbyte value, sbyte sign);
+        public static sbyte CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static sbyte CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static sbyte CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (sbyte Quotient, sbyte Remainder) DivRem(sbyte left, sbyte right);
+        public static bool IsEvenInteger(sbyte value);
+        public static bool IsNegative(sbyte value);
+        public static bool IsOddInteger(sbyte value);
+        public static bool IsPositive(sbyte value);
+        public static bool IsPow2(sbyte value);
+        public static sbyte LeadingZeroCount(sbyte value);
+        public static sbyte Log2(sbyte value);
+        public static sbyte Max(sbyte x, sbyte y);
+        public static sbyte MaxMagnitude(sbyte x, sbyte y);
+        public static sbyte Min(sbyte x, sbyte y);
+        public static sbyte MinMagnitude(sbyte x, sbyte y);
+        public static sbyte Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static sbyte PopCount(sbyte value);
+        public static sbyte RotateLeft(sbyte value, int rotateAmount);
+        public static sbyte RotateRight(sbyte value, int rotateAmount);
+        public static int Sign(sbyte value);
+        static sbyte IAdditionOperators&lt;sbyte, sbyte, sbyte&gt;.operator +(sbyte left, sbyte right);
+        static sbyte IAdditionOperators&lt;sbyte, sbyte, sbyte&gt;.operator checked +(sbyte left, sbyte right);
+        int IBinaryInteger&lt;sbyte&gt;.GetByteCount();
+        int IBinaryInteger&lt;sbyte&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;sbyte&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out sbyte value);
+        static bool IBinaryInteger&lt;sbyte&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out sbyte value);
+        bool IBinaryInteger&lt;sbyte&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;sbyte&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static sbyte IBitwiseOperators&lt;sbyte, sbyte, sbyte&gt;.operator &amp;(sbyte left, sbyte right);
+        static sbyte IBitwiseOperators&lt;sbyte, sbyte, sbyte&gt;.operator |(sbyte left, sbyte right);
+        static sbyte IBitwiseOperators&lt;sbyte, sbyte, sbyte&gt;.operator ^(sbyte left, sbyte right);
+        static sbyte IBitwiseOperators&lt;sbyte, sbyte, sbyte&gt;.operator ~(sbyte value);
+        static bool IComparisonOperators&lt;sbyte, sbyte, bool&gt;.operator &gt;(sbyte left, sbyte right);
+        static bool IComparisonOperators&lt;sbyte, sbyte, bool&gt;.operator &gt;=(sbyte left, sbyte right);
+        static bool IComparisonOperators&lt;sbyte, sbyte, bool&gt;.operator &lt;(sbyte left, sbyte right);
+        static bool IComparisonOperators&lt;sbyte, sbyte, bool&gt;.operator &lt;=(sbyte left, sbyte right);
+        static sbyte IDecrementOperators&lt;sbyte&gt;.operator checked --(sbyte value);
+        static sbyte IDecrementOperators&lt;sbyte&gt;.operator --(sbyte value);
+        static sbyte IDivisionOperators&lt;sbyte, sbyte, sbyte&gt;.operator /(sbyte left, sbyte right);
+        static bool IEqualityOperators&lt;sbyte, sbyte, bool&gt;.operator ==(sbyte left, sbyte right);
+        static bool IEqualityOperators&lt;sbyte, sbyte, bool&gt;.operator !=(sbyte left, sbyte right);
+        static sbyte IIncrementOperators&lt;sbyte&gt;.operator checked ++(sbyte value);
+        static sbyte IIncrementOperators&lt;sbyte&gt;.operator ++(sbyte value);
+        static sbyte IModulusOperators&lt;sbyte, sbyte, sbyte&gt;.operator %(sbyte left, sbyte right);
+        static sbyte IMultiplyOperators&lt;sbyte, sbyte, sbyte&gt;.operator checked *(sbyte left, sbyte right);
+        static sbyte IMultiplyOperators&lt;sbyte, sbyte, sbyte&gt;.operator *(sbyte left, sbyte right);
+        static sbyte INumber&lt;sbyte&gt;.MaxNumber(sbyte x, sbyte y);
+        static sbyte INumber&lt;sbyte&gt;.MinNumber(sbyte x, sbyte y);
+        static bool INumberBase&lt;sbyte&gt;.IsCanonical(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsComplexNumber(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsFinite(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsImaginaryNumber(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsInfinity(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsInteger(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsNaN(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsNegativeInfinity(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsNormal(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsPositiveInfinity(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsRealNumber(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsSubnormal(sbyte value);
+        static bool INumberBase&lt;sbyte&gt;.IsZero(sbyte value);
+        static sbyte INumberBase&lt;sbyte&gt;.MaxMagnitudeNumber(sbyte x, sbyte y);
+        static sbyte INumberBase&lt;sbyte&gt;.MinMagnitudeNumber(sbyte x, sbyte y);
+        static bool INumberBase&lt;sbyte&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out sbyte result);
+        static bool INumberBase&lt;sbyte&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out sbyte result);
+        static bool INumberBase&lt;sbyte&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out sbyte result);
+        static bool INumberBase&lt;sbyte&gt;.TryConvertToChecked&lt;TOther&gt;(sbyte value, out TOther result);
+        static bool INumberBase&lt;sbyte&gt;.TryConvertToSaturating&lt;TOther&gt;(sbyte value, out TOther result);
+        static bool INumberBase&lt;sbyte&gt;.TryConvertToTruncating&lt;TOther&gt;(sbyte value, out TOther result);
+        static sbyte IShiftOperators&lt;sbyte, int, sbyte&gt;.operator &lt;&lt;(sbyte value, int shiftAmount);
+        static sbyte IShiftOperators&lt;sbyte, int, sbyte&gt;.operator &gt;&gt;(sbyte value, int shiftAmount);
+        static sbyte IShiftOperators&lt;sbyte, int, sbyte&gt;.operator &gt;&gt;&gt;(sbyte value, int shiftAmount);
+        static sbyte ISubtractionOperators&lt;sbyte, sbyte, sbyte&gt;.operator checked -(sbyte left, sbyte right);
+        static sbyte ISubtractionOperators&lt;sbyte, sbyte, sbyte&gt;.operator -(sbyte left, sbyte right);
+        static sbyte IUnaryNegationOperators&lt;sbyte, sbyte&gt;.operator checked -(sbyte value);
+        static sbyte IUnaryNegationOperators&lt;sbyte, sbyte&gt;.operator -(sbyte value);
+        static sbyte IUnaryPlusOperators&lt;sbyte, sbyte&gt;.operator +(sbyte value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static sbyte TrailingZeroCount(sbyte value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out sbyte result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out sbyte result);
     }
-    public readonly struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable, ISpanFormattable {
+    public readonly struct Single : IAdditionOperators&lt;float, float, float&gt;, IAdditiveIdentity&lt;float, float&gt;, IBinaryFloatingPointIeee754&lt;float&gt;, IBinaryNumber&lt;float&gt;, IBitwiseOperators&lt;float, float, float&gt;, IComparable, IComparable&lt;float&gt;, IComparisonOperators&lt;float, float, bool&gt;, IConvertible, IDecrementOperators&lt;float&gt;, IDivisionOperators&lt;float, float, float&gt;, IEqualityOperators&lt;float, float, bool&gt;, IEquatable&lt;float&gt;, IExponentialFunctions&lt;float&gt;, IFloatingPoint&lt;float&gt;, IFloatingPointConstants&lt;float&gt;, IFloatingPointIeee754&lt;float&gt;, IFormattable, IHyperbolicFunctions&lt;float&gt;, IIncrementOperators&lt;float&gt;, ILogarithmicFunctions&lt;float&gt;, IMinMaxValue&lt;float&gt;, IModulusOperators&lt;float, float, float&gt;, IMultiplicativeIdentity&lt;float, float&gt;, IMultiplyOperators&lt;float, float, float&gt;, INumber&lt;float&gt;, INumberBase&lt;float&gt;, IParsable&lt;float&gt;, IPowerFunctions&lt;float&gt;, IRootFunctions&lt;float&gt;, ISignedNumber&lt;float&gt;, ISpanFormattable, ISpanParsable&lt;float&gt;, ISubtractionOperators&lt;float, float, float&gt;, ITrigonometricFunctions&lt;float&gt;, IUnaryNegationOperators&lt;float, float&gt;, IUnaryPlusOperators&lt;float, float&gt; {
+        public const float E = 2.7182817f;
+        public const float NegativeZero = -0f;
+        public const float Pi = 3.1415927f;
+        public const float Tau = 6.2831855f;
+        static float System.Numerics.IAdditiveIdentity&lt;System.Single,System.Single&gt;.AdditiveIdentity { get; }
+        static float System.Numerics.IBinaryNumber&lt;System.Single&gt;.AllBitsSet { get; }
+        static float System.Numerics.IFloatingPointConstants&lt;System.Single&gt;.E { get; }
+        static float System.Numerics.IFloatingPointConstants&lt;System.Single&gt;.Pi { get; }
+        static float System.Numerics.IFloatingPointConstants&lt;System.Single&gt;.Tau { get; }
+        static float System.Numerics.IFloatingPointIeee754&lt;System.Single&gt;.Epsilon { get; }
+        static float System.Numerics.IFloatingPointIeee754&lt;System.Single&gt;.NaN { get; }
+        static float System.Numerics.IFloatingPointIeee754&lt;System.Single&gt;.NegativeInfinity { get; }
+        static float System.Numerics.IFloatingPointIeee754&lt;System.Single&gt;.NegativeZero { get; }
+        static float System.Numerics.IFloatingPointIeee754&lt;System.Single&gt;.PositiveInfinity { get; }
+        static float System.Numerics.IMinMaxValue&lt;System.Single&gt;.MaxValue { get; }
+        static float System.Numerics.IMinMaxValue&lt;System.Single&gt;.MinValue { get; }
+        static float System.Numerics.IMultiplicativeIdentity&lt;System.Single,System.Single&gt;.MultiplicativeIdentity { get; }
+        static float System.Numerics.INumberBase&lt;System.Single&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.Single&gt;.Radix { get; }
+        static float System.Numerics.INumberBase&lt;System.Single&gt;.Zero { get; }
+        static float System.Numerics.ISignedNumber&lt;System.Single&gt;.NegativeOne { get; }
+        public static float Abs(float value);
+        public static float Acos(float x);
+        public static float Acosh(float x);
+        public static float AcosPi(float x);
+        public static float Asin(float x);
+        public static float Asinh(float x);
+        public static float AsinPi(float x);
+        public static float Atan(float x);
+        public static float Atan2(float y, float x);
+        public static float Atan2Pi(float y, float x);
+        public static float Atanh(float x);
+        public static float AtanPi(float x);
+        public static float BitDecrement(float x);
+        public static float BitIncrement(float x);
+        public static float Cbrt(float x);
+        public static float Ceiling(float x);
+        public static float Clamp(float value, float min, float max);
+        public static float CopySign(float value, float sign);
+        public static float Cos(float x);
+        public static float Cosh(float x);
+        public static float CosPi(float x);
+        public static float CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static float CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static float CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static float Exp(float x);
+        public static float Exp10(float x);
+        public static float Exp10M1(float x);
+        public static float Exp2(float x);
+        public static float Exp2M1(float x);
+        public static float ExpM1(float x);
+        public static float Floor(float x);
+        public static float FusedMultiplyAdd(float left, float right, float addend);
+        public static float Hypot(float x, float y);
+        public static float Ieee754Remainder(float left, float right);
+        public static int ILogB(float x);
+        public static bool IsEvenInteger(float value);
+        public static bool IsInteger(float value);
+        public static bool IsOddInteger(float value);
+        public static bool IsPositive(float value);
+        public static bool IsPow2(float value);
+        public static bool IsRealNumber(float value);
+        public static float Log(float x);
+        public static float Log(float x, float newBase);
+        public static float Log10(float x);
+        public static float Log10P1(float x);
+        public static float Log2(float value);
+        public static float Log2P1(float x);
+        public static float LogP1(float x);
+        public static float Max(float x, float y);
+        public static float MaxMagnitude(float x, float y);
+        public static float MaxMagnitudeNumber(float x, float y);
+        public static float MaxNumber(float x, float y);
+        public static float Min(float x, float y);
+        public static float MinMagnitude(float x, float y);
+        public static float MinMagnitudeNumber(float x, float y);
+        public static float MinNumber(float x, float y);
+        public static float Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static float Pow(float x, float y);
+        public static float ReciprocalEstimate(float x);
+        public static float ReciprocalSqrtEstimate(float x);
+        public static float RootN(float x, int n);
+        public static float Round(float x);
+        public static float Round(float x, int digits);
+        public static float Round(float x, int digits, MidpointRounding mode);
+        public static float Round(float x, MidpointRounding mode);
+        public static float ScaleB(float x, int n);
+        public static int Sign(float value);
+        public static float Sin(float x);
+        public static (float Sin, float Cos) SinCos(float x);
+        public static (float SinPi, float CosPi) SinCosPi(float x);
+        public static float Sinh(float x);
+        public static float SinPi(float x);
+        public static float Sqrt(float x);
+        static float IAdditionOperators&lt;float, float, float&gt;.operator +(float left, float right);
+        static float IBitwiseOperators&lt;float, float, float&gt;.operator &amp;(float left, float right);
+        static float IBitwiseOperators&lt;float, float, float&gt;.operator |(float left, float right);
+        static float IBitwiseOperators&lt;float, float, float&gt;.operator ^(float left, float right);
+        static float IBitwiseOperators&lt;float, float, float&gt;.operator ~(float value);
+        static float IDecrementOperators&lt;float&gt;.operator --(float value);
+        static float IDivisionOperators&lt;float, float, float&gt;.operator /(float left, float right);
+        int IFloatingPoint&lt;float&gt;.GetExponentByteCount();
+        int IFloatingPoint&lt;float&gt;.GetExponentShortestBitLength();
+        int IFloatingPoint&lt;float&gt;.GetSignificandBitLength();
+        int IFloatingPoint&lt;float&gt;.GetSignificandByteCount();
+        bool IFloatingPoint&lt;float&gt;.TryWriteExponentBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;float&gt;.TryWriteExponentLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;float&gt;.TryWriteSignificandBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IFloatingPoint&lt;float&gt;.TryWriteSignificandLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static float IIncrementOperators&lt;float&gt;.operator ++(float value);
+        static float IModulusOperators&lt;float, float, float&gt;.operator %(float left, float right);
+        static float IMultiplyOperators&lt;float, float, float&gt;.operator *(float left, float right);
+        static bool INumberBase&lt;float&gt;.IsCanonical(float value);
+        static bool INumberBase&lt;float&gt;.IsComplexNumber(float value);
+        static bool INumberBase&lt;float&gt;.IsImaginaryNumber(float value);
+        static bool INumberBase&lt;float&gt;.IsZero(float value);
+        static bool INumberBase&lt;float&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out float result);
+        static bool INumberBase&lt;float&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out float result);
+        static bool INumberBase&lt;float&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out float result);
+        static bool INumberBase&lt;float&gt;.TryConvertToChecked&lt;TOther&gt;(float value, out TOther result);
+        static bool INumberBase&lt;float&gt;.TryConvertToSaturating&lt;TOther&gt;(float value, out TOther result);
+        static bool INumberBase&lt;float&gt;.TryConvertToTruncating&lt;TOther&gt;(float value, out TOther result);
+        static float ISubtractionOperators&lt;float, float, float&gt;.operator -(float left, float right);
+        static float IUnaryNegationOperators&lt;float, float&gt;.operator -(float value);
+        static float IUnaryPlusOperators&lt;float, float&gt;.operator +(float value);
+        public static float Tan(float x);
+        public static float Tanh(float x);
+        public static float TanPi(float x);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static float Truncate(float x);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out float result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out float result);
     }
     public readonly ref struct Span&lt;T&gt; {
+        public Span(ref T reference);
     }
     public sealed class String : ICloneable, IComparable, IComparable&lt;string?&gt;, IConvertible, IEnumerable, IEnumerable&lt;char&gt;, IEquatable&lt;string?&gt; {
         public static string Format(IFormatProvider? provider, string format, object? arg0);
         public static string Format(IFormatProvider? provider, string format, object? arg0, object? arg1);
         public static string Format(IFormatProvider? provider, string format, object? arg0, object? arg1, object? arg2);
         public static string Format(IFormatProvider? provider, string format, params object?[] args);
         public static string Format(string format, object? arg0);
         public static string Format(string format, object? arg0, object? arg1);
         public static string Format(string format, object? arg0, object? arg1, object? arg2);
         public static string Format(string format, params object?[] args);
     }
-    public readonly struct TimeOnly : IComparable, IComparable&lt;TimeOnly&gt;, IEquatable&lt;TimeOnly&gt;, IFormattable, ISpanFormattable {
+    public readonly struct TimeOnly : IComparable, IComparable&lt;TimeOnly&gt;, IEquatable&lt;TimeOnly&gt;, IFormattable, IParsable&lt;TimeOnly&gt;, ISpanFormattable, ISpanParsable&lt;TimeOnly&gt; {
+        public TimeOnly(int hour, int minute, int second, int millisecond, int microsecond);
+        public int Microsecond { get; }
+        public int Nanosecond { get; }
+        public static TimeOnly Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static TimeOnly Parse(string s, IFormatProvider? provider);
         public static TimeOnly ParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider = null, DateTimeStyles style = DateTimeStyles.None);
         public static TimeOnly ParseExact(ReadOnlySpan&lt;char&gt; s, string[] formats);
         public static TimeOnly ParseExact(ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public static TimeOnly ParseExact(string s, string format);
         public static TimeOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public static TimeOnly ParseExact(string s, string[] formats);
         public static TimeOnly ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out TimeOnly result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out TimeOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, out TimeOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, string?[]? formats, out TimeOnly result);
         public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result);
         public static bool TryParseExact(string? s, string? format, out TimeOnly result);
         public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result);
         public static bool TryParseExact(string? s, string?[]? formats, out TimeOnly result);
     }
-    public readonly struct TimeSpan : IComparable, IComparable&lt;TimeSpan&gt;, IEquatable&lt;TimeSpan&gt;, IFormattable, ISpanFormattable {
+    public readonly struct TimeSpan : IComparable, IComparable&lt;TimeSpan&gt;, IEquatable&lt;TimeSpan&gt;, IFormattable, IParsable&lt;TimeSpan&gt;, ISpanFormattable, ISpanParsable&lt;TimeSpan&gt; {
+        public const long NanosecondsPerTick = (long)100;
+        public const long TicksPerMicrosecond = (long)10;
+        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds, int microseconds);
+        public int Microseconds { get; }
+        public int Nanoseconds { get; }
+        public double TotalMicroseconds { get; }
+        public double TotalNanoseconds { get; }
+        public static TimeSpan FromMicroseconds(double value);
         public static TimeSpan ParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider? formatProvider, TimeSpanStyles styles = TimeSpanStyles.None);
         public static TimeSpan ParseExact(ReadOnlySpan&lt;char&gt; input, string[] formats, IFormatProvider? formatProvider, TimeSpanStyles styles = TimeSpanStyles.None);
         public static TimeSpan ParseExact(string input, string format, IFormatProvider? formatProvider);
         public static TimeSpan ParseExact(string input, string format, IFormatProvider? formatProvider, TimeSpanStyles styles);
         public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider? formatProvider);
         public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider? formatProvider, TimeSpanStyles styles);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? formatProvider);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? formatProvider = null);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider? formatProvider, out TimeSpan result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, string?[]? formats, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result);
         public static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, string?[]? formats, IFormatProvider? formatProvider, out TimeSpan result);
         public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result);
         public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, out TimeSpan result);
         public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result);
         public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, out TimeSpan result);
     }
     public sealed class TimeZoneInfo : IDeserializationCallback, IEquatable&lt;TimeZoneInfo?&gt;, ISerializable {
         public bool HasIanaId { get; }
         public sealed class AdjustmentRule : IDeserializationCallback, IEquatable&lt;TimeZoneInfo.AdjustmentRule?&gt;, ISerializable {
+            public override bool Equals(object? obj);
         }
     }
     public abstract class Type : MemberInfo, IReflect {
         public virtual Array GetEnumValues();
+        public virtual Array GetEnumValuesAsUnderlyingType();
-        public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
+        public static Type? GetTypeFromHandle(RuntimeTypeHandle handle);
         public virtual Type MakeArrayType();
         public virtual Type MakeArrayType(int rank);
         public virtual Type MakeGenericType(params Type[] typeArguments);
     }
+    public readonly struct UInt128 : IAdditionOperators&lt;UInt128, UInt128, UInt128&gt;, IAdditiveIdentity&lt;UInt128, UInt128&gt;, IBinaryInteger&lt;UInt128&gt;, IBinaryNumber&lt;UInt128&gt;, IBitwiseOperators&lt;UInt128, UInt128, UInt128&gt;, IComparable, IComparable&lt;UInt128&gt;, IComparisonOperators&lt;UInt128, UInt128, bool&gt;, IDecrementOperators&lt;UInt128&gt;, IDivisionOperators&lt;UInt128, UInt128, UInt128&gt;, IEqualityOperators&lt;UInt128, UInt128, bool&gt;, IEquatable&lt;UInt128&gt;, IFormattable, IIncrementOperators&lt;UInt128&gt;, IMinMaxValue&lt;UInt128&gt;, IModulusOperators&lt;UInt128, UInt128, UInt128&gt;, IMultiplicativeIdentity&lt;UInt128, UInt128&gt;, IMultiplyOperators&lt;UInt128, UInt128, UInt128&gt;, INumber&lt;UInt128&gt;, INumberBase&lt;UInt128&gt;, IParsable&lt;UInt128&gt;, IShiftOperators&lt;UInt128, int, UInt128&gt;, ISpanFormattable, ISpanParsable&lt;UInt128&gt;, ISubtractionOperators&lt;UInt128, UInt128, UInt128&gt;, IUnaryNegationOperators&lt;UInt128, UInt128&gt;, IUnaryPlusOperators&lt;UInt128, UInt128&gt;, IUnsignedNumber&lt;UInt128&gt; {
+        public UInt128(ulong upper, ulong lower);
+        public static UInt128 MaxValue { get; }
+        public static UInt128 MinValue { get; }
+        public static UInt128 One { get; }
+        static UInt128 System.Numerics.IAdditiveIdentity&lt;System.UInt128,System.UInt128&gt;.AdditiveIdentity { get; }
+        static UInt128 System.Numerics.IBinaryNumber&lt;System.UInt128&gt;.AllBitsSet { get; }
+        static UInt128 System.Numerics.IMultiplicativeIdentity&lt;System.UInt128,System.UInt128&gt;.MultiplicativeIdentity { get; }
+        static int System.Numerics.INumberBase&lt;System.UInt128&gt;.Radix { get; }
+        public static UInt128 Zero { get; }
+        public static UInt128 Clamp(UInt128 value, UInt128 min, UInt128 max);
+        public int CompareTo(object? value);
+        public int CompareTo(UInt128 value);
+        public static UInt128 CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static UInt128 CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static UInt128 CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (UInt128 Quotient, UInt128 Remainder) DivRem(UInt128 left, UInt128 right);
+        public override bool Equals(object? obj);
+        public bool Equals(UInt128 other);
+        public override int GetHashCode();
+        public static bool IsEvenInteger(UInt128 value);
+        public static bool IsOddInteger(UInt128 value);
+        public static bool IsPow2(UInt128 value);
+        public static UInt128 LeadingZeroCount(UInt128 value);
+        public static UInt128 Log2(UInt128 value);
+        public static UInt128 Max(UInt128 x, UInt128 y);
+        public static UInt128 Min(UInt128 x, UInt128 y);
+        public static UInt128 operator +(UInt128 left, UInt128 right);
+        public static UInt128 operator &amp;(UInt128 left, UInt128 right);
+        public static UInt128 operator |(UInt128 left, UInt128 right);
+        public static UInt128 operator checked +(UInt128 left, UInt128 right);
+        public static UInt128 operator checked --(UInt128 value);
+        public static UInt128 operator checked /(UInt128 left, UInt128 right);
+        public static explicit operator checked UInt128 (double value);
+        public static explicit operator checked UInt128 (short value);
+        public static explicit operator checked UInt128 (int value);
+        public static explicit operator checked UInt128 (long value);
+        public static explicit operator checked UInt128 (IntPtr value);
+        public static explicit operator checked UInt128 (sbyte value);
+        public static explicit operator checked UInt128 (float value);
+        public static explicit operator checked byte (UInt128 value);
+        public static explicit operator checked char (UInt128 value);
+        public static explicit operator checked short (UInt128 value);
+        public static explicit operator checked int (UInt128 value);
+        public static explicit operator checked long (UInt128 value);
+        public static explicit operator checked Int128 (UInt128 value);
+        public static explicit operator checked IntPtr (UInt128 value);
+        public static explicit operator checked sbyte (UInt128 value);
+        public static explicit operator checked ushort (UInt128 value);
+        public static explicit operator checked uint (UInt128 value);
+        public static explicit operator checked ulong (UInt128 value);
+        public static explicit operator checked UIntPtr (UInt128 value);
+        public static UInt128 operator checked ++(UInt128 value);
+        public static UInt128 operator checked *(UInt128 left, UInt128 right);
+        public static UInt128 operator checked -(UInt128 left, UInt128 right);
+        public static UInt128 operator checked -(UInt128 value);
+        public static UInt128 operator --(UInt128 value);
+        public static UInt128 operator /(UInt128 left, UInt128 right);
+        public static bool operator ==(UInt128 left, UInt128 right);
+        public static UInt128 operator ^(UInt128 left, UInt128 right);
+        public static explicit operator UInt128 (decimal value);
+        public static explicit operator UInt128 (double value);
+        public static explicit operator UInt128 (short value);
+        public static explicit operator UInt128 (int value);
+        public static explicit operator UInt128 (long value);
+        public static explicit operator UInt128 (IntPtr value);
+        public static explicit operator UInt128 (sbyte value);
+        public static explicit operator UInt128 (float value);
+        public static explicit operator byte (UInt128 value);
+        public static explicit operator char (UInt128 value);
+        public static explicit operator decimal (UInt128 value);
+        public static explicit operator double (UInt128 value);
+        public static explicit operator Half (UInt128 value);
+        public static explicit operator Int128 (UInt128 value);
+        public static explicit operator short (UInt128 value);
+        public static explicit operator int (UInt128 value);
+        public static explicit operator long (UInt128 value);
+        public static explicit operator IntPtr (UInt128 value);
+        public static explicit operator sbyte (UInt128 value);
+        public static explicit operator float (UInt128 value);
+        public static explicit operator ushort (UInt128 value);
+        public static explicit operator uint (UInt128 value);
+        public static explicit operator ulong (UInt128 value);
+        public static explicit operator UIntPtr (UInt128 value);
+        public static bool operator &gt;(UInt128 left, UInt128 right);
+        public static bool operator &gt;=(UInt128 left, UInt128 right);
+        public static implicit operator UInt128 (byte value);
+        public static implicit operator UInt128 (char value);
+        public static implicit operator UInt128 (ushort value);
+        public static implicit operator UInt128 (uint value);
+        public static implicit operator UInt128 (ulong value);
+        public static implicit operator UInt128 (UIntPtr value);
+        public static UInt128 operator ++(UInt128 value);
+        public static bool operator !=(UInt128 left, UInt128 right);
+        public static UInt128 operator &lt;&lt;(UInt128 value, int shiftAmount);
+        public static bool operator &lt;(UInt128 left, UInt128 right);
+        public static bool operator &lt;=(UInt128 left, UInt128 right);
+        public static UInt128 operator %(UInt128 left, UInt128 right);
+        public static UInt128 operator *(UInt128 left, UInt128 right);
+        public static UInt128 operator ~(UInt128 value);
+        public static UInt128 operator &gt;&gt;(UInt128 value, int shiftAmount);
+        public static UInt128 operator -(UInt128 left, UInt128 right);
+        public static UInt128 operator -(UInt128 value);
+        public static UInt128 operator +(UInt128 value);
+        public static UInt128 operator &gt;&gt;&gt;(UInt128 value, int shiftAmount);
+        public static UInt128 Parse(ReadOnlySpan&lt;char&gt; s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null);
+        public static UInt128 Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static UInt128 Parse(string s);
+        public static UInt128 Parse(string s, NumberStyles style);
+        public static UInt128 Parse(string s, NumberStyles style, IFormatProvider? provider);
+        public static UInt128 Parse(string s, IFormatProvider? provider);
+        public static UInt128 PopCount(UInt128 value);
+        public static UInt128 RotateLeft(UInt128 value, int rotateAmount);
+        public static UInt128 RotateRight(UInt128 value, int rotateAmount);
+        public static int Sign(UInt128 value);
+        int IBinaryInteger&lt;UInt128&gt;.GetByteCount();
+        int IBinaryInteger&lt;UInt128&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;UInt128&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UInt128 value);
+        static bool IBinaryInteger&lt;UInt128&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UInt128 value);
+        bool IBinaryInteger&lt;UInt128&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;UInt128&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static UInt128 INumber&lt;UInt128&gt;.CopySign(UInt128 value, UInt128 sign);
+        static UInt128 INumber&lt;UInt128&gt;.MaxNumber(UInt128 x, UInt128 y);
+        static UInt128 INumber&lt;UInt128&gt;.MinNumber(UInt128 x, UInt128 y);
+        static UInt128 INumberBase&lt;UInt128&gt;.Abs(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsCanonical(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsComplexNumber(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsFinite(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsImaginaryNumber(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsInfinity(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsInteger(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsNaN(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsNegative(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsNegativeInfinity(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsNormal(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsPositive(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsPositiveInfinity(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsRealNumber(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsSubnormal(UInt128 value);
+        static bool INumberBase&lt;UInt128&gt;.IsZero(UInt128 value);
+        static UInt128 INumberBase&lt;UInt128&gt;.MaxMagnitude(UInt128 x, UInt128 y);
+        static UInt128 INumberBase&lt;UInt128&gt;.MaxMagnitudeNumber(UInt128 x, UInt128 y);
+        static UInt128 INumberBase&lt;UInt128&gt;.MinMagnitude(UInt128 x, UInt128 y);
+        static UInt128 INumberBase&lt;UInt128&gt;.MinMagnitudeNumber(UInt128 x, UInt128 y);
+        static bool INumberBase&lt;UInt128&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out UInt128 result);
+        static bool INumberBase&lt;UInt128&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out UInt128 result);
+        static bool INumberBase&lt;UInt128&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out UInt128 result);
+        static bool INumberBase&lt;UInt128&gt;.TryConvertToChecked&lt;TOther&gt;(UInt128 value, out TOther result);
+        static bool INumberBase&lt;UInt128&gt;.TryConvertToSaturating&lt;TOther&gt;(UInt128 value, out TOther result);
+        static bool INumberBase&lt;UInt128&gt;.TryConvertToTruncating&lt;TOther&gt;(UInt128 value, out TOther result);
+        public override string ToString();
+        public string ToString(IFormatProvider? provider);
+        public string ToString(string? format);
+        public string ToString(string? format, IFormatProvider? provider);
+        public static UInt128 TrailingZeroCount(UInt128 value);
+        public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, NumberStyles style, IFormatProvider? provider, out UInt128 result);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out UInt128 result);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, out UInt128 result);
+        public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out UInt128 result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out UInt128 result);
+        public static bool TryParse(string? s, out UInt128 result);
+    }
-    public readonly struct UInt16 : IComparable, IComparable&lt;ushort&gt;, IConvertible, IEquatable&lt;ushort&gt;, IFormattable, ISpanFormattable {
+    public readonly struct UInt16 : IAdditionOperators&lt;ushort, ushort, ushort&gt;, IAdditiveIdentity&lt;ushort, ushort&gt;, IBinaryInteger&lt;ushort&gt;, IBinaryNumber&lt;ushort&gt;, IBitwiseOperators&lt;ushort, ushort, ushort&gt;, IComparable, IComparable&lt;ushort&gt;, IComparisonOperators&lt;ushort, ushort, bool&gt;, IConvertible, IDecrementOperators&lt;ushort&gt;, IDivisionOperators&lt;ushort, ushort, ushort&gt;, IEqualityOperators&lt;ushort, ushort, bool&gt;, IEquatable&lt;ushort&gt;, IFormattable, IIncrementOperators&lt;ushort&gt;, IMinMaxValue&lt;ushort&gt;, IModulusOperators&lt;ushort, ushort, ushort&gt;, IMultiplicativeIdentity&lt;ushort, ushort&gt;, IMultiplyOperators&lt;ushort, ushort, ushort&gt;, INumber&lt;ushort&gt;, INumberBase&lt;ushort&gt;, IParsable&lt;ushort&gt;, IShiftOperators&lt;ushort, int, ushort&gt;, ISpanFormattable, ISpanParsable&lt;ushort&gt;, ISubtractionOperators&lt;ushort, ushort, ushort&gt;, IUnaryNegationOperators&lt;ushort, ushort&gt;, IUnaryPlusOperators&lt;ushort, ushort&gt;, IUnsignedNumber&lt;ushort&gt; {
+        static ushort System.Numerics.IAdditiveIdentity&lt;System.UInt16,System.UInt16&gt;.AdditiveIdentity { get; }
+        static ushort System.Numerics.IBinaryNumber&lt;System.UInt16&gt;.AllBitsSet { get; }
+        static ushort System.Numerics.IMinMaxValue&lt;System.UInt16&gt;.MaxValue { get; }
+        static ushort System.Numerics.IMinMaxValue&lt;System.UInt16&gt;.MinValue { get; }
+        static ushort System.Numerics.IMultiplicativeIdentity&lt;System.UInt16,System.UInt16&gt;.MultiplicativeIdentity { get; }
+        static ushort System.Numerics.INumberBase&lt;System.UInt16&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.UInt16&gt;.Radix { get; }
+        static ushort System.Numerics.INumberBase&lt;System.UInt16&gt;.Zero { get; }
+        public static ushort Clamp(ushort value, ushort min, ushort max);
+        public static ushort CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static ushort CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static ushort CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (ushort Quotient, ushort Remainder) DivRem(ushort left, ushort right);
+        public static bool IsEvenInteger(ushort value);
+        public static bool IsOddInteger(ushort value);
+        public static bool IsPow2(ushort value);
+        public static ushort LeadingZeroCount(ushort value);
+        public static ushort Log2(ushort value);
+        public static ushort Max(ushort x, ushort y);
+        public static ushort Min(ushort x, ushort y);
+        public static ushort Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static ushort PopCount(ushort value);
+        public static ushort RotateLeft(ushort value, int rotateAmount);
+        public static ushort RotateRight(ushort value, int rotateAmount);
+        public static int Sign(ushort value);
+        static ushort IAdditionOperators&lt;ushort, ushort, ushort&gt;.operator +(ushort left, ushort right);
+        static ushort IAdditionOperators&lt;ushort, ushort, ushort&gt;.operator checked +(ushort left, ushort right);
+        int IBinaryInteger&lt;ushort&gt;.GetByteCount();
+        int IBinaryInteger&lt;ushort&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;ushort&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out ushort value);
+        static bool IBinaryInteger&lt;ushort&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out ushort value);
+        bool IBinaryInteger&lt;ushort&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;ushort&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static ushort IBitwiseOperators&lt;ushort, ushort, ushort&gt;.operator &amp;(ushort left, ushort right);
+        static ushort IBitwiseOperators&lt;ushort, ushort, ushort&gt;.operator |(ushort left, ushort right);
+        static ushort IBitwiseOperators&lt;ushort, ushort, ushort&gt;.operator ^(ushort left, ushort right);
+        static ushort IBitwiseOperators&lt;ushort, ushort, ushort&gt;.operator ~(ushort value);
+        static bool IComparisonOperators&lt;ushort, ushort, bool&gt;.operator &gt;(ushort left, ushort right);
+        static bool IComparisonOperators&lt;ushort, ushort, bool&gt;.operator &gt;=(ushort left, ushort right);
+        static bool IComparisonOperators&lt;ushort, ushort, bool&gt;.operator &lt;(ushort left, ushort right);
+        static bool IComparisonOperators&lt;ushort, ushort, bool&gt;.operator &lt;=(ushort left, ushort right);
+        static ushort IDecrementOperators&lt;ushort&gt;.operator checked --(ushort value);
+        static ushort IDecrementOperators&lt;ushort&gt;.operator --(ushort value);
+        static ushort IDivisionOperators&lt;ushort, ushort, ushort&gt;.operator /(ushort left, ushort right);
+        static bool IEqualityOperators&lt;ushort, ushort, bool&gt;.operator ==(ushort left, ushort right);
+        static bool IEqualityOperators&lt;ushort, ushort, bool&gt;.operator !=(ushort left, ushort right);
+        static ushort IIncrementOperators&lt;ushort&gt;.operator checked ++(ushort value);
+        static ushort IIncrementOperators&lt;ushort&gt;.operator ++(ushort value);
+        static ushort IModulusOperators&lt;ushort, ushort, ushort&gt;.operator %(ushort left, ushort right);
+        static ushort IMultiplyOperators&lt;ushort, ushort, ushort&gt;.operator checked *(ushort left, ushort right);
+        static ushort IMultiplyOperators&lt;ushort, ushort, ushort&gt;.operator *(ushort left, ushort right);
+        static ushort INumber&lt;ushort&gt;.CopySign(ushort value, ushort sign);
+        static ushort INumber&lt;ushort&gt;.MaxNumber(ushort x, ushort y);
+        static ushort INumber&lt;ushort&gt;.MinNumber(ushort x, ushort y);
+        static ushort INumberBase&lt;ushort&gt;.Abs(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsCanonical(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsComplexNumber(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsFinite(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsImaginaryNumber(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsInfinity(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsInteger(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsNaN(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsNegative(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsNegativeInfinity(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsNormal(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsPositive(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsPositiveInfinity(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsRealNumber(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsSubnormal(ushort value);
+        static bool INumberBase&lt;ushort&gt;.IsZero(ushort value);
+        static ushort INumberBase&lt;ushort&gt;.MaxMagnitude(ushort x, ushort y);
+        static ushort INumberBase&lt;ushort&gt;.MaxMagnitudeNumber(ushort x, ushort y);
+        static ushort INumberBase&lt;ushort&gt;.MinMagnitude(ushort x, ushort y);
+        static ushort INumberBase&lt;ushort&gt;.MinMagnitudeNumber(ushort x, ushort y);
+        static bool INumberBase&lt;ushort&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out ushort result);
+        static bool INumberBase&lt;ushort&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out ushort result);
+        static bool INumberBase&lt;ushort&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out ushort result);
+        static bool INumberBase&lt;ushort&gt;.TryConvertToChecked&lt;TOther&gt;(ushort value, out TOther result);
+        static bool INumberBase&lt;ushort&gt;.TryConvertToSaturating&lt;TOther&gt;(ushort value, out TOther result);
+        static bool INumberBase&lt;ushort&gt;.TryConvertToTruncating&lt;TOther&gt;(ushort value, out TOther result);
+        static ushort IShiftOperators&lt;ushort, int, ushort&gt;.operator &lt;&lt;(ushort value, int shiftAmount);
+        static ushort IShiftOperators&lt;ushort, int, ushort&gt;.operator &gt;&gt;(ushort value, int shiftAmount);
+        static ushort IShiftOperators&lt;ushort, int, ushort&gt;.operator &gt;&gt;&gt;(ushort value, int shiftAmount);
+        static ushort ISubtractionOperators&lt;ushort, ushort, ushort&gt;.operator checked -(ushort left, ushort right);
+        static ushort ISubtractionOperators&lt;ushort, ushort, ushort&gt;.operator -(ushort left, ushort right);
+        static ushort IUnaryNegationOperators&lt;ushort, ushort&gt;.operator checked -(ushort value);
+        static ushort IUnaryNegationOperators&lt;ushort, ushort&gt;.operator -(ushort value);
+        static ushort IUnaryPlusOperators&lt;ushort, ushort&gt;.operator +(ushort value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static ushort TrailingZeroCount(ushort value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out ushort result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out ushort result);
     }
-    public readonly struct UInt32 : IComparable, IComparable&lt;uint&gt;, IConvertible, IEquatable&lt;uint&gt;, IFormattable, ISpanFormattable {
+    public readonly struct UInt32 : IAdditionOperators&lt;uint, uint, uint&gt;, IAdditiveIdentity&lt;uint, uint&gt;, IBinaryInteger&lt;uint&gt;, IBinaryNumber&lt;uint&gt;, IBitwiseOperators&lt;uint, uint, uint&gt;, IComparable, IComparable&lt;uint&gt;, IComparisonOperators&lt;uint, uint, bool&gt;, IConvertible, IDecrementOperators&lt;uint&gt;, IDivisionOperators&lt;uint, uint, uint&gt;, IEqualityOperators&lt;uint, uint, bool&gt;, IEquatable&lt;uint&gt;, IFormattable, IIncrementOperators&lt;uint&gt;, IMinMaxValue&lt;uint&gt;, IModulusOperators&lt;uint, uint, uint&gt;, IMultiplicativeIdentity&lt;uint, uint&gt;, IMultiplyOperators&lt;uint, uint, uint&gt;, INumber&lt;uint&gt;, INumberBase&lt;uint&gt;, IParsable&lt;uint&gt;, IShiftOperators&lt;uint, int, uint&gt;, ISpanFormattable, ISpanParsable&lt;uint&gt;, ISubtractionOperators&lt;uint, uint, uint&gt;, IUnaryNegationOperators&lt;uint, uint&gt;, IUnaryPlusOperators&lt;uint, uint&gt;, IUnsignedNumber&lt;uint&gt; {
+        static uint System.Numerics.IAdditiveIdentity&lt;System.UInt32,System.UInt32&gt;.AdditiveIdentity { get; }
+        static uint System.Numerics.IBinaryNumber&lt;System.UInt32&gt;.AllBitsSet { get; }
+        static uint System.Numerics.IMinMaxValue&lt;System.UInt32&gt;.MaxValue { get; }
+        static uint System.Numerics.IMinMaxValue&lt;System.UInt32&gt;.MinValue { get; }
+        static uint System.Numerics.IMultiplicativeIdentity&lt;System.UInt32,System.UInt32&gt;.MultiplicativeIdentity { get; }
+        static uint System.Numerics.INumberBase&lt;System.UInt32&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.UInt32&gt;.Radix { get; }
+        static uint System.Numerics.INumberBase&lt;System.UInt32&gt;.Zero { get; }
+        public static uint Clamp(uint value, uint min, uint max);
+        public static uint CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static uint CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static uint CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (uint Quotient, uint Remainder) DivRem(uint left, uint right);
+        public static bool IsEvenInteger(uint value);
+        public static bool IsOddInteger(uint value);
+        public static bool IsPow2(uint value);
+        public static uint LeadingZeroCount(uint value);
+        public static uint Log2(uint value);
+        public static uint Max(uint x, uint y);
+        public static uint Min(uint x, uint y);
+        public static uint Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static uint PopCount(uint value);
+        public static uint RotateLeft(uint value, int rotateAmount);
+        public static uint RotateRight(uint value, int rotateAmount);
+        public static int Sign(uint value);
+        static uint IAdditionOperators&lt;uint, uint, uint&gt;.operator +(uint left, uint right);
+        static uint IAdditionOperators&lt;uint, uint, uint&gt;.operator checked +(uint left, uint right);
+        int IBinaryInteger&lt;uint&gt;.GetByteCount();
+        int IBinaryInteger&lt;uint&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;uint&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out uint value);
+        static bool IBinaryInteger&lt;uint&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out uint value);
+        bool IBinaryInteger&lt;uint&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;uint&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static uint IBitwiseOperators&lt;uint, uint, uint&gt;.operator &amp;(uint left, uint right);
+        static uint IBitwiseOperators&lt;uint, uint, uint&gt;.operator |(uint left, uint right);
+        static uint IBitwiseOperators&lt;uint, uint, uint&gt;.operator ^(uint left, uint right);
+        static uint IBitwiseOperators&lt;uint, uint, uint&gt;.operator ~(uint value);
+        static bool IComparisonOperators&lt;uint, uint, bool&gt;.operator &gt;(uint left, uint right);
+        static bool IComparisonOperators&lt;uint, uint, bool&gt;.operator &gt;=(uint left, uint right);
+        static bool IComparisonOperators&lt;uint, uint, bool&gt;.operator &lt;(uint left, uint right);
+        static bool IComparisonOperators&lt;uint, uint, bool&gt;.operator &lt;=(uint left, uint right);
+        static uint IDecrementOperators&lt;uint&gt;.operator checked --(uint value);
+        static uint IDecrementOperators&lt;uint&gt;.operator --(uint value);
+        static uint IDivisionOperators&lt;uint, uint, uint&gt;.operator /(uint left, uint right);
+        static bool IEqualityOperators&lt;uint, uint, bool&gt;.operator ==(uint left, uint right);
+        static bool IEqualityOperators&lt;uint, uint, bool&gt;.operator !=(uint left, uint right);
+        static uint IIncrementOperators&lt;uint&gt;.operator checked ++(uint value);
+        static uint IIncrementOperators&lt;uint&gt;.operator ++(uint value);
+        static uint IModulusOperators&lt;uint, uint, uint&gt;.operator %(uint left, uint right);
+        static uint IMultiplyOperators&lt;uint, uint, uint&gt;.operator checked *(uint left, uint right);
+        static uint IMultiplyOperators&lt;uint, uint, uint&gt;.operator *(uint left, uint right);
+        static uint INumber&lt;uint&gt;.CopySign(uint value, uint sign);
+        static uint INumber&lt;uint&gt;.MaxNumber(uint x, uint y);
+        static uint INumber&lt;uint&gt;.MinNumber(uint x, uint y);
+        static uint INumberBase&lt;uint&gt;.Abs(uint value);
+        static bool INumberBase&lt;uint&gt;.IsCanonical(uint value);
+        static bool INumberBase&lt;uint&gt;.IsComplexNumber(uint value);
+        static bool INumberBase&lt;uint&gt;.IsFinite(uint value);
+        static bool INumberBase&lt;uint&gt;.IsImaginaryNumber(uint value);
+        static bool INumberBase&lt;uint&gt;.IsInfinity(uint value);
+        static bool INumberBase&lt;uint&gt;.IsInteger(uint value);
+        static bool INumberBase&lt;uint&gt;.IsNaN(uint value);
+        static bool INumberBase&lt;uint&gt;.IsNegative(uint value);
+        static bool INumberBase&lt;uint&gt;.IsNegativeInfinity(uint value);
+        static bool INumberBase&lt;uint&gt;.IsNormal(uint value);
+        static bool INumberBase&lt;uint&gt;.IsPositive(uint value);
+        static bool INumberBase&lt;uint&gt;.IsPositiveInfinity(uint value);
+        static bool INumberBase&lt;uint&gt;.IsRealNumber(uint value);
+        static bool INumberBase&lt;uint&gt;.IsSubnormal(uint value);
+        static bool INumberBase&lt;uint&gt;.IsZero(uint value);
+        static uint INumberBase&lt;uint&gt;.MaxMagnitude(uint x, uint y);
+        static uint INumberBase&lt;uint&gt;.MaxMagnitudeNumber(uint x, uint y);
+        static uint INumberBase&lt;uint&gt;.MinMagnitude(uint x, uint y);
+        static uint INumberBase&lt;uint&gt;.MinMagnitudeNumber(uint x, uint y);
+        static bool INumberBase&lt;uint&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out uint result);
+        static bool INumberBase&lt;uint&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out uint result);
+        static bool INumberBase&lt;uint&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out uint result);
+        static bool INumberBase&lt;uint&gt;.TryConvertToChecked&lt;TOther&gt;(uint value, out TOther result);
+        static bool INumberBase&lt;uint&gt;.TryConvertToSaturating&lt;TOther&gt;(uint value, out TOther result);
+        static bool INumberBase&lt;uint&gt;.TryConvertToTruncating&lt;TOther&gt;(uint value, out TOther result);
+        static uint IShiftOperators&lt;uint, int, uint&gt;.operator &lt;&lt;(uint value, int shiftAmount);
+        static uint IShiftOperators&lt;uint, int, uint&gt;.operator &gt;&gt;(uint value, int shiftAmount);
+        static uint IShiftOperators&lt;uint, int, uint&gt;.operator &gt;&gt;&gt;(uint value, int shiftAmount);
+        static uint ISubtractionOperators&lt;uint, uint, uint&gt;.operator checked -(uint left, uint right);
+        static uint ISubtractionOperators&lt;uint, uint, uint&gt;.operator -(uint left, uint right);
+        static uint IUnaryNegationOperators&lt;uint, uint&gt;.operator checked -(uint value);
+        static uint IUnaryNegationOperators&lt;uint, uint&gt;.operator -(uint value);
+        static uint IUnaryPlusOperators&lt;uint, uint&gt;.operator +(uint value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static uint TrailingZeroCount(uint value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out uint result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out uint result);
     }
-    public readonly struct UInt64 : IComparable, IComparable&lt;ulong&gt;, IConvertible, IEquatable&lt;ulong&gt;, IFormattable, ISpanFormattable {
+    public readonly struct UInt64 : IAdditionOperators&lt;ulong, ulong, ulong&gt;, IAdditiveIdentity&lt;ulong, ulong&gt;, IBinaryInteger&lt;ulong&gt;, IBinaryNumber&lt;ulong&gt;, IBitwiseOperators&lt;ulong, ulong, ulong&gt;, IComparable, IComparable&lt;ulong&gt;, IComparisonOperators&lt;ulong, ulong, bool&gt;, IConvertible, IDecrementOperators&lt;ulong&gt;, IDivisionOperators&lt;ulong, ulong, ulong&gt;, IEqualityOperators&lt;ulong, ulong, bool&gt;, IEquatable&lt;ulong&gt;, IFormattable, IIncrementOperators&lt;ulong&gt;, IMinMaxValue&lt;ulong&gt;, IModulusOperators&lt;ulong, ulong, ulong&gt;, IMultiplicativeIdentity&lt;ulong, ulong&gt;, IMultiplyOperators&lt;ulong, ulong, ulong&gt;, INumber&lt;ulong&gt;, INumberBase&lt;ulong&gt;, IParsable&lt;ulong&gt;, IShiftOperators&lt;ulong, int, ulong&gt;, ISpanFormattable, ISpanParsable&lt;ulong&gt;, ISubtractionOperators&lt;ulong, ulong, ulong&gt;, IUnaryNegationOperators&lt;ulong, ulong&gt;, IUnaryPlusOperators&lt;ulong, ulong&gt;, IUnsignedNumber&lt;ulong&gt; {
+        static ulong System.Numerics.IAdditiveIdentity&lt;System.UInt64,System.UInt64&gt;.AdditiveIdentity { get; }
+        static ulong System.Numerics.IBinaryNumber&lt;System.UInt64&gt;.AllBitsSet { get; }
+        static ulong System.Numerics.IMinMaxValue&lt;System.UInt64&gt;.MaxValue { get; }
+        static ulong System.Numerics.IMinMaxValue&lt;System.UInt64&gt;.MinValue { get; }
+        static ulong System.Numerics.IMultiplicativeIdentity&lt;System.UInt64,System.UInt64&gt;.MultiplicativeIdentity { get; }
+        static ulong System.Numerics.INumberBase&lt;System.UInt64&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;System.UInt64&gt;.Radix { get; }
+        static ulong System.Numerics.INumberBase&lt;System.UInt64&gt;.Zero { get; }
+        public static ulong Clamp(ulong value, ulong min, ulong max);
+        public static ulong CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static ulong CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static ulong CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (ulong Quotient, ulong Remainder) DivRem(ulong left, ulong right);
+        public static bool IsEvenInteger(ulong value);
+        public static bool IsOddInteger(ulong value);
+        public static bool IsPow2(ulong value);
+        public static ulong LeadingZeroCount(ulong value);
+        public static ulong Log2(ulong value);
+        public static ulong Max(ulong x, ulong y);
+        public static ulong Min(ulong x, ulong y);
+        public static ulong Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static ulong PopCount(ulong value);
+        public static ulong RotateLeft(ulong value, int rotateAmount);
+        public static ulong RotateRight(ulong value, int rotateAmount);
+        public static int Sign(ulong value);
+        static ulong IAdditionOperators&lt;ulong, ulong, ulong&gt;.operator +(ulong left, ulong right);
+        static ulong IAdditionOperators&lt;ulong, ulong, ulong&gt;.operator checked +(ulong left, ulong right);
+        int IBinaryInteger&lt;ulong&gt;.GetByteCount();
+        int IBinaryInteger&lt;ulong&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;ulong&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out ulong value);
+        static bool IBinaryInteger&lt;ulong&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out ulong value);
+        bool IBinaryInteger&lt;ulong&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;ulong&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static ulong IBitwiseOperators&lt;ulong, ulong, ulong&gt;.operator &amp;(ulong left, ulong right);
+        static ulong IBitwiseOperators&lt;ulong, ulong, ulong&gt;.operator |(ulong left, ulong right);
+        static ulong IBitwiseOperators&lt;ulong, ulong, ulong&gt;.operator ^(ulong left, ulong right);
+        static ulong IBitwiseOperators&lt;ulong, ulong, ulong&gt;.operator ~(ulong value);
+        static bool IComparisonOperators&lt;ulong, ulong, bool&gt;.operator &gt;(ulong left, ulong right);
+        static bool IComparisonOperators&lt;ulong, ulong, bool&gt;.operator &gt;=(ulong left, ulong right);
+        static bool IComparisonOperators&lt;ulong, ulong, bool&gt;.operator &lt;(ulong left, ulong right);
+        static bool IComparisonOperators&lt;ulong, ulong, bool&gt;.operator &lt;=(ulong left, ulong right);
+        static ulong IDecrementOperators&lt;ulong&gt;.operator checked --(ulong value);
+        static ulong IDecrementOperators&lt;ulong&gt;.operator --(ulong value);
+        static ulong IDivisionOperators&lt;ulong, ulong, ulong&gt;.operator /(ulong left, ulong right);
+        static bool IEqualityOperators&lt;ulong, ulong, bool&gt;.operator ==(ulong left, ulong right);
+        static bool IEqualityOperators&lt;ulong, ulong, bool&gt;.operator !=(ulong left, ulong right);
+        static ulong IIncrementOperators&lt;ulong&gt;.operator checked ++(ulong value);
+        static ulong IIncrementOperators&lt;ulong&gt;.operator ++(ulong value);
+        static ulong IModulusOperators&lt;ulong, ulong, ulong&gt;.operator %(ulong left, ulong right);
+        static ulong IMultiplyOperators&lt;ulong, ulong, ulong&gt;.operator checked *(ulong left, ulong right);
+        static ulong IMultiplyOperators&lt;ulong, ulong, ulong&gt;.operator *(ulong left, ulong right);
+        static ulong INumber&lt;ulong&gt;.CopySign(ulong value, ulong sign);
+        static ulong INumber&lt;ulong&gt;.MaxNumber(ulong x, ulong y);
+        static ulong INumber&lt;ulong&gt;.MinNumber(ulong x, ulong y);
+        static ulong INumberBase&lt;ulong&gt;.Abs(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsCanonical(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsComplexNumber(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsFinite(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsImaginaryNumber(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsInfinity(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsInteger(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsNaN(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsNegative(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsNegativeInfinity(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsNormal(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsPositive(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsPositiveInfinity(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsRealNumber(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsSubnormal(ulong value);
+        static bool INumberBase&lt;ulong&gt;.IsZero(ulong value);
+        static ulong INumberBase&lt;ulong&gt;.MaxMagnitude(ulong x, ulong y);
+        static ulong INumberBase&lt;ulong&gt;.MaxMagnitudeNumber(ulong x, ulong y);
+        static ulong INumberBase&lt;ulong&gt;.MinMagnitude(ulong x, ulong y);
+        static ulong INumberBase&lt;ulong&gt;.MinMagnitudeNumber(ulong x, ulong y);
+        static bool INumberBase&lt;ulong&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out ulong result);
+        static bool INumberBase&lt;ulong&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out ulong result);
+        static bool INumberBase&lt;ulong&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out ulong result);
+        static bool INumberBase&lt;ulong&gt;.TryConvertToChecked&lt;TOther&gt;(ulong value, out TOther result);
+        static bool INumberBase&lt;ulong&gt;.TryConvertToSaturating&lt;TOther&gt;(ulong value, out TOther result);
+        static bool INumberBase&lt;ulong&gt;.TryConvertToTruncating&lt;TOther&gt;(ulong value, out TOther result);
+        static ulong IShiftOperators&lt;ulong, int, ulong&gt;.operator &lt;&lt;(ulong value, int shiftAmount);
+        static ulong IShiftOperators&lt;ulong, int, ulong&gt;.operator &gt;&gt;(ulong value, int shiftAmount);
+        static ulong IShiftOperators&lt;ulong, int, ulong&gt;.operator &gt;&gt;&gt;(ulong value, int shiftAmount);
+        static ulong ISubtractionOperators&lt;ulong, ulong, ulong&gt;.operator checked -(ulong left, ulong right);
+        static ulong ISubtractionOperators&lt;ulong, ulong, ulong&gt;.operator -(ulong left, ulong right);
+        static ulong IUnaryNegationOperators&lt;ulong, ulong&gt;.operator checked -(ulong value);
+        static ulong IUnaryNegationOperators&lt;ulong, ulong&gt;.operator -(ulong value);
+        static ulong IUnaryPlusOperators&lt;ulong, ulong&gt;.operator +(ulong value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static ulong TrailingZeroCount(ulong value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out ulong result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out ulong result);
     }
-    public readonly struct UIntPtr : IComparable, IComparable&lt;UIntPtr&gt;, IEquatable&lt;UIntPtr&gt;, IFormattable, ISerializable, ISpanFormattable {
+    public readonly struct UIntPtr : IAdditionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, IAdditiveIdentity&lt;UIntPtr, UIntPtr&gt;, IBinaryInteger&lt;UIntPtr&gt;, IBinaryNumber&lt;UIntPtr&gt;, IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, IComparable, IComparable&lt;UIntPtr&gt;, IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;, IDecrementOperators&lt;UIntPtr&gt;, IDivisionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, IEqualityOperators&lt;UIntPtr, UIntPtr, bool&gt;, IEquatable&lt;UIntPtr&gt;, IFormattable, IIncrementOperators&lt;UIntPtr&gt;, IMinMaxValue&lt;UIntPtr&gt;, IModulusOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, IMultiplicativeIdentity&lt;UIntPtr, UIntPtr&gt;, IMultiplyOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, INumber&lt;UIntPtr&gt;, INumberBase&lt;UIntPtr&gt;, IParsable&lt;UIntPtr&gt;, ISerializable, IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;, ISpanFormattable, ISpanParsable&lt;UIntPtr&gt;, ISubtractionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;, IUnaryNegationOperators&lt;UIntPtr, UIntPtr&gt;, IUnaryPlusOperators&lt;UIntPtr, UIntPtr&gt;, IUnsignedNumber&lt;UIntPtr&gt; {
+        static UIntPtr System.Numerics.IAdditiveIdentity&lt;nuint,nuint&gt;.AdditiveIdentity { get; }
+        static UIntPtr System.Numerics.IBinaryNumber&lt;nuint&gt;.AllBitsSet { get; }
+        static UIntPtr System.Numerics.IMinMaxValue&lt;nuint&gt;.MaxValue { get; }
+        static UIntPtr System.Numerics.IMinMaxValue&lt;nuint&gt;.MinValue { get; }
+        static UIntPtr System.Numerics.IMultiplicativeIdentity&lt;nuint,nuint&gt;.MultiplicativeIdentity { get; }
+        static UIntPtr System.Numerics.INumberBase&lt;nuint&gt;.One { get; }
+        static int System.Numerics.INumberBase&lt;nuint&gt;.Radix { get; }
+        static UIntPtr System.Numerics.INumberBase&lt;nuint&gt;.Zero { get; }
+        public static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max);
+        public static UIntPtr CreateChecked&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static UIntPtr CreateSaturating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static UIntPtr CreateTruncating&lt;TOther&gt;(TOther value) where TOther : INumberBase&lt;TOther&gt;;
+        public static (UIntPtr Quotient, UIntPtr Remainder) DivRem(UIntPtr left, UIntPtr right);
+        public static bool IsEvenInteger(UIntPtr value);
+        public static bool IsOddInteger(UIntPtr value);
+        public static bool IsPow2(UIntPtr value);
+        public static UIntPtr LeadingZeroCount(UIntPtr value);
+        public static UIntPtr Log2(UIntPtr value);
+        public static UIntPtr Max(UIntPtr x, UIntPtr y);
+        public static UIntPtr Min(UIntPtr x, UIntPtr y);
+        public static UIntPtr Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);
+        public static UIntPtr PopCount(UIntPtr value);
+        public static UIntPtr RotateLeft(UIntPtr value, int rotateAmount);
+        public static UIntPtr RotateRight(UIntPtr value, int rotateAmount);
+        public static int Sign(UIntPtr value);
+        static UIntPtr IAdditionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator +(UIntPtr left, UIntPtr right);
+        static UIntPtr IAdditionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator checked +(UIntPtr left, UIntPtr right);
+        int IBinaryInteger&lt;UIntPtr&gt;.GetByteCount();
+        int IBinaryInteger&lt;UIntPtr&gt;.GetShortestBitLength();
+        static bool IBinaryInteger&lt;UIntPtr&gt;.TryReadBigEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UIntPtr value);
+        static bool IBinaryInteger&lt;UIntPtr&gt;.TryReadLittleEndian(ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out UIntPtr value);
+        bool IBinaryInteger&lt;UIntPtr&gt;.TryWriteBigEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        bool IBinaryInteger&lt;UIntPtr&gt;.TryWriteLittleEndian(Span&lt;byte&gt; destination, out int bytesWritten);
+        static UIntPtr IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator &amp;(UIntPtr left, UIntPtr right);
+        static UIntPtr IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator |(UIntPtr left, UIntPtr right);
+        static UIntPtr IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator ^(UIntPtr left, UIntPtr right);
+        static UIntPtr IBitwiseOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator ~(UIntPtr value);
+        static bool IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;.operator &gt;(UIntPtr left, UIntPtr right);
+        static bool IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;.operator &gt;=(UIntPtr left, UIntPtr right);
+        static bool IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;.operator &lt;(UIntPtr left, UIntPtr right);
+        static bool IComparisonOperators&lt;UIntPtr, UIntPtr, bool&gt;.operator &lt;=(UIntPtr left, UIntPtr right);
+        static UIntPtr IDecrementOperators&lt;UIntPtr&gt;.operator checked --(UIntPtr value);
+        static UIntPtr IDecrementOperators&lt;UIntPtr&gt;.operator --(UIntPtr value);
+        static UIntPtr IDivisionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator /(UIntPtr left, UIntPtr right);
+        static UIntPtr IIncrementOperators&lt;UIntPtr&gt;.operator checked ++(UIntPtr value);
+        static UIntPtr IIncrementOperators&lt;UIntPtr&gt;.operator ++(UIntPtr value);
+        static UIntPtr IModulusOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator %(UIntPtr left, UIntPtr right);
+        static UIntPtr IMultiplyOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator checked *(UIntPtr left, UIntPtr right);
+        static UIntPtr IMultiplyOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator *(UIntPtr left, UIntPtr right);
+        static UIntPtr INumber&lt;UIntPtr&gt;.CopySign(UIntPtr value, UIntPtr sign);
+        static UIntPtr INumber&lt;UIntPtr&gt;.MaxNumber(UIntPtr x, UIntPtr y);
+        static UIntPtr INumber&lt;UIntPtr&gt;.MinNumber(UIntPtr x, UIntPtr y);
+        static UIntPtr INumberBase&lt;UIntPtr&gt;.Abs(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsCanonical(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsComplexNumber(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsFinite(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsImaginaryNumber(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsInfinity(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsInteger(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsNaN(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsNegative(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsNegativeInfinity(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsNormal(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsPositive(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsPositiveInfinity(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsRealNumber(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsSubnormal(UIntPtr value);
+        static bool INumberBase&lt;UIntPtr&gt;.IsZero(UIntPtr value);
+        static UIntPtr INumberBase&lt;UIntPtr&gt;.MaxMagnitude(UIntPtr x, UIntPtr y);
+        static UIntPtr INumberBase&lt;UIntPtr&gt;.MaxMagnitudeNumber(UIntPtr x, UIntPtr y);
+        static UIntPtr INumberBase&lt;UIntPtr&gt;.MinMagnitude(UIntPtr x, UIntPtr y);
+        static UIntPtr INumberBase&lt;UIntPtr&gt;.MinMagnitudeNumber(UIntPtr x, UIntPtr y);
+        static bool INumberBase&lt;UIntPtr&gt;.TryConvertFromChecked&lt;TOther&gt;(TOther value, out UIntPtr result);
+        static bool INumberBase&lt;UIntPtr&gt;.TryConvertFromSaturating&lt;TOther&gt;(TOther value, out UIntPtr result);
+        static bool INumberBase&lt;UIntPtr&gt;.TryConvertFromTruncating&lt;TOther&gt;(TOther value, out UIntPtr result);
+        static bool INumberBase&lt;UIntPtr&gt;.TryConvertToChecked&lt;TOther&gt;(UIntPtr value, out TOther result);
+        static bool INumberBase&lt;UIntPtr&gt;.TryConvertToSaturating&lt;TOther&gt;(UIntPtr value, out TOther result);
+        static bool INumberBase&lt;UIntPtr&gt;.TryConvertToTruncating&lt;TOther&gt;(UIntPtr value, out TOther result);
+        static UIntPtr IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;.operator &lt;&lt;(UIntPtr value, int shiftAmount);
+        static UIntPtr IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;.operator &gt;&gt;(UIntPtr value, int shiftAmount);
+        static UIntPtr IShiftOperators&lt;UIntPtr, int, UIntPtr&gt;.operator &gt;&gt;&gt;(UIntPtr value, int shiftAmount);
+        static UIntPtr ISubtractionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator checked -(UIntPtr left, UIntPtr right);
+        static UIntPtr ISubtractionOperators&lt;UIntPtr, UIntPtr, UIntPtr&gt;.operator -(UIntPtr left, UIntPtr right);
+        static UIntPtr IUnaryNegationOperators&lt;UIntPtr, UIntPtr&gt;.operator checked -(UIntPtr value);
+        static UIntPtr IUnaryNegationOperators&lt;UIntPtr, UIntPtr&gt;.operator -(UIntPtr value);
+        static UIntPtr IUnaryPlusOperators&lt;UIntPtr, UIntPtr&gt;.operator +(UIntPtr value);
         public string ToString(string? format);
         public string ToString(string? format, IFormatProvider? provider);
+        public static UIntPtr TrailingZeroCount(UIntPtr value);
         public bool TryFormat(Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default(ReadOnlySpan&lt;char&gt;), IFormatProvider? provider = null);
+        public static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out UIntPtr result);
+        public static bool TryParse(string? s, IFormatProvider? provider, out UIntPtr result);
     }
     public class Uri : ISerializable {
         public Uri(string uriString);
         public Uri(string uriString, bool dontEscape);
         public Uri(string uriString, in UriCreationOptions creationOptions);
         public Uri(string uriString, UriKind uriKind);
         protected static string EscapeString(string? str);
         public static string EscapeUriString(string stringToEscape);
         public static bool IsWellFormedUriString(string? uriString, UriKind uriKind);
         public string MakeRelative(Uri toUri);
         public static bool TryCreate(string? uriString, in UriCreationOptions creationOptions, out Uri? result);
         public static bool TryCreate(string? uriString, UriKind uriKind, out Uri? result);
     }
     public class UriBuilder {
         public UriBuilder(string uri);
     }
     public struct UriCreationOptions
     public class UriTypeConverter : TypeConverter {
         public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
     }
 }
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
