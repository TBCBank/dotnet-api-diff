{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".NET 7.0 API Changes The following API changes were made in .NET 7.0 : Microsoft.NETCore.App Microsoft.AspNetCore.App Microsoft.WindowsDesktop.App","title":".NET 7.0   API Changes"},{"location":"#net-70-api-changes","text":"The following API changes were made in .NET 7.0 : Microsoft.NETCore.App Microsoft.AspNetCore.App Microsoft.WindowsDesktop.App","title":".NET 7.0   API Changes"},{"location":"Microsoft.AspNetCore.App/7.0/","text":"API Difference 6.0 vs 7.0 API listing follows standard diff formatting. Lines preceded by a '+' are additions and a '-' indicates removal. Microsoft.AspNetCore.Authentication Microsoft.AspNetCore.Authentication.Cookies Microsoft.AspNetCore.Authorization Microsoft.AspNetCore.Authorization.Infrastructure Microsoft.AspNetCore.Authorization.Policy Microsoft.AspNetCore.Builder Microsoft.AspNetCore.Components Microsoft.AspNetCore.Components.CompilerServices Microsoft.AspNetCore.Components.Forms Microsoft.AspNetCore.Components.Rendering Microsoft.AspNetCore.Components.RenderTree Microsoft.AspNetCore.Components.Routing Microsoft.AspNetCore.Components.Web Microsoft.AspNetCore.Components.Web.Virtualization Microsoft.AspNetCore.Connections Microsoft.AspNetCore.Connections.Features Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel Microsoft.AspNetCore.DataProtection.Internal Microsoft.AspNetCore.Diagnostics Microsoft.AspNetCore.Hosting Microsoft.AspNetCore.Http Microsoft.AspNetCore.Http.Features Microsoft.AspNetCore.Http.HttpResults Microsoft.AspNetCore.Http.Metadata Microsoft.AspNetCore.HttpLogging Microsoft.AspNetCore.Identity Microsoft.AspNetCore.Mvc Microsoft.AspNetCore.Mvc.ApplicationModels Microsoft.AspNetCore.Mvc.Infrastructure Microsoft.AspNetCore.Mvc.ModelBinding Microsoft.AspNetCore.Mvc.ModelBinding.Binders Microsoft.AspNetCore.Mvc.ModelBinding.Metadata Microsoft.AspNetCore.Mvc.RazorPages Microsoft.AspNetCore.Mvc.Rendering Microsoft.AspNetCore.Mvc.Routing Microsoft.AspNetCore.Mvc.ViewFeatures Microsoft.AspNetCore.OutputCaching Microsoft.AspNetCore.RateLimiting Microsoft.AspNetCore.RequestDecompression Microsoft.AspNetCore.ResponseCompression Microsoft.AspNetCore.Routing Microsoft.AspNetCore.Routing.Patterns Microsoft.AspNetCore.Server.IIS.Core Microsoft.AspNetCore.Server.Kestrel.Core Microsoft.AspNetCore.Server.Kestrel.Https Microsoft.AspNetCore.Server.Kestrel.Transport.Quic Microsoft.AspNetCore.SignalR Microsoft.AspNetCore.SignalR.Protocol Microsoft.AspNetCore.WebUtilities Microsoft.Extensions.Caching.Distributed Microsoft.Extensions.Caching.Memory Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.CommandLine Microsoft.Extensions.Configuration.EnvironmentVariables Microsoft.Extensions.Configuration.Ini Microsoft.Extensions.Configuration.Memory Microsoft.Extensions.Configuration.Xml Microsoft.Extensions.DependencyInjection Microsoft.Extensions.DependencyInjection.Extensions Microsoft.Extensions.FileProviders Microsoft.Extensions.FileProviders.Physical Microsoft.Extensions.FileSystemGlobbing Microsoft.Extensions.FileSystemGlobbing.Abstractions Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts Microsoft.Extensions.Hosting Microsoft.Extensions.Hosting.Internal Microsoft.Extensions.Http Microsoft.Extensions.Logging Microsoft.Extensions.Logging.Abstractions Microsoft.Extensions.Logging.Configuration Microsoft.Extensions.Logging.Console Microsoft.Extensions.Logging.EventLog Microsoft.Extensions.Logging.TraceSource Microsoft.Extensions.ObjectPool Microsoft.Extensions.Options Microsoft.Extensions.Primitives Microsoft.JSInterop Microsoft.JSInterop.Infrastructure Microsoft.Net.Http.Headers System.Diagnostics.Eventing.Reader System.Security.Claims System.Threading.RateLimiting","title":"API Difference 6.0 vs 7.0"},{"location":"Microsoft.AspNetCore.App/7.0/#api-difference-60-vs-70","text":"API listing follows standard diff formatting. Lines preceded by a '+' are additions and a '-' indicates removal. Microsoft.AspNetCore.Authentication Microsoft.AspNetCore.Authentication.Cookies Microsoft.AspNetCore.Authorization Microsoft.AspNetCore.Authorization.Infrastructure Microsoft.AspNetCore.Authorization.Policy Microsoft.AspNetCore.Builder Microsoft.AspNetCore.Components Microsoft.AspNetCore.Components.CompilerServices Microsoft.AspNetCore.Components.Forms Microsoft.AspNetCore.Components.Rendering Microsoft.AspNetCore.Components.RenderTree Microsoft.AspNetCore.Components.Routing Microsoft.AspNetCore.Components.Web Microsoft.AspNetCore.Components.Web.Virtualization Microsoft.AspNetCore.Connections Microsoft.AspNetCore.Connections.Features Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel Microsoft.AspNetCore.DataProtection.Internal Microsoft.AspNetCore.Diagnostics Microsoft.AspNetCore.Hosting Microsoft.AspNetCore.Http Microsoft.AspNetCore.Http.Features Microsoft.AspNetCore.Http.HttpResults Microsoft.AspNetCore.Http.Metadata Microsoft.AspNetCore.HttpLogging Microsoft.AspNetCore.Identity Microsoft.AspNetCore.Mvc Microsoft.AspNetCore.Mvc.ApplicationModels Microsoft.AspNetCore.Mvc.Infrastructure Microsoft.AspNetCore.Mvc.ModelBinding Microsoft.AspNetCore.Mvc.ModelBinding.Binders Microsoft.AspNetCore.Mvc.ModelBinding.Metadata Microsoft.AspNetCore.Mvc.RazorPages Microsoft.AspNetCore.Mvc.Rendering Microsoft.AspNetCore.Mvc.Routing Microsoft.AspNetCore.Mvc.ViewFeatures Microsoft.AspNetCore.OutputCaching Microsoft.AspNetCore.RateLimiting Microsoft.AspNetCore.RequestDecompression Microsoft.AspNetCore.ResponseCompression Microsoft.AspNetCore.Routing Microsoft.AspNetCore.Routing.Patterns Microsoft.AspNetCore.Server.IIS.Core Microsoft.AspNetCore.Server.Kestrel.Core Microsoft.AspNetCore.Server.Kestrel.Https Microsoft.AspNetCore.Server.Kestrel.Transport.Quic Microsoft.AspNetCore.SignalR Microsoft.AspNetCore.SignalR.Protocol Microsoft.AspNetCore.WebUtilities Microsoft.Extensions.Caching.Distributed Microsoft.Extensions.Caching.Memory Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.CommandLine Microsoft.Extensions.Configuration.EnvironmentVariables Microsoft.Extensions.Configuration.Ini Microsoft.Extensions.Configuration.Memory Microsoft.Extensions.Configuration.Xml Microsoft.Extensions.DependencyInjection Microsoft.Extensions.DependencyInjection.Extensions Microsoft.Extensions.FileProviders Microsoft.Extensions.FileProviders.Physical Microsoft.Extensions.FileSystemGlobbing Microsoft.Extensions.FileSystemGlobbing.Abstractions Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts Microsoft.Extensions.Hosting Microsoft.Extensions.Hosting.Internal Microsoft.Extensions.Http Microsoft.Extensions.Logging Microsoft.Extensions.Logging.Abstractions Microsoft.Extensions.Logging.Configuration Microsoft.Extensions.Logging.Console Microsoft.Extensions.Logging.EventLog Microsoft.Extensions.Logging.TraceSource Microsoft.Extensions.ObjectPool Microsoft.Extensions.Options Microsoft.Extensions.Primitives Microsoft.JSInterop Microsoft.JSInterop.Infrastructure Microsoft.Net.Http.Headers System.Diagnostics.Eventing.Reader System.Security.Claims System.Threading.RateLimiting","title":"API Difference 6.0 vs 7.0"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authentication.Cookies/","text":"Microsoft.AspNetCore.Authentication.Cookies namespace Microsoft.AspNetCore.Authentication.Cookies { public class CookieAuthenticationEvents { + public virtual Task CheckSlidingExpiration(CookieSlidingExpirationContext context); } public interface ITicketStore { + Task RemoveAsync(string key, HttpContext httpContext, CancellationToken cancellationToken); + Task RenewAsync(string key, AuthenticationTicket ticket, HttpContext httpContext, CancellationToken cancellationToken); + Task<AuthenticationTicket?> RetrieveAsync(string key, HttpContext httpContext, CancellationToken cancellationToken); + Task<string> StoreAsync(AuthenticationTicket ticket, HttpContext httpContext, CancellationToken cancellationToken); } public class PostConfigureCookieAuthenticationOptions : IPostConfigureOptions<CookieAuthenticationOptions> { - public void PostConfigure(string name, CookieAuthenticationOptions options); + public void PostConfigure(string? name, CookieAuthenticationOptions options); } }","title":"Microsoft.AspNetCore.Authentication.Cookies"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authentication.Cookies/#microsoftaspnetcoreauthenticationcookies","text":"namespace Microsoft.AspNetCore.Authentication.Cookies { public class CookieAuthenticationEvents { + public virtual Task CheckSlidingExpiration(CookieSlidingExpirationContext context); } public interface ITicketStore { + Task RemoveAsync(string key, HttpContext httpContext, CancellationToken cancellationToken); + Task RenewAsync(string key, AuthenticationTicket ticket, HttpContext httpContext, CancellationToken cancellationToken); + Task<AuthenticationTicket?> RetrieveAsync(string key, HttpContext httpContext, CancellationToken cancellationToken); + Task<string> StoreAsync(AuthenticationTicket ticket, HttpContext httpContext, CancellationToken cancellationToken); } public class PostConfigureCookieAuthenticationOptions : IPostConfigureOptions<CookieAuthenticationOptions> { - public void PostConfigure(string name, CookieAuthenticationOptions options); + public void PostConfigure(string? name, CookieAuthenticationOptions options); } }","title":"Microsoft.AspNetCore.Authentication.Cookies"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authentication/","text":"Microsoft.AspNetCore.Authentication namespace Microsoft.AspNetCore.Authentication { + public static class AuthenticationConfigurationProviderExtensions { + public static IConfiguration GetSchemeConfiguration(this IAuthenticationConfigurationProvider provider, string authenticationScheme); + } + public interface IAuthenticationConfigurationProvider { + IConfiguration AuthenticationConfiguration { get; } + } }","title":"Microsoft.AspNetCore.Authentication"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authentication/#microsoftaspnetcoreauthentication","text":"namespace Microsoft.AspNetCore.Authentication { + public static class AuthenticationConfigurationProviderExtensions { + public static IConfiguration GetSchemeConfiguration(this IAuthenticationConfigurationProvider provider, string authenticationScheme); + } + public interface IAuthenticationConfigurationProvider { + IConfiguration AuthenticationConfiguration { get; } + } }","title":"Microsoft.AspNetCore.Authentication"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization.Infrastructure/","text":"Microsoft.AspNetCore.Authorization.Infrastructure namespace Microsoft.AspNetCore.Authorization.Infrastructure { public class PassThroughAuthorizationHandler : IAuthorizationHandler { + public PassThroughAuthorizationHandler(IOptions<AuthorizationOptions> options); public Task HandleAsync(AuthorizationHandlerContext context); } }","title":"Microsoft.AspNetCore.Authorization.Infrastructure"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization.Infrastructure/#microsoftaspnetcoreauthorizationinfrastructure","text":"namespace Microsoft.AspNetCore.Authorization.Infrastructure { public class PassThroughAuthorizationHandler : IAuthorizationHandler { + public PassThroughAuthorizationHandler(IOptions<AuthorizationOptions> options); public Task HandleAsync(AuthorizationHandlerContext context); } }","title":"Microsoft.AspNetCore.Authorization.Infrastructure"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization.Policy/","text":"Microsoft.AspNetCore.Authorization.Policy namespace Microsoft.AspNetCore.Authorization.Policy { public class AuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler { public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult); } }","title":"Microsoft.AspNetCore.Authorization.Policy"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization.Policy/#microsoftaspnetcoreauthorizationpolicy","text":"namespace Microsoft.AspNetCore.Authorization.Policy { public class AuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler { public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult); } }","title":"Microsoft.AspNetCore.Authorization.Policy"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization/","text":"Microsoft.AspNetCore.Authorization namespace Microsoft.AspNetCore.Authorization { + public class AuthorizationBuilder { + public AuthorizationBuilder(IServiceCollection services); + public virtual IServiceCollection Services { get; } + public virtual AuthorizationBuilder AddDefaultPolicy(string name, AuthorizationPolicy policy); + public virtual AuthorizationBuilder AddDefaultPolicy(string name, Action<AuthorizationPolicyBuilder> configurePolicy); + public virtual AuthorizationBuilder AddFallbackPolicy(string name, AuthorizationPolicy policy); + public virtual AuthorizationBuilder AddFallbackPolicy(string name, Action<AuthorizationPolicyBuilder> configurePolicy); + public virtual AuthorizationBuilder AddPolicy(string name, AuthorizationPolicy policy); + public virtual AuthorizationBuilder AddPolicy(string name, Action<AuthorizationPolicyBuilder> configurePolicy); + public virtual AuthorizationBuilder SetDefaultPolicy(AuthorizationPolicy policy); + public virtual AuthorizationBuilder SetFallbackPolicy(AuthorizationPolicy? policy); + public virtual AuthorizationBuilder SetInvokeHandlersAfterFailure(bool invoke); + } public class AuthorizationMiddleware { + public AuthorizationMiddleware(RequestDelegate next, IAuthorizationPolicyProvider policyProvider, IServiceProvider services); public Task Invoke(HttpContext context); } public class AuthorizationPolicy { public static Task<AuthorizationPolicy?> CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable<IAuthorizeData> authorizeData); + public static Task<AuthorizationPolicy?> CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable<IAuthorizeData> authorizeData, IEnumerable<AuthorizationPolicy> policies); } public class DefaultAuthorizationPolicyProvider : IAuthorizationPolicyProvider { + public virtual bool AllowsCachingPolicies { get; } } public interface IAuthorizationPolicyProvider { + bool AllowsCachingPolicies { get; } } }","title":"Microsoft.AspNetCore.Authorization"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Authorization/#microsoftaspnetcoreauthorization","text":"namespace Microsoft.AspNetCore.Authorization { + public class AuthorizationBuilder { + public AuthorizationBuilder(IServiceCollection services); + public virtual IServiceCollection Services { get; } + public virtual AuthorizationBuilder AddDefaultPolicy(string name, AuthorizationPolicy policy); + public virtual AuthorizationBuilder AddDefaultPolicy(string name, Action<AuthorizationPolicyBuilder> configurePolicy); + public virtual AuthorizationBuilder AddFallbackPolicy(string name, AuthorizationPolicy policy); + public virtual AuthorizationBuilder AddFallbackPolicy(string name, Action<AuthorizationPolicyBuilder> configurePolicy); + public virtual AuthorizationBuilder AddPolicy(string name, AuthorizationPolicy policy); + public virtual AuthorizationBuilder AddPolicy(string name, Action<AuthorizationPolicyBuilder> configurePolicy); + public virtual AuthorizationBuilder SetDefaultPolicy(AuthorizationPolicy policy); + public virtual AuthorizationBuilder SetFallbackPolicy(AuthorizationPolicy? policy); + public virtual AuthorizationBuilder SetInvokeHandlersAfterFailure(bool invoke); + } public class AuthorizationMiddleware { + public AuthorizationMiddleware(RequestDelegate next, IAuthorizationPolicyProvider policyProvider, IServiceProvider services); public Task Invoke(HttpContext context); } public class AuthorizationPolicy { public static Task<AuthorizationPolicy?> CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable<IAuthorizeData> authorizeData); + public static Task<AuthorizationPolicy?> CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable<IAuthorizeData> authorizeData, IEnumerable<AuthorizationPolicy> policies); } public class DefaultAuthorizationPolicyProvider : IAuthorizationPolicyProvider { + public virtual bool AllowsCachingPolicies { get; } } public interface IAuthorizationPolicyProvider { + bool AllowsCachingPolicies { get; } } }","title":"Microsoft.AspNetCore.Authorization"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Builder/","text":"Microsoft.AspNetCore.Builder namespace Microsoft.AspNetCore.Builder { public static class AuthorizationEndpointConventionBuilderExtensions { + public static TBuilder RequireAuthorization<TBuilder>(this TBuilder builder, AuthorizationPolicy policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder RequireAuthorization<TBuilder>(this TBuilder builder, Action<AuthorizationPolicyBuilder> configurePolicy) where TBuilder : IEndpointConventionBuilder; } public sealed class ComponentEndpointConventionBuilder : IEndpointConventionBuilder, IHubEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public sealed class ConfigureWebHostBuilder : ISupportsStartup, IWebHostBuilder { IWebHostBuilder ISupportsStartup.UseStartup(Type startupType); } public sealed class ConnectionEndpointRouteBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public sealed class ControllerActionEndpointConventionBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public static class ControllerEndpointRouteBuilderExtensions { public static ControllerActionEndpointConventionBuilder MapAreaControllerRoute(this IEndpointRouteBuilder endpoints, string name, string areaName, string pattern, object? defaults = null, object? constraints = null, object? dataTokens = null); public static ControllerActionEndpointConventionBuilder MapControllerRoute(this IEndpointRouteBuilder endpoints, string name, string pattern, object? defaults = null, object? constraints = null, object? dataTokens = null); public static void MapDynamicControllerRoute<TTransformer>(this IEndpointRouteBuilder endpoints, string pattern) where TTransformer : DynamicRouteValueTransformer; public static void MapDynamicControllerRoute<TTransformer>(this IEndpointRouteBuilder endpoints, string pattern, object? state) where TTransformer : DynamicRouteValueTransformer; public static void MapDynamicControllerRoute<TTransformer>(this IEndpointRouteBuilder endpoints, string pattern, object state, int order) where TTransformer : DynamicRouteValueTransformer; public static IEndpointConventionBuilder MapFallbackToAreaController(this IEndpointRouteBuilder endpoints, string pattern, string action, string controller, string area); public static IEndpointConventionBuilder MapFallbackToController(this IEndpointRouteBuilder endpoints, string pattern, string action, string controller); } public class CookiePolicyOptions { + public string ConsentCookieValue { get; set; } } public abstract class EndpointBuilder { + public IServiceProvider ApplicationServices { get; set; } - public string DisplayName { get; set; } + public string? DisplayName { get; set; } + public IList<Func<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate>> FilterFactories { get; } - public RequestDelegate RequestDelegate { get; set; } + public RequestDelegate? RequestDelegate { get; set; } } public static class EndpointRouteBuilderExtensions { public static RouteHandlerBuilder Map(this IEndpointRouteBuilder endpoints, RoutePattern pattern, Delegate handler); public static IEndpointConventionBuilder Map(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder Map(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapDelete(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapDelete(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static RouteHandlerBuilder MapFallback(this IEndpointRouteBuilder endpoints, Delegate handler); public static RouteHandlerBuilder MapFallback(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapGet(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapGet(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); + public static RouteGroupBuilder MapGroup(this IEndpointRouteBuilder endpoints, RoutePattern prefix); + public static RouteGroupBuilder MapGroup(this IEndpointRouteBuilder endpoints, string prefix); public static IEndpointConventionBuilder MapMethods(this IEndpointRouteBuilder endpoints, string pattern, IEnumerable<string> httpMethods, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapMethods(this IEndpointRouteBuilder endpoints, string pattern, IEnumerable<string> httpMethods, Delegate handler); + public static IEndpointConventionBuilder MapPatch(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); + public static RouteHandlerBuilder MapPatch(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapPost(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapPost(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapPut(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapPut(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); } public static class FallbackEndpointRouteBuilderExtensions { public static IEndpointConventionBuilder MapFallback(this IEndpointRouteBuilder endpoints, RequestDelegate requestDelegate); public static IEndpointConventionBuilder MapFallback(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); } public sealed class HubEndpointConventionBuilder : IEndpointConventionBuilder, IHubEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public interface IEndpointConventionBuilder { + void Finally(Action<EndpointBuilder> finallyConvention); } public static class MapRouteRouteBuilderExtensions { public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string? name, string? template); public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string name, string template, object defaults); public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints); public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints, object dataTokens); } public static class MvcAreaRouteBuilderExtensions { public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template); public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template, object? defaults); public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template, object? defaults, object? constraints); public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template, object? defaults, object? constraints, object? dataTokens); } + public static class OutputCacheApplicationBuilderExtensions { + public static IApplicationBuilder UseOutputCache(this IApplicationBuilder app); + } public sealed class PageActionEndpointConventionBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } + public static class RateLimiterApplicationBuilderExtensions { + public static IApplicationBuilder UseRateLimiter(this IApplicationBuilder app); + public static IApplicationBuilder UseRateLimiter(this IApplicationBuilder app, RateLimiterOptions options); + } + public static class RateLimiterEndpointConventionBuilderExtensions { + public static TBuilder DisableRateLimiting<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder; + public static TBuilder RequireRateLimiting<TBuilder, TPartitionKey>(this TBuilder builder, IRateLimiterPolicy<TPartitionKey> policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder RequireRateLimiting<TBuilder>(this TBuilder builder, string policyName) where TBuilder : IEndpointConventionBuilder; + } + public static class RateLimiterServiceCollectionExtensions { + public static IServiceCollection AddRateLimiter(this IServiceCollection services, Action<RateLimiterOptions> configureOptions); + } + public static class RequestDecompressionBuilderExtensions { + public static IApplicationBuilder UseRequestDecompression(this IApplicationBuilder builder); + } public sealed class RouteHandlerBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public static class StaticFilesEndpointRouteBuilderExtensions { public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string filePath); public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string filePath, StaticFileOptions options); public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string pattern, string filePath); public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string pattern, string filePath, StaticFileOptions options); } public sealed class WebApplication : IApplicationBuilder, IAsyncDisposable, IDisposable, IEndpointRouteBuilder, IHost { - IApplicationBuilder IApplicationBuilder.Use(Func<RequestDelegate, RequestDelegate> middleware); + public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware); } public sealed class WebApplicationBuilder { public ConfigurationManager Configuration { get; } public ILoggingBuilder Logging { get; } public IServiceCollection Services { get; } } }","title":"Microsoft.AspNetCore.Builder"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Builder/#microsoftaspnetcorebuilder","text":"namespace Microsoft.AspNetCore.Builder { public static class AuthorizationEndpointConventionBuilderExtensions { + public static TBuilder RequireAuthorization<TBuilder>(this TBuilder builder, AuthorizationPolicy policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder RequireAuthorization<TBuilder>(this TBuilder builder, Action<AuthorizationPolicyBuilder> configurePolicy) where TBuilder : IEndpointConventionBuilder; } public sealed class ComponentEndpointConventionBuilder : IEndpointConventionBuilder, IHubEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public sealed class ConfigureWebHostBuilder : ISupportsStartup, IWebHostBuilder { IWebHostBuilder ISupportsStartup.UseStartup(Type startupType); } public sealed class ConnectionEndpointRouteBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public sealed class ControllerActionEndpointConventionBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public static class ControllerEndpointRouteBuilderExtensions { public static ControllerActionEndpointConventionBuilder MapAreaControllerRoute(this IEndpointRouteBuilder endpoints, string name, string areaName, string pattern, object? defaults = null, object? constraints = null, object? dataTokens = null); public static ControllerActionEndpointConventionBuilder MapControllerRoute(this IEndpointRouteBuilder endpoints, string name, string pattern, object? defaults = null, object? constraints = null, object? dataTokens = null); public static void MapDynamicControllerRoute<TTransformer>(this IEndpointRouteBuilder endpoints, string pattern) where TTransformer : DynamicRouteValueTransformer; public static void MapDynamicControllerRoute<TTransformer>(this IEndpointRouteBuilder endpoints, string pattern, object? state) where TTransformer : DynamicRouteValueTransformer; public static void MapDynamicControllerRoute<TTransformer>(this IEndpointRouteBuilder endpoints, string pattern, object state, int order) where TTransformer : DynamicRouteValueTransformer; public static IEndpointConventionBuilder MapFallbackToAreaController(this IEndpointRouteBuilder endpoints, string pattern, string action, string controller, string area); public static IEndpointConventionBuilder MapFallbackToController(this IEndpointRouteBuilder endpoints, string pattern, string action, string controller); } public class CookiePolicyOptions { + public string ConsentCookieValue { get; set; } } public abstract class EndpointBuilder { + public IServiceProvider ApplicationServices { get; set; } - public string DisplayName { get; set; } + public string? DisplayName { get; set; } + public IList<Func<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate>> FilterFactories { get; } - public RequestDelegate RequestDelegate { get; set; } + public RequestDelegate? RequestDelegate { get; set; } } public static class EndpointRouteBuilderExtensions { public static RouteHandlerBuilder Map(this IEndpointRouteBuilder endpoints, RoutePattern pattern, Delegate handler); public static IEndpointConventionBuilder Map(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder Map(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapDelete(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapDelete(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static RouteHandlerBuilder MapFallback(this IEndpointRouteBuilder endpoints, Delegate handler); public static RouteHandlerBuilder MapFallback(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapGet(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapGet(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); + public static RouteGroupBuilder MapGroup(this IEndpointRouteBuilder endpoints, RoutePattern prefix); + public static RouteGroupBuilder MapGroup(this IEndpointRouteBuilder endpoints, string prefix); public static IEndpointConventionBuilder MapMethods(this IEndpointRouteBuilder endpoints, string pattern, IEnumerable<string> httpMethods, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapMethods(this IEndpointRouteBuilder endpoints, string pattern, IEnumerable<string> httpMethods, Delegate handler); + public static IEndpointConventionBuilder MapPatch(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); + public static RouteHandlerBuilder MapPatch(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapPost(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapPost(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); public static IEndpointConventionBuilder MapPut(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); public static RouteHandlerBuilder MapPut(this IEndpointRouteBuilder endpoints, string pattern, Delegate handler); } public static class FallbackEndpointRouteBuilderExtensions { public static IEndpointConventionBuilder MapFallback(this IEndpointRouteBuilder endpoints, RequestDelegate requestDelegate); public static IEndpointConventionBuilder MapFallback(this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate requestDelegate); } public sealed class HubEndpointConventionBuilder : IEndpointConventionBuilder, IHubEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public interface IEndpointConventionBuilder { + void Finally(Action<EndpointBuilder> finallyConvention); } public static class MapRouteRouteBuilderExtensions { public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string? name, string? template); public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string name, string template, object defaults); public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints); public static IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, string name, string template, object defaults, object constraints, object dataTokens); } public static class MvcAreaRouteBuilderExtensions { public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template); public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template, object? defaults); public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template, object? defaults, object? constraints); public static IRouteBuilder MapAreaRoute(this IRouteBuilder routeBuilder, string name, string areaName, string? template, object? defaults, object? constraints, object? dataTokens); } + public static class OutputCacheApplicationBuilderExtensions { + public static IApplicationBuilder UseOutputCache(this IApplicationBuilder app); + } public sealed class PageActionEndpointConventionBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } + public static class RateLimiterApplicationBuilderExtensions { + public static IApplicationBuilder UseRateLimiter(this IApplicationBuilder app); + public static IApplicationBuilder UseRateLimiter(this IApplicationBuilder app, RateLimiterOptions options); + } + public static class RateLimiterEndpointConventionBuilderExtensions { + public static TBuilder DisableRateLimiting<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder; + public static TBuilder RequireRateLimiting<TBuilder, TPartitionKey>(this TBuilder builder, IRateLimiterPolicy<TPartitionKey> policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder RequireRateLimiting<TBuilder>(this TBuilder builder, string policyName) where TBuilder : IEndpointConventionBuilder; + } + public static class RateLimiterServiceCollectionExtensions { + public static IServiceCollection AddRateLimiter(this IServiceCollection services, Action<RateLimiterOptions> configureOptions); + } + public static class RequestDecompressionBuilderExtensions { + public static IApplicationBuilder UseRequestDecompression(this IApplicationBuilder builder); + } public sealed class RouteHandlerBuilder : IEndpointConventionBuilder { + public void Finally(Action<EndpointBuilder> finalConvention); } public static class StaticFilesEndpointRouteBuilderExtensions { public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string filePath); public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string filePath, StaticFileOptions options); public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string pattern, string filePath); public static IEndpointConventionBuilder MapFallbackToFile(this IEndpointRouteBuilder endpoints, string pattern, string filePath, StaticFileOptions options); } public sealed class WebApplication : IApplicationBuilder, IAsyncDisposable, IDisposable, IEndpointRouteBuilder, IHost { - IApplicationBuilder IApplicationBuilder.Use(Func<RequestDelegate, RequestDelegate> middleware); + public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware); } public sealed class WebApplicationBuilder { public ConfigurationManager Configuration { get; } public ILoggingBuilder Logging { get; } public IServiceCollection Services { get; } } }","title":"Microsoft.AspNetCore.Builder"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.CompilerServices/","text":"Microsoft.AspNetCore.Components.CompilerServices namespace Microsoft.AspNetCore.Components.CompilerServices { public static class RuntimeHelpers { + public static EventCallback<T> CreateInferredEventCallback<T>(object receiver, EventCallback<T> callback, T value); + public static Task InvokeAsynchronousDelegate(Action callback); + public static Task InvokeAsynchronousDelegate(Func<Task> callback); + public static void InvokeSynchronousDelegate(Action callback); } }","title":"Microsoft.AspNetCore.Components.CompilerServices"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.CompilerServices/#microsoftaspnetcorecomponentscompilerservices","text":"namespace Microsoft.AspNetCore.Components.CompilerServices { public static class RuntimeHelpers { + public static EventCallback<T> CreateInferredEventCallback<T>(object receiver, EventCallback<T> callback, T value); + public static Task InvokeAsynchronousDelegate(Action callback); + public static Task InvokeAsynchronousDelegate(Func<Task> callback); + public static void InvokeSynchronousDelegate(Action callback); } }","title":"Microsoft.AspNetCore.Components.CompilerServices"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Forms/","text":"Microsoft.AspNetCore.Components.Forms namespace Microsoft.AspNetCore.Components.Forms { public static class EditContextDataAnnotationsExtensions { public static IDisposable EnableDataAnnotationsValidation(this EditContext editContext); + public static IDisposable EnableDataAnnotationsValidation(this EditContext editContext, IServiceProvider serviceProvider); } public abstract class InputBase<TValue> : ComponentBase, IDisposable { public override Task SetParametersAsync(ParameterView parameters); } public class InputRadio<TValue> : ComponentBase { + public ElementReference? Element { get; protected set; } } }","title":"Microsoft.AspNetCore.Components.Forms"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Forms/#microsoftaspnetcorecomponentsforms","text":"namespace Microsoft.AspNetCore.Components.Forms { public static class EditContextDataAnnotationsExtensions { public static IDisposable EnableDataAnnotationsValidation(this EditContext editContext); + public static IDisposable EnableDataAnnotationsValidation(this EditContext editContext, IServiceProvider serviceProvider); } public abstract class InputBase<TValue> : ComponentBase, IDisposable { public override Task SetParametersAsync(ParameterView parameters); } public class InputRadio<TValue> : ComponentBase { + public ElementReference? Element { get; protected set; } } }","title":"Microsoft.AspNetCore.Components.Forms"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.RenderTree/","text":"Microsoft.AspNetCore.Components.RenderTree namespace Microsoft.AspNetCore.Components.RenderTree { public abstract class Renderer : IAsyncDisposable, IDisposable { public ValueTask DisposeAsync(); protected internal Task RenderRootComponentAsync(int componentId, ParameterView initialParameters); } }","title":"Microsoft.AspNetCore.Components.RenderTree"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.RenderTree/#microsoftaspnetcorecomponentsrendertree","text":"namespace Microsoft.AspNetCore.Components.RenderTree { public abstract class Renderer : IAsyncDisposable, IDisposable { public ValueTask DisposeAsync(); protected internal Task RenderRootComponentAsync(int componentId, ParameterView initialParameters); } }","title":"Microsoft.AspNetCore.Components.RenderTree"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Rendering/","text":"Microsoft.AspNetCore.Components.Rendering namespace Microsoft.AspNetCore.Components.Rendering { public sealed class RenderTreeBuilder : IDisposable { + public void AddContent(int sequence, MarkupString? markupContent); } }","title":"Microsoft.AspNetCore.Components.Rendering"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Rendering/#microsoftaspnetcorecomponentsrendering","text":"namespace Microsoft.AspNetCore.Components.Rendering { public sealed class RenderTreeBuilder : IDisposable { + public void AddContent(int sequence, MarkupString? markupContent); } }","title":"Microsoft.AspNetCore.Components.Rendering"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Routing/","text":"Microsoft.AspNetCore.Components.Routing namespace Microsoft.AspNetCore.Components.Routing { public class LocationChangedEventArgs : EventArgs { + public string? HistoryEntryState { get; internal set; } } + public sealed class LocationChangingContext { + public LocationChangingContext(); + public CancellationToken CancellationToken { get; set; } + public string? HistoryEntryState { get; set; } + public bool IsNavigationIntercepted { get; set; } + public required string TargetLocation { get; set; } + public void PreventNavigation(); + } + public sealed class NavigationLock : IAsyncDisposable, IComponent, IHandleAfterRender { + public NavigationLock(); + public bool ConfirmExternalNavigation { get; set; } + public EventCallback<LocationChangingContext> OnBeforeInternalNavigation { get; set; } + void IComponent.Attach(RenderHandle renderHandle); + Task IComponent.SetParametersAsync(ParameterView parameters); + Task IHandleAfterRender.OnAfterRenderAsync(); + ValueTask IAsyncDisposable.DisposeAsync(); + } public class Router : IComponent, IDisposable, IHandleAfterRender { public Task SetParametersAsync(ParameterView parameters); } }","title":"Microsoft.AspNetCore.Components.Routing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Routing/#microsoftaspnetcorecomponentsrouting","text":"namespace Microsoft.AspNetCore.Components.Routing { public class LocationChangedEventArgs : EventArgs { + public string? HistoryEntryState { get; internal set; } } + public sealed class LocationChangingContext { + public LocationChangingContext(); + public CancellationToken CancellationToken { get; set; } + public string? HistoryEntryState { get; set; } + public bool IsNavigationIntercepted { get; set; } + public required string TargetLocation { get; set; } + public void PreventNavigation(); + } + public sealed class NavigationLock : IAsyncDisposable, IComponent, IHandleAfterRender { + public NavigationLock(); + public bool ConfirmExternalNavigation { get; set; } + public EventCallback<LocationChangingContext> OnBeforeInternalNavigation { get; set; } + void IComponent.Attach(RenderHandle renderHandle); + Task IComponent.SetParametersAsync(ParameterView parameters); + Task IHandleAfterRender.OnAfterRenderAsync(); + ValueTask IAsyncDisposable.DisposeAsync(); + } public class Router : IComponent, IDisposable, IHandleAfterRender { public Task SetParametersAsync(ParameterView parameters); } }","title":"Microsoft.AspNetCore.Components.Routing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Web.Virtualization/","text":"Microsoft.AspNetCore.Components.Web.Virtualization namespace Microsoft.AspNetCore.Components.Web.Virtualization { public sealed class Virtualize<TItem> : ComponentBase, IAsyncDisposable, IVirtualizeJsCallbacks { + public string SpacerElement { get; set; } public ValueTask DisposeAsync(); protected override Task OnAfterRenderAsync(bool firstRender); public Task RefreshDataAsync(); } }","title":"Microsoft.AspNetCore.Components.Web.Virtualization"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Web.Virtualization/#microsoftaspnetcorecomponentswebvirtualization","text":"namespace Microsoft.AspNetCore.Components.Web.Virtualization { public sealed class Virtualize<TItem> : ComponentBase, IAsyncDisposable, IVirtualizeJsCallbacks { + public string SpacerElement { get; set; } public ValueTask DisposeAsync(); protected override Task OnAfterRenderAsync(bool firstRender); public Task RefreshDataAsync(); } }","title":"Microsoft.AspNetCore.Components.Web.Virtualization"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Web/","text":"Microsoft.AspNetCore.Components.Web namespace Microsoft.AspNetCore.Components.Web { public static class EventHandlers public class MouseEventArgs : EventArgs { + public double MovementX { get; set; } + public double MovementY { get; set; } } }","title":"Microsoft.AspNetCore.Components.Web"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components.Web/#microsoftaspnetcorecomponentsweb","text":"namespace Microsoft.AspNetCore.Components.Web { public static class EventHandlers public class MouseEventArgs : EventArgs { + public double MovementX { get; set; } + public double MovementY { get; set; } } }","title":"Microsoft.AspNetCore.Components.Web"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components/","text":"Microsoft.AspNetCore.Components namespace Microsoft.AspNetCore.Components { public class DynamicComponent : IComponent { public Task SetParametersAsync(ParameterView parameters); } public static class EventCallbackFactoryBinderExtensions { + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<bool> setter, bool existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly> setter, DateOnly existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly> setter, DateOnly existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime> setter, DateTime existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime> setter, DateTime existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset> setter, DateTimeOffset existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset> setter, DateTimeOffset existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<decimal> setter, decimal existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<double> setter, double existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<short> setter, short existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<int> setter, int existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<long> setter, long existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<bool?> setter, bool? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly?> setter, DateOnly? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly?> setter, DateOnly? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime?> setter, DateTime? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime?> setter, DateTime? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset?> setter, DateTimeOffset? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset?> setter, DateTimeOffset? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<decimal?> setter, decimal? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<double?> setter, double? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<short?> setter, short? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<int?> setter, int? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<long?> setter, long? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<float?> setter, float? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly?> setter, TimeOnly? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly?> setter, TimeOnly? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<float> setter, float existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<string?> setter, string existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly> setter, TimeOnly existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly> setter, TimeOnly existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder<T>(this EventCallbackFactory factory, object receiver, EventCallback<T> setter, T existingValue, CultureInfo? culture = null); } public sealed class LayoutAttribute : Attribute { public LayoutAttribute(Type layoutType); } public abstract class NavigationManager { + public string? HistoryEntryState { get; protected set; } + protected virtual void HandleLocationChangingHandlerException(Exception ex, LocationChangingContext context); + protected ValueTask<bool> NotifyLocationChangingAsync(string uri, string? state, bool isNavigationIntercepted); + public IDisposable RegisterLocationChangingHandler(Func<LocationChangingContext, ValueTask> locationChangingHandler); + protected virtual void SetNavigationLockState(bool value); } public readonly struct NavigationOptions { + public string HistoryEntryState { get; set; } } public class RouteView : IComponent { protected virtual void Render(RenderTreeBuilder builder); } }","title":"Microsoft.AspNetCore.Components"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Components/#microsoftaspnetcorecomponents","text":"namespace Microsoft.AspNetCore.Components { public class DynamicComponent : IComponent { public Task SetParametersAsync(ParameterView parameters); } public static class EventCallbackFactoryBinderExtensions { + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<bool> setter, bool existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly> setter, DateOnly existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly> setter, DateOnly existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime> setter, DateTime existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime> setter, DateTime existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset> setter, DateTimeOffset existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset> setter, DateTimeOffset existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<decimal> setter, decimal existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<double> setter, double existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<short> setter, short existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<int> setter, int existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<long> setter, long existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<bool?> setter, bool? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly?> setter, DateOnly? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateOnly?> setter, DateOnly? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime?> setter, DateTime? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTime?> setter, DateTime? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset?> setter, DateTimeOffset? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<DateTimeOffset?> setter, DateTimeOffset? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<decimal?> setter, decimal? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<double?> setter, double? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<short?> setter, short? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<int?> setter, int? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<long?> setter, long? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<float?> setter, float? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly?> setter, TimeOnly? existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly?> setter, TimeOnly? existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<float> setter, float existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<string?> setter, string existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly> setter, TimeOnly existingValue, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder(this EventCallbackFactory factory, object receiver, EventCallback<TimeOnly> setter, TimeOnly existingValue, string format, CultureInfo? culture = null); + public static EventCallback<ChangeEventArgs> CreateBinder<T>(this EventCallbackFactory factory, object receiver, EventCallback<T> setter, T existingValue, CultureInfo? culture = null); } public sealed class LayoutAttribute : Attribute { public LayoutAttribute(Type layoutType); } public abstract class NavigationManager { + public string? HistoryEntryState { get; protected set; } + protected virtual void HandleLocationChangingHandlerException(Exception ex, LocationChangingContext context); + protected ValueTask<bool> NotifyLocationChangingAsync(string uri, string? state, bool isNavigationIntercepted); + public IDisposable RegisterLocationChangingHandler(Func<LocationChangingContext, ValueTask> locationChangingHandler); + protected virtual void SetNavigationLockState(bool value); } public readonly struct NavigationOptions { + public string HistoryEntryState { get; set; } } public class RouteView : IComponent { protected virtual void Render(RenderTreeBuilder builder); } }","title":"Microsoft.AspNetCore.Components"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Connections.Features/","text":"Microsoft.AspNetCore.Connections.Features namespace Microsoft.AspNetCore.Connections.Features { + public interface IStreamClosedFeature { + void OnClosed(Action<object?> callback, object state); + } }","title":"Microsoft.AspNetCore.Connections.Features"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Connections.Features/#microsoftaspnetcoreconnectionsfeatures","text":"namespace Microsoft.AspNetCore.Connections.Features { + public interface IStreamClosedFeature { + void OnClosed(Action<object?> callback, object state); + } }","title":"Microsoft.AspNetCore.Connections.Features"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Connections/","text":"Microsoft.AspNetCore.Connections namespace Microsoft.AspNetCore.Connections { + public class TlsConnectionCallbackContext { + public TlsConnectionCallbackContext(); + public SslClientHelloInfo ClientHelloInfo { get; set; } + public BaseConnectionContext Connection { get; set; } + public object? State { get; set; } + } + public class TlsConnectionCallbackOptions { + public TlsConnectionCallbackOptions(); + public List<SslApplicationProtocol> ApplicationProtocols { get; set; } + public Func<TlsConnectionCallbackContext, CancellationToken, ValueTask<SslServerAuthenticationOptions>> OnConnection { get; set; } + public object? OnConnectionState { get; set; } + } }","title":"Microsoft.AspNetCore.Connections"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Connections/#microsoftaspnetcoreconnections","text":"namespace Microsoft.AspNetCore.Connections { + public class TlsConnectionCallbackContext { + public TlsConnectionCallbackContext(); + public SslClientHelloInfo ClientHelloInfo { get; set; } + public BaseConnectionContext Connection { get; set; } + public object? State { get; set; } + } + public class TlsConnectionCallbackOptions { + public TlsConnectionCallbackOptions(); + public List<SslApplicationProtocol> ApplicationProtocols { get; set; } + public Func<TlsConnectionCallbackContext, CancellationToken, ValueTask<SslServerAuthenticationOptions>> OnConnection { get; set; } + public object? OnConnectionState { get; set; } + } }","title":"Microsoft.AspNetCore.Connections"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel/","text":"Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel namespace Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel { public sealed class ManagedAuthenticatedEncryptorConfiguration : AlgorithmConfiguration, IInternalAlgorithmConfiguration { public Type EncryptionAlgorithmType { get; set; } public Type ValidationAlgorithmType { get; set; } } }","title":"Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel/#microsoftaspnetcoredataprotectionauthenticatedencryptionconfigurationmodel","text":"namespace Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel { public sealed class ManagedAuthenticatedEncryptorConfiguration : AlgorithmConfiguration, IInternalAlgorithmConfiguration { public Type EncryptionAlgorithmType { get; set; } public Type ValidationAlgorithmType { get; set; } } }","title":"Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.DataProtection.Internal/","text":"Microsoft.AspNetCore.DataProtection.Internal namespace Microsoft.AspNetCore.DataProtection.Internal { public interface IActivator { object CreateInstance(Type expectedBaseType, string implementationTypeName); } }","title":"Microsoft.AspNetCore.DataProtection.Internal"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.DataProtection.Internal/#microsoftaspnetcoredataprotectioninternal","text":"namespace Microsoft.AspNetCore.DataProtection.Internal { public interface IActivator { object CreateInstance(Type expectedBaseType, string implementationTypeName); } }","title":"Microsoft.AspNetCore.DataProtection.Internal"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Diagnostics/","text":"Microsoft.AspNetCore.Diagnostics namespace Microsoft.AspNetCore.Diagnostics { public class DeveloperExceptionPageMiddleware { public Task Invoke(HttpContext context); } public interface IStatusCodeReExecuteFeature { + Endpoint Endpoint { get; } - string? OriginalQueryString { get; set; } + string OriginalQueryString { get; set; } + RouteValueDictionary RouteValues { get; } } public class StatusCodeReExecuteFeature : IStatusCodeReExecuteFeature { + public Endpoint Endpoint { get; set; } - public string? OriginalQueryString { get; set; } + public string OriginalQueryString { get; set; } + public RouteValueDictionary RouteValues { get; set; } } }","title":"Microsoft.AspNetCore.Diagnostics"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Diagnostics/#microsoftaspnetcorediagnostics","text":"namespace Microsoft.AspNetCore.Diagnostics { public class DeveloperExceptionPageMiddleware { public Task Invoke(HttpContext context); } public interface IStatusCodeReExecuteFeature { + Endpoint Endpoint { get; } - string? OriginalQueryString { get; set; } + string OriginalQueryString { get; set; } + RouteValueDictionary RouteValues { get; } } public class StatusCodeReExecuteFeature : IStatusCodeReExecuteFeature { + public Endpoint Endpoint { get; set; } - public string? OriginalQueryString { get; set; } + public string OriginalQueryString { get; set; } + public RouteValueDictionary RouteValues { get; set; } } }","title":"Microsoft.AspNetCore.Diagnostics"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Hosting/","text":"Microsoft.AspNetCore.Hosting namespace Microsoft.AspNetCore.Hosting { public static class HostingAbstractionsWebHostBuilderExtensions { public static IWebHostBuilder UseStartup(this IWebHostBuilder hostBuilder, string startupAssemblyName); } public class WebHostBuilder : IWebHostBuilder { - public string GetSetting(string key); + public string? GetSetting(string key); } public static class WebHostBuilderQuicExtensions { public static IWebHostBuilder UseQuic(this IWebHostBuilder hostBuilder); public static IWebHostBuilder UseQuic(this IWebHostBuilder hostBuilder, Action<QuicTransportOptions> configureOptions); } }","title":"Microsoft.AspNetCore.Hosting"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Hosting/#microsoftaspnetcorehosting","text":"namespace Microsoft.AspNetCore.Hosting { public static class HostingAbstractionsWebHostBuilderExtensions { public static IWebHostBuilder UseStartup(this IWebHostBuilder hostBuilder, string startupAssemblyName); } public class WebHostBuilder : IWebHostBuilder { - public string GetSetting(string key); + public string? GetSetting(string key); } public static class WebHostBuilderQuicExtensions { public static IWebHostBuilder UseQuic(this IWebHostBuilder hostBuilder); public static IWebHostBuilder UseQuic(this IWebHostBuilder hostBuilder, Action<QuicTransportOptions> configureOptions); } }","title":"Microsoft.AspNetCore.Hosting"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.Features/","text":"Microsoft.AspNetCore.Http.Features namespace Microsoft.AspNetCore.Http.Features { + public static class FeatureCollectionExtensions { + public static object GetRequiredFeature(this IFeatureCollection featureCollection, Type key); + public static TFeature GetRequiredFeature<TFeature>(this IFeatureCollection featureCollection); + } + public interface IHttpExtendedConnectFeature { + bool IsExtendedConnect { get; } + string Protocol { get; } + ValueTask<Stream> AcceptAsync(); + } + public interface IHttpWebTransportFeature { + bool IsWebTransportRequest { get; } + ValueTask<IWebTransportSession> AcceptAsync(CancellationToken cancellationToken = default(CancellationToken)); + } + public interface IWebTransportSession { + long SessionId { get; } + void Abort(int errorCode); + ValueTask<ConnectionContext?> AcceptStreamAsync(CancellationToken cancellationToken = default(CancellationToken)); + ValueTask<ConnectionContext?> OpenUnidirectionalStreamAsync(CancellationToken cancellationToken = default(CancellationToken)); + } }","title":"Microsoft.AspNetCore.Http.Features"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.Features/#microsoftaspnetcorehttpfeatures","text":"namespace Microsoft.AspNetCore.Http.Features { + public static class FeatureCollectionExtensions { + public static object GetRequiredFeature(this IFeatureCollection featureCollection, Type key); + public static TFeature GetRequiredFeature<TFeature>(this IFeatureCollection featureCollection); + } + public interface IHttpExtendedConnectFeature { + bool IsExtendedConnect { get; } + string Protocol { get; } + ValueTask<Stream> AcceptAsync(); + } + public interface IHttpWebTransportFeature { + bool IsWebTransportRequest { get; } + ValueTask<IWebTransportSession> AcceptAsync(CancellationToken cancellationToken = default(CancellationToken)); + } + public interface IWebTransportSession { + long SessionId { get; } + void Abort(int errorCode); + ValueTask<ConnectionContext?> AcceptStreamAsync(CancellationToken cancellationToken = default(CancellationToken)); + ValueTask<ConnectionContext?> OpenUnidirectionalStreamAsync(CancellationToken cancellationToken = default(CancellationToken)); + } }","title":"Microsoft.AspNetCore.Http.Features"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.HttpResults/","text":"Microsoft.AspNetCore.Http.HttpResults +namespace Microsoft.AspNetCore.Http.HttpResults { + public sealed class Accepted : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + public string? Location { get; } + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Accepted<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + public string Location { get; } + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class AcceptedAtRoute : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public string? RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class AcceptedAtRoute<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public string RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class BadRequest : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class BadRequest<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class ChallengeHttpResult : IResult { + public IReadOnlyList<string> AuthenticationSchemes { get; internal set; } + public AuthenticationProperties? Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class Conflict : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Conflict<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class ContentHttpResult : IContentTypeHttpResult, IResult, IStatusCodeHttpResult { + public string ContentType { get; internal set; } + public string ResponseContent { get; internal set; } + public int? StatusCode { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class Created : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + public string? Location { get; } + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Created<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + public string Location { get; } + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class CreatedAtRoute : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public string? RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class CreatedAtRoute<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public string RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class EmptyHttpResult : IResult { + public static EmptyHttpResult Instance { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class FileContentHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue? EntityTag { get; internal set; } + public ReadOnlyMemory<byte> FileContents { get; internal set; } + public string? FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class FileStreamHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue EntityTag { get; internal set; } + public string FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public Stream FileStream { get; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class ForbidHttpResult : IResult { + public IReadOnlyList<string> AuthenticationSchemes { get; internal set; } + public AuthenticationProperties? Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class JsonHttpResult<TValue> : IContentTypeHttpResult, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + public string ContentType { get; internal set; } + public JsonSerializerOptions JsonSerializerOptions { get; internal set; } + object IValueHttpResult.Value { get; } + public int? StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public class NoContent : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class NotFound : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class NotFound<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue Value { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Ok : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Ok<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class PhysicalFileHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue? EntityTag { get; internal set; } + public string? FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public string FileName { get; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class ProblemHttpResult : IContentTypeHttpResult, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<ProblemDetails> { + public string ContentType { get; } + int? IStatusCodeHttpResult.StatusCode { get; } + object? IValueHttpResult.Value { get; } + ProblemDetails? IValueHttpResult<ProblemDetails>.Value { get; } + public ProblemDetails ProblemDetails { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class PushStreamHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue EntityTag { get; internal set; } + public string FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class RedirectHttpResult : IResult { + public bool AcceptLocalUrlOnly { get; } + public bool Permanent { get; } + public bool PreserveMethod { get; } + public string Url { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class RedirectToRouteHttpResult : IResult { + public string Fragment { get; } + public bool Permanent { get; } + public bool PreserveMethod { get; } + public string RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class Results<TResult1, TResult2> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2> (TResult1 result); + public static implicit operator Results<TResult1, TResult2> (TResult2 result); + } + public sealed class Results<TResult1, TResult2, TResult3> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3> (TResult3 result); + } + public sealed class Results<TResult1, TResult2, TResult3, TResult4> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult where TResult4 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult3 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult4 result); + } + public sealed class Results<TResult1, TResult2, TResult3, TResult4, TResult5> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult where TResult4 : IResult where TResult5 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult3 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult4 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult5 result); + } + public sealed class Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult where TResult4 : IResult where TResult5 : IResult where TResult6 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult3 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult4 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult5 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult6 result); + } + public sealed class SignInHttpResult : IResult { + public string AuthenticationScheme { get; internal set; } + public ClaimsPrincipal Principal { get; internal set; } + public AuthenticationProperties Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class SignOutHttpResult : IResult { + public IReadOnlyList<string> AuthenticationSchemes { get; internal set; } + public AuthenticationProperties? Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class StatusCodeHttpResult : IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class UnauthorizedHttpResult : IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class UnprocessableEntity : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class UnprocessableEntity<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Utf8ContentHttpResult : IContentTypeHttpResult, IResult, IStatusCodeHttpResult { + public string? ContentType { get; internal set; } + public ReadOnlyMemory<byte> ResponseContent { get; internal set; } + public int? StatusCode { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class ValidationProblem : IContentTypeHttpResult, IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<HttpValidationProblemDetails> { + public string ContentType { get; } + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + HttpValidationProblemDetails? IValueHttpResult<HttpValidationProblemDetails>.Value { get; } + public HttpValidationProblemDetails ProblemDetails { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class VirtualFileHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue? EntityTag { get; internal set; } + public string? FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public string FileName { get; internal set; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } +}","title":"Microsoft.AspNetCore.Http.HttpResults"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.HttpResults/#microsoftaspnetcorehttphttpresults","text":"+namespace Microsoft.AspNetCore.Http.HttpResults { + public sealed class Accepted : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + public string? Location { get; } + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Accepted<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + public string Location { get; } + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class AcceptedAtRoute : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public string? RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class AcceptedAtRoute<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public string RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class BadRequest : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class BadRequest<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class ChallengeHttpResult : IResult { + public IReadOnlyList<string> AuthenticationSchemes { get; internal set; } + public AuthenticationProperties? Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class Conflict : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Conflict<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class ContentHttpResult : IContentTypeHttpResult, IResult, IStatusCodeHttpResult { + public string ContentType { get; internal set; } + public string ResponseContent { get; internal set; } + public int? StatusCode { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class Created : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + public string? Location { get; } + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Created<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + public string Location { get; } + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class CreatedAtRoute : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public string? RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class CreatedAtRoute<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public string RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public int StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class EmptyHttpResult : IResult { + public static EmptyHttpResult Instance { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class FileContentHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue? EntityTag { get; internal set; } + public ReadOnlyMemory<byte> FileContents { get; internal set; } + public string? FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class FileStreamHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue EntityTag { get; internal set; } + public string FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public Stream FileStream { get; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class ForbidHttpResult : IResult { + public IReadOnlyList<string> AuthenticationSchemes { get; internal set; } + public AuthenticationProperties? Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class JsonHttpResult<TValue> : IContentTypeHttpResult, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + public string ContentType { get; internal set; } + public JsonSerializerOptions JsonSerializerOptions { get; internal set; } + object IValueHttpResult.Value { get; } + public int? StatusCode { get; } + public TValue Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public class NoContent : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class NotFound : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class NotFound<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? IStatusCodeHttpResult.StatusCode { get; } + object IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue Value { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Ok : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Ok<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class PhysicalFileHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue? EntityTag { get; internal set; } + public string? FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public string FileName { get; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class ProblemHttpResult : IContentTypeHttpResult, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<ProblemDetails> { + public string ContentType { get; } + int? IStatusCodeHttpResult.StatusCode { get; } + object? IValueHttpResult.Value { get; } + ProblemDetails? IValueHttpResult<ProblemDetails>.Value { get; } + public ProblemDetails ProblemDetails { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class PushStreamHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue EntityTag { get; internal set; } + public string FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class RedirectHttpResult : IResult { + public bool AcceptLocalUrlOnly { get; } + public bool Permanent { get; } + public bool PreserveMethod { get; } + public string Url { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class RedirectToRouteHttpResult : IResult { + public string Fragment { get; } + public bool Permanent { get; } + public bool PreserveMethod { get; } + public string RouteName { get; } + public RouteValueDictionary RouteValues { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class Results<TResult1, TResult2> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2> (TResult1 result); + public static implicit operator Results<TResult1, TResult2> (TResult2 result); + } + public sealed class Results<TResult1, TResult2, TResult3> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3> (TResult3 result); + } + public sealed class Results<TResult1, TResult2, TResult3, TResult4> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult where TResult4 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult3 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4> (TResult4 result); + } + public sealed class Results<TResult1, TResult2, TResult3, TResult4, TResult5> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult where TResult4 : IResult where TResult5 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult3 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult4 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5> (TResult5 result); + } + public sealed class Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> : IEndpointMetadataProvider, INestedHttpResult, IResult where TResult1 : IResult where TResult2 : IResult where TResult3 : IResult where TResult4 : IResult where TResult5 : IResult where TResult6 : IResult { + public IResult Result { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult1 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult2 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult3 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult4 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult5 result); + public static implicit operator Results<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6> (TResult6 result); + } + public sealed class SignInHttpResult : IResult { + public string AuthenticationScheme { get; internal set; } + public ClaimsPrincipal Principal { get; internal set; } + public AuthenticationProperties Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class SignOutHttpResult : IResult { + public IReadOnlyList<string> AuthenticationSchemes { get; internal set; } + public AuthenticationProperties? Properties { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class StatusCodeHttpResult : IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class UnauthorizedHttpResult : IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class UnprocessableEntity : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class UnprocessableEntity<TValue> : IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<TValue> { + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + public int StatusCode { get; } + public TValue? Value { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class Utf8ContentHttpResult : IContentTypeHttpResult, IResult, IStatusCodeHttpResult { + public string? ContentType { get; internal set; } + public ReadOnlyMemory<byte> ResponseContent { get; internal set; } + public int? StatusCode { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } + public sealed class ValidationProblem : IContentTypeHttpResult, IEndpointMetadataProvider, IResult, IStatusCodeHttpResult, IValueHttpResult, IValueHttpResult<HttpValidationProblemDetails> { + public string ContentType { get; } + int? Microsoft.AspNetCore.Http.IStatusCodeHttpResult.StatusCode { get; } + object? Microsoft.AspNetCore.Http.IValueHttpResult.Value { get; } + HttpValidationProblemDetails? IValueHttpResult<HttpValidationProblemDetails>.Value { get; } + public HttpValidationProblemDetails ProblemDetails { get; } + public int StatusCode { get; } + public Task ExecuteAsync(HttpContext httpContext); + static void IEndpointMetadataProvider.PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public sealed class VirtualFileHttpResult : IContentTypeHttpResult, IFileHttpResult, IResult { + public string ContentType { get; internal set; } + public bool EnableRangeProcessing { get; internal set; } + public EntityTagHeaderValue? EntityTag { get; internal set; } + public string? FileDownloadName { get; internal set; } + public long? FileLength { get; internal set; } + public string FileName { get; internal set; } + public DateTimeOffset? LastModified { get; internal set; } + public Task ExecuteAsync(HttpContext httpContext); + } +}","title":"Microsoft.AspNetCore.Http.HttpResults"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.Metadata/","text":"Microsoft.AspNetCore.Http.Metadata namespace Microsoft.AspNetCore.Http.Metadata { + public interface IEndpointDescriptionMetadata { + string Description { get; } + } + public interface IEndpointMetadataProvider { + static abstract void PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public interface IEndpointParameterMetadataProvider { + static abstract void PopulateMetadata(ParameterInfo parameter, EndpointBuilder builder); + } + public interface IEndpointSummaryMetadata { + string Summary { get; } + } + public interface IFromFormMetadata { + string Name { get; } + } + public interface IRequestSizeLimitMetadata { + long? MaxRequestBodySize { get; } + } + public interface ISkipStatusCodePagesMetadata }","title":"Microsoft.AspNetCore.Http.Metadata"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http.Metadata/#microsoftaspnetcorehttpmetadata","text":"namespace Microsoft.AspNetCore.Http.Metadata { + public interface IEndpointDescriptionMetadata { + string Description { get; } + } + public interface IEndpointMetadataProvider { + static abstract void PopulateMetadata(MethodInfo method, EndpointBuilder builder); + } + public interface IEndpointParameterMetadataProvider { + static abstract void PopulateMetadata(ParameterInfo parameter, EndpointBuilder builder); + } + public interface IEndpointSummaryMetadata { + string Summary { get; } + } + public interface IFromFormMetadata { + string Name { get; } + } + public interface IRequestSizeLimitMetadata { + long? MaxRequestBodySize { get; } + } + public interface ISkipStatusCodePagesMetadata }","title":"Microsoft.AspNetCore.Http.Metadata"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http/","text":"Microsoft.AspNetCore.Http namespace Microsoft.AspNetCore.Http { + public sealed class AsParametersAttribute : Attribute { + public AsParametersAttribute(); + } public class CookieBuilder { + public IList<string> Extensions { get; } } public class CookieOptions { + public CookieOptions(CookieOptions options); + public IList<string> Extensions { get; } + public SetCookieHeaderValue CreateCookieHeader(string name, string value); } + public sealed class DefaultEndpointFilterInvocationContext : EndpointFilterInvocationContext { + public DefaultEndpointFilterInvocationContext(HttpContext httpContext, params object[] arguments); + public override IList<object?> Arguments { get; } + public override HttpContext HttpContext { get; } + public override T GetArgument<T>(int index); + } + public sealed class EndpointDescriptionAttribute : Attribute, IEndpointDescriptionMetadata { + public EndpointDescriptionAttribute(string description); + public string Description { get; } + } + public delegate ValueTask<object?> EndpointFilterDelegate(EndpointFilterInvocationContext context); + public static class EndpointFilterExtensions { + public static TBuilder AddEndpointFilter<TBuilder, TFilterType>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder where TFilterType : IEndpointFilter; + public static TBuilder AddEndpointFilter<TBuilder>(this TBuilder builder, IEndpointFilter filter) where TBuilder : IEndpointConventionBuilder; + public static TBuilder AddEndpointFilter<TBuilder>(this TBuilder builder, Func<EndpointFilterInvocationContext, EndpointFilterDelegate, ValueTask<object?>> routeHandlerFilter) where TBuilder : IEndpointConventionBuilder; + public static RouteHandlerBuilder AddEndpointFilter<TFilterType>(this RouteHandlerBuilder builder) where TFilterType : IEndpointFilter; + public static RouteGroupBuilder AddEndpointFilter<TFilterType>(this RouteGroupBuilder builder) where TFilterType : IEndpointFilter; + public static TBuilder AddEndpointFilterFactory<TBuilder>(this TBuilder builder, Func<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate> filterFactory) where TBuilder : IEndpointConventionBuilder; + } + public sealed class EndpointFilterFactoryContext { + public EndpointFilterFactoryContext(); + public IServiceProvider ApplicationServices { get; set; } + public required MethodInfo MethodInfo { get; set; } + } + public abstract class EndpointFilterInvocationContext { + protected EndpointFilterInvocationContext(); + public abstract IList<object?> Arguments { get; } + public abstract HttpContext HttpContext { get; } + public abstract T GetArgument<T>(int index); + } public sealed class EndpointMetadataCollection : IEnumerable, IEnumerable<object>, IReadOnlyCollection<object>, IReadOnlyList<object> { + public T GetRequiredMetadata<T>() where T : class; - public struct Enumerator : IDisposable, IEnumerator, IEnumerator<object?> { + public struct Enumerator : IDisposable, IEnumerator, IEnumerator<object> { - public object? Current { get; } + public object Current { get; } } } + public sealed class EndpointSummaryAttribute : Attribute, IEndpointSummaryMetadata { + public EndpointSummaryAttribute(string summary); + public string Summary { get; } + } public static class HttpRequestJsonExtensions { public static ValueTask<object?> ReadFromJsonAsync(this HttpRequest request, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<object?> ReadFromJsonAsync(this HttpRequest request, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<object?> ReadFromJsonAsync(this HttpRequest request, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<TValue?> ReadFromJsonAsync<TValue>(this HttpRequest request, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<TValue?> ReadFromJsonAsync<TValue>(this HttpRequest request, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<TValue?> ReadFromJsonAsync<TValue>(this HttpRequest request, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class HttpResponse { - public abstract string ContentType { get; set; } + public abstract string? ContentType { get; set; } } public static class HttpResponseJsonExtensions { public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, JsonSerializerOptions? options, string? contentType, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, JsonSerializerContext context, string? contentType = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, JsonSerializerOptions? options, string? contentType, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, string? contentType = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, CancellationToken cancellationToken = default(CancellationToken)); } + public interface IBindableFromHttpContext<TSelf> where TSelf : class, IBindableFromHttpContext<TSelf> { + static abstract ValueTask<TSelf?> BindAsync(HttpContext context, ParameterInfo parameter); + } + public interface IContentTypeHttpResult { + string ContentType { get; } + } + public interface IEndpointFilter { + ValueTask<object?> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next); + } + public interface IFileHttpResult { + string ContentType { get; } + string FileDownloadName { get; } + } + public interface INestedHttpResult { + IResult Result { get; } + } + public interface IProblemDetailsService { + ValueTask WriteAsync(ProblemDetailsContext context); + } + public interface IProblemDetailsWriter { + bool CanWrite(ProblemDetailsContext context); + ValueTask WriteAsync(ProblemDetailsContext context); + } public interface IRequestCookieCollection : IEnumerable, IEnumerable<KeyValuePair<string, string>> { bool TryGetValue(string key, out string? value); } + public interface IStatusCodeHttpResult { + int? StatusCode { get; } + } + public interface IValueHttpResult { + object Value { get; } + } + public interface IValueHttpResult<out TValue> { + TValue Value { get; } + } public static class OpenApiRouteHandlerBuilderExtensions { + public static TBuilder ExcludeFromDescription<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder; + public static TBuilder WithDescription<TBuilder>(this TBuilder builder, string description) where TBuilder : IEndpointConventionBuilder; + public static TBuilder WithSummary<TBuilder>(this TBuilder builder, string summary) where TBuilder : IEndpointConventionBuilder; + public static TBuilder WithTags<TBuilder>(this TBuilder builder, params string[] tags) where TBuilder : IEndpointConventionBuilder; } + public sealed class ProblemDetailsContext { + public ProblemDetailsContext(); + public EndpointMetadataCollection? AdditionalMetadata { get; set; } + public required HttpContext HttpContext { get; set; } + public ProblemDetails ProblemDetails { get; set; } + } + public class ProblemDetailsOptions { + public ProblemDetailsOptions(); + public Action<ProblemDetailsContext>? CustomizeProblemDetails { get; set; } + } public static class RequestDelegateFactory { - public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions? options = null); + public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions? options); + public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions? options = null, RequestDelegateMetadataResult? metadataResult = null); - public static RequestDelegateResult Create(MethodInfo methodInfo, Func<HttpContext, object>? targetFactory = null, RequestDelegateFactoryOptions? options = null); + public static RequestDelegateResult Create(MethodInfo methodInfo, Func<HttpContext, object>? targetFactory, RequestDelegateFactoryOptions? options); + public static RequestDelegateResult Create(MethodInfo methodInfo, Func<HttpContext, object>? targetFactory = null, RequestDelegateFactoryOptions? options = null, RequestDelegateMetadataResult? metadataResult = null); + public static RequestDelegateMetadataResult InferMetadata(MethodInfo methodInfo, RequestDelegateFactoryOptions? options = null); } public sealed class RequestDelegateFactoryOptions { + public EndpointBuilder EndpointBuilder { get; set; } } + public sealed class RequestDelegateMetadataResult { + public RequestDelegateMetadataResult(); + public required IReadOnlyList<object> EndpointMetadata { get; set; } + } public static class Results { + public static IResult Empty { get; } - public static IResult Accepted(string? uri = null, object? value = null); + public static IResult Accepted(string uri = null, object value = null); + public static IResult Accepted<TValue>(string uri = null, TValue value = null); - public static IResult AcceptedAtRoute(string? routeName = null, object? routeValues = null, object? value = null); + public static IResult AcceptedAtRoute(string routeName = null, object routeValues = null, object value = null); + public static IResult AcceptedAtRoute<TValue>(string routeName = null, object routeValues = null, TValue value = null); + public static IResult BadRequest<TValue>(TValue error); - public static IResult Bytes(byte[] contents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null); + public static IResult Bytes(byte[] contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static IResult Bytes(ReadOnlyMemory<byte> contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static IResult Conflict<TValue>(TValue error); - public static IResult Content(string content, MediaTypeHeaderValue contentType); + public static IResult Content(string? content, MediaTypeHeaderValue contentType); - public static IResult Content(string content, string? contentType = null, Encoding? contentEncoding = null); + public static IResult Content(string content, string contentType, Encoding contentEncoding); + public static IResult Content(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static IResult Created<TValue>(string uri, TValue? value); + public static IResult Created<TValue>(Uri uri, TValue? value); - public static IResult CreatedAtRoute(string? routeName = null, object? routeValues = null, object? value = null); + public static IResult CreatedAtRoute(string routeName = null, object routeValues = null, object value = null); + public static IResult CreatedAtRoute<TValue>(string routeName = null, object routeValues = null, TValue value = null); - public static IResult File(byte[] fileContents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null); + public static IResult File(byte[] fileContents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); - public static IResult File(Stream fileStream, string? contentType = null, string? fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false); + public static IResult File(Stream fileStream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); - public static IResult File(string path, string? contentType = null, string? fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false); + public static IResult File(string path, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); - public static IResult Json(object? data, JsonSerializerOptions? options = null, string? contentType = null, int? statusCode = default(int?)); + public static IResult Json(object data, JsonSerializerOptions options = null, string contentType = null, int? statusCode = default(int?)); + public static IResult Json<TValue>(TValue data, JsonSerializerOptions options = null, string contentType = null, int? statusCode = default(int?)); + public static IResult NotFound<TValue>(TValue value); + public static IResult Ok<TValue>(TValue value); - public static IResult Problem(string? detail = null, string? instance = null, int? statusCode = default(int?), string? title = null, string? type = null, IDictionary<string, object?>? extensions = null); + public static IResult Problem(string detail = null, string instance = null, int? statusCode = default(int?), string title = null, string type = null, IDictionary<string, object?>? extensions = null); - public static IResult RedirectToRoute(string? routeName = null, object? routeValues = null, bool permanent = false, bool preserveMethod = false, string? fragment = null); + public static IResult RedirectToRoute(string routeName = null, object routeValues = null, bool permanent = false, bool preserveMethod = false, string fragment = null); + public static IResult Stream(Func<Stream, Task> streamWriterCallback, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static IResult Stream(PipeReader pipeReader, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); - public static IResult Stream(Stream stream, string? contentType = null, string? fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false); + public static IResult Stream(Stream stream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static IResult Text(ReadOnlySpan<byte> utf8Content, string? contentType = null, int? statusCode = default(int?)); - public static IResult Text(string content, string? contentType = null, Encoding? contentEncoding = null); + public static IResult Text(string content, string contentType, Encoding contentEncoding); + public static IResult Text(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static IResult UnprocessableEntity<TValue>(TValue error); - public static IResult ValidationProblem(IDictionary<string, string[]> errors, string? detail = null, string? instance = null, int? statusCode = default(int?), string? title = null, string? type = null, IDictionary<string, object?>? extensions = null); + public static IResult ValidationProblem(IDictionary<string, string[]> errors, string detail = null, string instance = null, int? statusCode = default(int?), string title = null, string type = null, IDictionary<string, object?>? extensions = null); } public class StreamResponseBodyFeature : IHttpResponseBodyFeature { - public StreamResponseBodyFeature(Stream stream, IHttpResponseBodyFeature priorFeature); + public StreamResponseBodyFeature(Stream stream, IHttpResponseBodyFeature? priorFeature); } + public static class TypedResults { + public static EmptyHttpResult Empty { get; } + public static Accepted Accepted(string? uri); + public static Accepted Accepted(Uri uri); + public static Accepted<TValue> Accepted<TValue>(string uri, TValue value); + public static Accepted<TValue> Accepted<TValue>(Uri uri, TValue? value); + public static AcceptedAtRoute AcceptedAtRoute(string routeName = null, object routeValues = null); + public static AcceptedAtRoute<TValue> AcceptedAtRoute<TValue>(TValue value, string routeName = null, object routeValues = null); + public static BadRequest BadRequest(); + public static BadRequest<TValue> BadRequest<TValue>(TValue error); + public static FileContentHttpResult Bytes(byte[] contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static FileContentHttpResult Bytes(ReadOnlyMemory<byte> contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static ChallengeHttpResult Challenge(AuthenticationProperties? properties = null, IList<string>? authenticationSchemes = null); + public static Conflict Conflict(); + public static Conflict<TValue> Conflict<TValue>(TValue error); + public static ContentHttpResult Content(string? content, MediaTypeHeaderValue contentType); + public static ContentHttpResult Content(string content, string contentType, Encoding contentEncoding); + public static ContentHttpResult Content(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static Created Created(string uri); + public static Created Created(Uri uri); + public static Created<TValue> Created<TValue>(string uri, TValue? value); + public static Created<TValue> Created<TValue>(Uri uri, TValue? value); + public static CreatedAtRoute CreatedAtRoute(string routeName = null, object routeValues = null); + public static CreatedAtRoute<TValue> CreatedAtRoute<TValue>(TValue value, string routeName = null, object routeValues = null); + public static FileContentHttpResult File(byte[] fileContents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static FileStreamHttpResult File(Stream fileStream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static ForbidHttpResult Forbid(AuthenticationProperties? properties = null, IList<string>? authenticationSchemes = null); + public static JsonHttpResult<TValue> Json<TValue>(TValue data, JsonSerializerOptions options = null, string contentType = null, int? statusCode = default(int?)); + public static RedirectHttpResult LocalRedirect(string localUrl, bool permanent = false, bool preserveMethod = false); + public static NoContent NoContent(); + public static NotFound NotFound(); + public static NotFound<TValue> NotFound<TValue>(TValue value); + public static Ok Ok(); + public static Ok<TValue> Ok<TValue>(TValue value); + public static PhysicalFileHttpResult PhysicalFile(string path, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static ProblemHttpResult Problem(ProblemDetails problemDetails); + public static ProblemHttpResult Problem(string detail = null, string instance = null, int? statusCode = default(int?), string title = null, string type = null, IDictionary<string, object?>? extensions = null); + public static RedirectHttpResult Redirect(string url, bool permanent = false, bool preserveMethod = false); + public static RedirectToRouteHttpResult RedirectToRoute(string routeName = null, object routeValues = null, bool permanent = false, bool preserveMethod = false, string fragment = null); + public static SignInHttpResult SignIn(ClaimsPrincipal principal, AuthenticationProperties? properties = null, string? authenticationScheme = null); + public static SignOutHttpResult SignOut(AuthenticationProperties? properties = null, IList<string>? authenticationSchemes = null); + public static StatusCodeHttpResult StatusCode(int statusCode); + public static PushStreamHttpResult Stream(Func<Stream, Task> streamWriterCallback, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static FileStreamHttpResult Stream(PipeReader pipeReader, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static FileStreamHttpResult Stream(Stream stream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static Utf8ContentHttpResult Text(ReadOnlySpan<byte> utf8Content, string? contentType = null, int? statusCode = default(int?)); + public static ContentHttpResult Text(string content, string contentType, Encoding contentEncoding); + public static ContentHttpResult Text(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static UnauthorizedHttpResult Unauthorized(); + public static UnprocessableEntity UnprocessableEntity(); + public static UnprocessableEntity<TValue> UnprocessableEntity<TValue>(TValue error); + public static ValidationProblem ValidationProblem(IDictionary<string, string[]> errors, string detail = null, string instance = null, string title = null, string type = null, IDictionary<string, object?>? extensions = null); + public static VirtualFileHttpResult VirtualFile(string path, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + } }","title":"Microsoft.AspNetCore.Http"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Http/#microsoftaspnetcorehttp","text":"namespace Microsoft.AspNetCore.Http { + public sealed class AsParametersAttribute : Attribute { + public AsParametersAttribute(); + } public class CookieBuilder { + public IList<string> Extensions { get; } } public class CookieOptions { + public CookieOptions(CookieOptions options); + public IList<string> Extensions { get; } + public SetCookieHeaderValue CreateCookieHeader(string name, string value); } + public sealed class DefaultEndpointFilterInvocationContext : EndpointFilterInvocationContext { + public DefaultEndpointFilterInvocationContext(HttpContext httpContext, params object[] arguments); + public override IList<object?> Arguments { get; } + public override HttpContext HttpContext { get; } + public override T GetArgument<T>(int index); + } + public sealed class EndpointDescriptionAttribute : Attribute, IEndpointDescriptionMetadata { + public EndpointDescriptionAttribute(string description); + public string Description { get; } + } + public delegate ValueTask<object?> EndpointFilterDelegate(EndpointFilterInvocationContext context); + public static class EndpointFilterExtensions { + public static TBuilder AddEndpointFilter<TBuilder, TFilterType>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder where TFilterType : IEndpointFilter; + public static TBuilder AddEndpointFilter<TBuilder>(this TBuilder builder, IEndpointFilter filter) where TBuilder : IEndpointConventionBuilder; + public static TBuilder AddEndpointFilter<TBuilder>(this TBuilder builder, Func<EndpointFilterInvocationContext, EndpointFilterDelegate, ValueTask<object?>> routeHandlerFilter) where TBuilder : IEndpointConventionBuilder; + public static RouteHandlerBuilder AddEndpointFilter<TFilterType>(this RouteHandlerBuilder builder) where TFilterType : IEndpointFilter; + public static RouteGroupBuilder AddEndpointFilter<TFilterType>(this RouteGroupBuilder builder) where TFilterType : IEndpointFilter; + public static TBuilder AddEndpointFilterFactory<TBuilder>(this TBuilder builder, Func<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate> filterFactory) where TBuilder : IEndpointConventionBuilder; + } + public sealed class EndpointFilterFactoryContext { + public EndpointFilterFactoryContext(); + public IServiceProvider ApplicationServices { get; set; } + public required MethodInfo MethodInfo { get; set; } + } + public abstract class EndpointFilterInvocationContext { + protected EndpointFilterInvocationContext(); + public abstract IList<object?> Arguments { get; } + public abstract HttpContext HttpContext { get; } + public abstract T GetArgument<T>(int index); + } public sealed class EndpointMetadataCollection : IEnumerable, IEnumerable<object>, IReadOnlyCollection<object>, IReadOnlyList<object> { + public T GetRequiredMetadata<T>() where T : class; - public struct Enumerator : IDisposable, IEnumerator, IEnumerator<object?> { + public struct Enumerator : IDisposable, IEnumerator, IEnumerator<object> { - public object? Current { get; } + public object Current { get; } } } + public sealed class EndpointSummaryAttribute : Attribute, IEndpointSummaryMetadata { + public EndpointSummaryAttribute(string summary); + public string Summary { get; } + } public static class HttpRequestJsonExtensions { public static ValueTask<object?> ReadFromJsonAsync(this HttpRequest request, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<object?> ReadFromJsonAsync(this HttpRequest request, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<object?> ReadFromJsonAsync(this HttpRequest request, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<TValue?> ReadFromJsonAsync<TValue>(this HttpRequest request, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<TValue?> ReadFromJsonAsync<TValue>(this HttpRequest request, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<TValue?> ReadFromJsonAsync<TValue>(this HttpRequest request, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class HttpResponse { - public abstract string ContentType { get; set; } + public abstract string? ContentType { get; set; } } public static class HttpResponseJsonExtensions { public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, JsonSerializerOptions? options, string? contentType, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, JsonSerializerContext context, string? contentType = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync(this HttpResponse response, object? value, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, JsonSerializerOptions? options, string? contentType, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, string? contentType = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task WriteAsJsonAsync<TValue>(this HttpResponse response, TValue value, CancellationToken cancellationToken = default(CancellationToken)); } + public interface IBindableFromHttpContext<TSelf> where TSelf : class, IBindableFromHttpContext<TSelf> { + static abstract ValueTask<TSelf?> BindAsync(HttpContext context, ParameterInfo parameter); + } + public interface IContentTypeHttpResult { + string ContentType { get; } + } + public interface IEndpointFilter { + ValueTask<object?> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next); + } + public interface IFileHttpResult { + string ContentType { get; } + string FileDownloadName { get; } + } + public interface INestedHttpResult { + IResult Result { get; } + } + public interface IProblemDetailsService { + ValueTask WriteAsync(ProblemDetailsContext context); + } + public interface IProblemDetailsWriter { + bool CanWrite(ProblemDetailsContext context); + ValueTask WriteAsync(ProblemDetailsContext context); + } public interface IRequestCookieCollection : IEnumerable, IEnumerable<KeyValuePair<string, string>> { bool TryGetValue(string key, out string? value); } + public interface IStatusCodeHttpResult { + int? StatusCode { get; } + } + public interface IValueHttpResult { + object Value { get; } + } + public interface IValueHttpResult<out TValue> { + TValue Value { get; } + } public static class OpenApiRouteHandlerBuilderExtensions { + public static TBuilder ExcludeFromDescription<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder; + public static TBuilder WithDescription<TBuilder>(this TBuilder builder, string description) where TBuilder : IEndpointConventionBuilder; + public static TBuilder WithSummary<TBuilder>(this TBuilder builder, string summary) where TBuilder : IEndpointConventionBuilder; + public static TBuilder WithTags<TBuilder>(this TBuilder builder, params string[] tags) where TBuilder : IEndpointConventionBuilder; } + public sealed class ProblemDetailsContext { + public ProblemDetailsContext(); + public EndpointMetadataCollection? AdditionalMetadata { get; set; } + public required HttpContext HttpContext { get; set; } + public ProblemDetails ProblemDetails { get; set; } + } + public class ProblemDetailsOptions { + public ProblemDetailsOptions(); + public Action<ProblemDetailsContext>? CustomizeProblemDetails { get; set; } + } public static class RequestDelegateFactory { - public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions? options = null); + public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions? options); + public static RequestDelegateResult Create(Delegate handler, RequestDelegateFactoryOptions? options = null, RequestDelegateMetadataResult? metadataResult = null); - public static RequestDelegateResult Create(MethodInfo methodInfo, Func<HttpContext, object>? targetFactory = null, RequestDelegateFactoryOptions? options = null); + public static RequestDelegateResult Create(MethodInfo methodInfo, Func<HttpContext, object>? targetFactory, RequestDelegateFactoryOptions? options); + public static RequestDelegateResult Create(MethodInfo methodInfo, Func<HttpContext, object>? targetFactory = null, RequestDelegateFactoryOptions? options = null, RequestDelegateMetadataResult? metadataResult = null); + public static RequestDelegateMetadataResult InferMetadata(MethodInfo methodInfo, RequestDelegateFactoryOptions? options = null); } public sealed class RequestDelegateFactoryOptions { + public EndpointBuilder EndpointBuilder { get; set; } } + public sealed class RequestDelegateMetadataResult { + public RequestDelegateMetadataResult(); + public required IReadOnlyList<object> EndpointMetadata { get; set; } + } public static class Results { + public static IResult Empty { get; } - public static IResult Accepted(string? uri = null, object? value = null); + public static IResult Accepted(string uri = null, object value = null); + public static IResult Accepted<TValue>(string uri = null, TValue value = null); - public static IResult AcceptedAtRoute(string? routeName = null, object? routeValues = null, object? value = null); + public static IResult AcceptedAtRoute(string routeName = null, object routeValues = null, object value = null); + public static IResult AcceptedAtRoute<TValue>(string routeName = null, object routeValues = null, TValue value = null); + public static IResult BadRequest<TValue>(TValue error); - public static IResult Bytes(byte[] contents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null); + public static IResult Bytes(byte[] contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static IResult Bytes(ReadOnlyMemory<byte> contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static IResult Conflict<TValue>(TValue error); - public static IResult Content(string content, MediaTypeHeaderValue contentType); + public static IResult Content(string? content, MediaTypeHeaderValue contentType); - public static IResult Content(string content, string? contentType = null, Encoding? contentEncoding = null); + public static IResult Content(string content, string contentType, Encoding contentEncoding); + public static IResult Content(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static IResult Created<TValue>(string uri, TValue? value); + public static IResult Created<TValue>(Uri uri, TValue? value); - public static IResult CreatedAtRoute(string? routeName = null, object? routeValues = null, object? value = null); + public static IResult CreatedAtRoute(string routeName = null, object routeValues = null, object value = null); + public static IResult CreatedAtRoute<TValue>(string routeName = null, object routeValues = null, TValue value = null); - public static IResult File(byte[] fileContents, string? contentType = null, string? fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null); + public static IResult File(byte[] fileContents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); - public static IResult File(Stream fileStream, string? contentType = null, string? fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false); + public static IResult File(Stream fileStream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); - public static IResult File(string path, string? contentType = null, string? fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false); + public static IResult File(string path, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); - public static IResult Json(object? data, JsonSerializerOptions? options = null, string? contentType = null, int? statusCode = default(int?)); + public static IResult Json(object data, JsonSerializerOptions options = null, string contentType = null, int? statusCode = default(int?)); + public static IResult Json<TValue>(TValue data, JsonSerializerOptions options = null, string contentType = null, int? statusCode = default(int?)); + public static IResult NotFound<TValue>(TValue value); + public static IResult Ok<TValue>(TValue value); - public static IResult Problem(string? detail = null, string? instance = null, int? statusCode = default(int?), string? title = null, string? type = null, IDictionary<string, object?>? extensions = null); + public static IResult Problem(string detail = null, string instance = null, int? statusCode = default(int?), string title = null, string type = null, IDictionary<string, object?>? extensions = null); - public static IResult RedirectToRoute(string? routeName = null, object? routeValues = null, bool permanent = false, bool preserveMethod = false, string? fragment = null); + public static IResult RedirectToRoute(string routeName = null, object routeValues = null, bool permanent = false, bool preserveMethod = false, string fragment = null); + public static IResult Stream(Func<Stream, Task> streamWriterCallback, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static IResult Stream(PipeReader pipeReader, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); - public static IResult Stream(Stream stream, string? contentType = null, string? fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue? entityTag = null, bool enableRangeProcessing = false); + public static IResult Stream(Stream stream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static IResult Text(ReadOnlySpan<byte> utf8Content, string? contentType = null, int? statusCode = default(int?)); - public static IResult Text(string content, string? contentType = null, Encoding? contentEncoding = null); + public static IResult Text(string content, string contentType, Encoding contentEncoding); + public static IResult Text(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static IResult UnprocessableEntity<TValue>(TValue error); - public static IResult ValidationProblem(IDictionary<string, string[]> errors, string? detail = null, string? instance = null, int? statusCode = default(int?), string? title = null, string? type = null, IDictionary<string, object?>? extensions = null); + public static IResult ValidationProblem(IDictionary<string, string[]> errors, string detail = null, string instance = null, int? statusCode = default(int?), string title = null, string type = null, IDictionary<string, object?>? extensions = null); } public class StreamResponseBodyFeature : IHttpResponseBodyFeature { - public StreamResponseBodyFeature(Stream stream, IHttpResponseBodyFeature priorFeature); + public StreamResponseBodyFeature(Stream stream, IHttpResponseBodyFeature? priorFeature); } + public static class TypedResults { + public static EmptyHttpResult Empty { get; } + public static Accepted Accepted(string? uri); + public static Accepted Accepted(Uri uri); + public static Accepted<TValue> Accepted<TValue>(string uri, TValue value); + public static Accepted<TValue> Accepted<TValue>(Uri uri, TValue? value); + public static AcceptedAtRoute AcceptedAtRoute(string routeName = null, object routeValues = null); + public static AcceptedAtRoute<TValue> AcceptedAtRoute<TValue>(TValue value, string routeName = null, object routeValues = null); + public static BadRequest BadRequest(); + public static BadRequest<TValue> BadRequest<TValue>(TValue error); + public static FileContentHttpResult Bytes(byte[] contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static FileContentHttpResult Bytes(ReadOnlyMemory<byte> contents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static ChallengeHttpResult Challenge(AuthenticationProperties? properties = null, IList<string>? authenticationSchemes = null); + public static Conflict Conflict(); + public static Conflict<TValue> Conflict<TValue>(TValue error); + public static ContentHttpResult Content(string? content, MediaTypeHeaderValue contentType); + public static ContentHttpResult Content(string content, string contentType, Encoding contentEncoding); + public static ContentHttpResult Content(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static Created Created(string uri); + public static Created Created(Uri uri); + public static Created<TValue> Created<TValue>(string uri, TValue? value); + public static Created<TValue> Created<TValue>(Uri uri, TValue? value); + public static CreatedAtRoute CreatedAtRoute(string routeName = null, object routeValues = null); + public static CreatedAtRoute<TValue> CreatedAtRoute<TValue>(TValue value, string routeName = null, object routeValues = null); + public static FileContentHttpResult File(byte[] fileContents, string contentType = null, string fileDownloadName = null, bool enableRangeProcessing = false, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static FileStreamHttpResult File(Stream fileStream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static ForbidHttpResult Forbid(AuthenticationProperties? properties = null, IList<string>? authenticationSchemes = null); + public static JsonHttpResult<TValue> Json<TValue>(TValue data, JsonSerializerOptions options = null, string contentType = null, int? statusCode = default(int?)); + public static RedirectHttpResult LocalRedirect(string localUrl, bool permanent = false, bool preserveMethod = false); + public static NoContent NoContent(); + public static NotFound NotFound(); + public static NotFound<TValue> NotFound<TValue>(TValue value); + public static Ok Ok(); + public static Ok<TValue> Ok<TValue>(TValue value); + public static PhysicalFileHttpResult PhysicalFile(string path, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static ProblemHttpResult Problem(ProblemDetails problemDetails); + public static ProblemHttpResult Problem(string detail = null, string instance = null, int? statusCode = default(int?), string title = null, string type = null, IDictionary<string, object?>? extensions = null); + public static RedirectHttpResult Redirect(string url, bool permanent = false, bool preserveMethod = false); + public static RedirectToRouteHttpResult RedirectToRoute(string routeName = null, object routeValues = null, bool permanent = false, bool preserveMethod = false, string fragment = null); + public static SignInHttpResult SignIn(ClaimsPrincipal principal, AuthenticationProperties? properties = null, string? authenticationScheme = null); + public static SignOutHttpResult SignOut(AuthenticationProperties? properties = null, IList<string>? authenticationSchemes = null); + public static StatusCodeHttpResult StatusCode(int statusCode); + public static PushStreamHttpResult Stream(Func<Stream, Task> streamWriterCallback, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null); + public static FileStreamHttpResult Stream(PipeReader pipeReader, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static FileStreamHttpResult Stream(Stream stream, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + public static Utf8ContentHttpResult Text(ReadOnlySpan<byte> utf8Content, string? contentType = null, int? statusCode = default(int?)); + public static ContentHttpResult Text(string content, string contentType, Encoding contentEncoding); + public static ContentHttpResult Text(string content, string contentType = null, Encoding contentEncoding = null, int? statusCode = default(int?)); + public static UnauthorizedHttpResult Unauthorized(); + public static UnprocessableEntity UnprocessableEntity(); + public static UnprocessableEntity<TValue> UnprocessableEntity<TValue>(TValue error); + public static ValidationProblem ValidationProblem(IDictionary<string, string[]> errors, string detail = null, string instance = null, string title = null, string type = null, IDictionary<string, object?>? extensions = null); + public static VirtualFileHttpResult VirtualFile(string path, string contentType = null, string fileDownloadName = null, DateTimeOffset? lastModified = default(DateTimeOffset?), EntityTagHeaderValue entityTag = null, bool enableRangeProcessing = false); + } }","title":"Microsoft.AspNetCore.Http"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.HttpLogging/","text":"Microsoft.AspNetCore.HttpLogging namespace Microsoft.AspNetCore.HttpLogging { public sealed class W3CLoggerOptions { + public ISet<string> AdditionalRequestHeaders { get; } } }","title":"Microsoft.AspNetCore.HttpLogging"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.HttpLogging/#microsoftaspnetcorehttplogging","text":"namespace Microsoft.AspNetCore.HttpLogging { public sealed class W3CLoggerOptions { + public ISet<string> AdditionalRequestHeaders { get; } } }","title":"Microsoft.AspNetCore.HttpLogging"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Identity/","text":"Microsoft.AspNetCore.Identity namespace Microsoft.AspNetCore.Identity { public class DefaultPersonalDataProtector : IPersonalDataProtector { - public virtual string Protect(string data); + public virtual string? Protect(string? data); - public virtual string Unprotect(string data); + public virtual string? Unprotect(string? data); } public class ExternalLoginInfo : UserLoginInfo { - public AuthenticationProperties AuthenticationProperties { get; set; } + public AuthenticationProperties? AuthenticationProperties { get; set; } - public IEnumerable<AuthenticationToken> AuthenticationTokens { get; set; } + public IEnumerable<AuthenticationToken>? AuthenticationTokens { get; set; } } public class IdentityBuilder { public IdentityBuilder(Type user, Type role, IServiceCollection services); - public Type RoleType { get; } + public Type? RoleType { get; } public virtual IdentityBuilder AddTokenProvider(string providerName, Type provider); } public class IdentityCookiesBuilder { - public OptionsBuilder<CookieAuthenticationOptions> ApplicationCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? ApplicationCookie { get; set; } - public OptionsBuilder<CookieAuthenticationOptions> ExternalCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? ExternalCookie { get; set; } - public OptionsBuilder<CookieAuthenticationOptions> TwoFactorRememberMeCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? TwoFactorRememberMeCookie { get; set; } - public OptionsBuilder<CookieAuthenticationOptions> TwoFactorUserIdCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? TwoFactorUserIdCookie { get; set; } } public class IdentityErrorDescriber { - public virtual IdentityError InvalidEmail(string email); + public virtual IdentityError InvalidEmail(string? email); - public virtual IdentityError InvalidRoleName(string role); + public virtual IdentityError InvalidRoleName(string? role); - public virtual IdentityError InvalidUserName(string userName); + public virtual IdentityError InvalidUserName(string? userName); } public class IdentityUserClaim<TKey> where TKey : IEquatable<TKey> { - public virtual string ClaimType { get; set; } + public virtual string? ClaimType { get; set; } - public virtual string ClaimValue { get; set; } + public virtual string? ClaimValue { get; set; } } public class IdentityUserLogin<TKey> where TKey : IEquatable<TKey> { - public virtual string ProviderDisplayName { get; set; } + public virtual string? ProviderDisplayName { get; set; } } public class IdentityUserToken<TKey> where TKey : IEquatable<TKey> { - public virtual string Value { get; set; } + public virtual string? Value { get; set; } } public interface ILookupNormalizer { string NormalizeEmail(string email); string NormalizeName(string name); } public interface ILookupProtector { string Protect(string keyId, string data); string Unprotect(string keyId, string data); } public interface IPasswordValidator<TUser> where TUser : class { - Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string password); + Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string? password); } public interface IPersonalDataProtector { string Protect(string data); string Unprotect(string data); } public interface IRoleStore<TRole> : IDisposable where TRole : class { - Task<TRole> FindByIdAsync(string roleId, CancellationToken cancellationToken); + Task<TRole?> FindByIdAsync(string roleId, CancellationToken cancellationToken); - Task<TRole> FindByNameAsync(string normalizedRoleName, CancellationToken cancellationToken); + Task<TRole?> FindByNameAsync(string normalizedRoleName, CancellationToken cancellationToken); - Task<string> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken); + Task<string?> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken); - Task<string> GetRoleNameAsync(TRole role, CancellationToken cancellationToken); + Task<string?> GetRoleNameAsync(TRole role, CancellationToken cancellationToken); - Task SetNormalizedRoleNameAsync(TRole role, string normalizedName, CancellationToken cancellationToken); + Task SetNormalizedRoleNameAsync(TRole role, string? normalizedName, CancellationToken cancellationToken); - Task SetRoleNameAsync(TRole role, string roleName, CancellationToken cancellationToken); + Task SetRoleNameAsync(TRole role, string? roleName, CancellationToken cancellationToken); } public interface IUserAuthenticationTokenStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); + Task<string?> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); - Task SetTokenAsync(TUser user, string loginProvider, string name, string value, CancellationToken cancellationToken); + Task SetTokenAsync(TUser user, string loginProvider, string name, string? value, CancellationToken cancellationToken); } public interface IUserAuthenticatorKeyStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); } public interface IUserEmailStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<TUser> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken); + Task<TUser?> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken); - Task<string> GetEmailAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetEmailAsync(TUser user, CancellationToken cancellationToken); - Task<string> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken); - Task SetEmailAsync(TUser user, string email, CancellationToken cancellationToken); + Task SetEmailAsync(TUser user, string? email, CancellationToken cancellationToken); - Task SetNormalizedEmailAsync(TUser user, string normalizedEmail, CancellationToken cancellationToken); + Task SetNormalizedEmailAsync(TUser user, string? normalizedEmail, CancellationToken cancellationToken); } public interface IUserLoginStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<TUser> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); + Task<TUser?> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); } public interface IUserPasswordStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken); - Task SetPasswordHashAsync(TUser user, string passwordHash, CancellationToken cancellationToken); + Task SetPasswordHashAsync(TUser user, string? passwordHash, CancellationToken cancellationToken); } public interface IUserPhoneNumberStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken); - Task SetPhoneNumberAsync(TUser user, string phoneNumber, CancellationToken cancellationToken); + Task SetPhoneNumberAsync(TUser user, string? phoneNumber, CancellationToken cancellationToken); } public interface IUserSecurityStampStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken); } public interface IUserStore<TUser> : IDisposable where TUser : class { - Task<TUser> FindByIdAsync(string userId, CancellationToken cancellationToken); + Task<TUser?> FindByIdAsync(string userId, CancellationToken cancellationToken); - Task<TUser> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken); + Task<TUser?> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken); - Task<string> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken); - Task<string> GetUserNameAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetUserNameAsync(TUser user, CancellationToken cancellationToken); - Task SetNormalizedUserNameAsync(TUser user, string normalizedName, CancellationToken cancellationToken); + Task SetNormalizedUserNameAsync(TUser user, string? normalizedName, CancellationToken cancellationToken); - Task SetUserNameAsync(TUser user, string userName, CancellationToken cancellationToken); + Task SetUserNameAsync(TUser user, string? userName, CancellationToken cancellationToken); } public class PasswordHasher<TUser> : IPasswordHasher<TUser> where TUser : class { - public PasswordHasher(IOptions<PasswordHasherOptions> optionsAccessor = null); + public PasswordHasher(IOptions<PasswordHasherOptions>? optionsAccessor = null); } public class PasswordValidator<TUser> : IPasswordValidator<TUser> where TUser : class { - public PasswordValidator(IdentityErrorDescriber errors = null); + public PasswordValidator(IdentityErrorDescriber? errors = null); - public virtual Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string password); + public virtual Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string? password); } public class PersonalDataAttribute : Attribute public class RoleManager<TRole> : IDisposable where TRole : class { - public virtual Task<TRole> FindByIdAsync(string roleId); + public virtual Task<TRole?> FindByIdAsync(string roleId); - public virtual Task<TRole> FindByNameAsync(string roleName); + public virtual Task<TRole?> FindByNameAsync(string roleName); - public virtual Task<string> GetRoleNameAsync(TRole role); + public virtual Task<string?> GetRoleNameAsync(TRole role); - public virtual string NormalizeKey(string key); + public virtual string? NormalizeKey(string? key); - public virtual Task<IdentityResult> SetRoleNameAsync(TRole role, string name); + public virtual Task<IdentityResult> SetRoleNameAsync(TRole role, string? name); } public abstract class RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim> : IDisposable, IQueryableRoleStore<TRole>, IRoleClaimStore<TRole>, IRoleStore<TRole> where TRole : IdentityRole<TKey> where TKey : IEquatable<TKey> where TUserRole : IdentityUserRole<TKey>, new() where TRoleClaim : IdentityRoleClaim<TKey>, new() { - public virtual TKey ConvertIdFromString(string id); + public virtual TKey? ConvertIdFromString(string? id); - public virtual string ConvertIdToString(TKey id); + public virtual string? ConvertIdToString(TKey id); - public abstract Task<TRole> FindByIdAsync(string id, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TRole?> FindByIdAsync(string id, CancellationToken cancellationToken = default(CancellationToken)); - public abstract Task<TRole> FindByNameAsync(string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TRole?> FindByNameAsync(string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetNormalizedRoleNameAsync(TRole role, string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetNormalizedRoleNameAsync(TRole role, string? normalizedName, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetRoleNameAsync(TRole role, string roleName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetRoleNameAsync(TRole role, string? roleName, CancellationToken cancellationToken = default(CancellationToken)); } public class RoleValidator<TRole> : IRoleValidator<TRole> where TRole : class { - public RoleValidator(IdentityErrorDescriber errors = null); + public RoleValidator(IdentityErrorDescriber? errors = null); } public class SecurityStampValidator<TUser> : ISecurityStampValidator where TUser : class { - protected virtual Task<TUser> VerifySecurityStamp(ClaimsPrincipal principal); + protected virtual Task<TUser?> VerifySecurityStamp(ClaimsPrincipal? principal); } public class SecurityStampValidatorOptions { - public Func<SecurityStampRefreshingPrincipalContext, Task> OnRefreshingPrincipal { get; set; } + public Func<SecurityStampRefreshingPrincipalContext, Task>? OnRefreshingPrincipal { get; set; } } public class SignInManager<TUser> where TUser : class { - public virtual AuthenticationProperties ConfigureExternalAuthenticationProperties(string provider, string redirectUrl, string userId = null); + public virtual AuthenticationProperties ConfigureExternalAuthenticationProperties(string? provider, string? redirectUrl, string? userId = null); - public virtual Task<ExternalLoginInfo> GetExternalLoginInfoAsync(string expectedXsrf = null); + public virtual Task<ExternalLoginInfo?> GetExternalLoginInfoAsync(string? expectedXsrf = null); - public virtual Task<TUser> GetTwoFactorAuthenticationUserAsync(); + public virtual Task<TUser?> GetTwoFactorAuthenticationUserAsync(); - protected virtual Task<SignInResult> PreSignInCheck(TUser user); + protected virtual Task<SignInResult?> PreSignInCheck(TUser user); - public virtual Task SignInAsync(TUser user, AuthenticationProperties authenticationProperties, string authenticationMethod = null); + public virtual Task SignInAsync(TUser user, AuthenticationProperties authenticationProperties, string? authenticationMethod = null); - public virtual Task SignInAsync(TUser user, bool isPersistent, string authenticationMethod = null); + public virtual Task SignInAsync(TUser user, bool isPersistent, string? authenticationMethod = null); - protected virtual Task<SignInResult> SignInOrTwoFactorAsync(TUser user, bool isPersistent, string loginProvider = null, bool bypassTwoFactor = false); + protected virtual Task<SignInResult> SignInOrTwoFactorAsync(TUser user, bool isPersistent, string? loginProvider = null, bool bypassTwoFactor = false); - public virtual Task SignInWithClaimsAsync(TUser user, AuthenticationProperties authenticationProperties, IEnumerable<Claim> additionalClaims); + public virtual Task SignInWithClaimsAsync(TUser user, AuthenticationProperties? authenticationProperties, IEnumerable<Claim> additionalClaims); - public virtual Task<TUser> ValidateSecurityStampAsync(ClaimsPrincipal principal); + public virtual Task<TUser?> ValidateSecurityStampAsync(ClaimsPrincipal? principal); - public virtual Task<bool> ValidateSecurityStampAsync(TUser user, string securityStamp); + public virtual Task<bool> ValidateSecurityStampAsync(TUser? user, string? securityStamp); - public virtual Task<TUser> ValidateTwoFactorSecurityStampAsync(ClaimsPrincipal principal); + public virtual Task<TUser?> ValidateTwoFactorSecurityStampAsync(ClaimsPrincipal? principal); } public class TokenProviderDescriptor { - public object ProviderInstance { get; set; } + public object? ProviderInstance { get; set; } } public class TwoFactorSecurityStampValidator<TUser> : SecurityStampValidator<TUser>, ISecurityStampValidator, ITwoFactorSecurityStampValidator where TUser : class { - protected override Task<TUser> VerifySecurityStamp(ClaimsPrincipal principal); + protected override Task<TUser?> VerifySecurityStamp(ClaimsPrincipal? principal); } public sealed class UpperInvariantLookupNormalizer : ILookupNormalizer { - public string NormalizeEmail(string email); + public string? NormalizeEmail(string? email); - public string NormalizeName(string name); + public string? NormalizeName(string? name); } public class UserLoginInfo { - public UserLoginInfo(string loginProvider, string providerKey, string displayName); + public UserLoginInfo(string loginProvider, string providerKey, string? displayName); - public string ProviderDisplayName { get; set; } + public string? ProviderDisplayName { get; set; } } public class UserManager<TUser> : IDisposable where TUser : class { public virtual Task<byte[]> CreateSecurityTokenAsync(TUser user); - public virtual Task<TUser> FindByEmailAsync(string email); + public virtual Task<TUser?> FindByEmailAsync(string email); - public virtual Task<TUser> FindByIdAsync(string userId); + public virtual Task<TUser?> FindByIdAsync(string userId); - public virtual Task<TUser> FindByLoginAsync(string loginProvider, string providerKey); + public virtual Task<TUser?> FindByLoginAsync(string loginProvider, string providerKey); - public virtual Task<TUser> FindByNameAsync(string userName); + public virtual Task<TUser?> FindByNameAsync(string userName); - public virtual Task<IEnumerable<string>> GenerateNewTwoFactorRecoveryCodesAsync(TUser user, int number); + public virtual Task<IEnumerable<string>?> GenerateNewTwoFactorRecoveryCodesAsync(TUser user, int number); - public virtual Task<string> GetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName); + public virtual Task<string?> GetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName); - public virtual Task<string> GetAuthenticatorKeyAsync(TUser user); + public virtual Task<string?> GetAuthenticatorKeyAsync(TUser user); - public virtual Task<string> GetEmailAsync(TUser user); + public virtual Task<string?> GetEmailAsync(TUser user); - public virtual Task<string> GetPhoneNumberAsync(TUser user); + public virtual Task<string?> GetPhoneNumberAsync(TUser user); - public virtual Task<TUser> GetUserAsync(ClaimsPrincipal principal); + public virtual Task<TUser?> GetUserAsync(ClaimsPrincipal principal); - public virtual string GetUserId(ClaimsPrincipal principal); + public virtual string? GetUserId(ClaimsPrincipal principal); - public virtual string GetUserName(ClaimsPrincipal principal); + public virtual string? GetUserName(ClaimsPrincipal principal); - public virtual Task<string> GetUserNameAsync(TUser user); + public virtual Task<string?> GetUserNameAsync(TUser user); - public virtual string NormalizeEmail(string email); + public virtual string? NormalizeEmail(string? email); - public virtual string NormalizeName(string name); + public virtual string? NormalizeName(string? name); public virtual Task<IdentityResult> RedeemTwoFactorRecoveryCodeAsync(TUser user, string code); - public virtual Task<IdentityResult> SetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName, string tokenValue); + public virtual Task<IdentityResult> SetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName, string? tokenValue); - public virtual Task<IdentityResult> SetEmailAsync(TUser user, string email); + public virtual Task<IdentityResult> SetEmailAsync(TUser user, string? email); - public virtual Task<IdentityResult> SetPhoneNumberAsync(TUser user, string phoneNumber); + public virtual Task<IdentityResult> SetPhoneNumberAsync(TUser user, string? phoneNumber); - public virtual Task<IdentityResult> SetUserNameAsync(TUser user, string userName); + public virtual Task<IdentityResult> SetUserNameAsync(TUser user, string? userName); protected virtual Task<IdentityResult> UpdateUserAsync(TUser user); - protected Task<IdentityResult> ValidatePasswordAsync(TUser user, string password); + protected Task<IdentityResult> ValidatePasswordAsync(TUser user, string? password); protected Task<IdentityResult> ValidateUserAsync(TUser user); } public abstract class UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken> : IDisposable, IQueryableUserStore<TUser>, IUserAuthenticationTokenStore<TUser>, IUserAuthenticatorKeyStore<TUser>, IUserClaimStore<TUser>, IUserEmailStore<TUser>, IUserLockoutStore<TUser>, IUserLoginStore<TUser>, IUserPasswordStore<TUser>, IUserPhoneNumberStore<TUser>, IUserSecurityStampStore<TUser>, IUserStore<TUser>, IUserTwoFactorRecoveryCodeStore<TUser>, IUserTwoFactorStore<TUser> where TUser : IdentityUser<TKey> where TKey : IEquatable<TKey> where TUserClaim : IdentityUserClaim<TKey>, new() where TUserLogin : IdentityUserLogin<TKey>, new() where TUserToken : IdentityUserToken<TKey>, new() { - public virtual TKey ConvertIdFromString(string id); + public virtual TKey? ConvertIdFromString(string? id); - public virtual string ConvertIdToString(TKey id); + public virtual string? ConvertIdToString(TKey id); - protected virtual TUserToken CreateUserToken(TUser user, string loginProvider, string name, string value); + protected virtual TUserToken CreateUserToken(TUser user, string loginProvider, string name, string? value); - public abstract Task<TUser> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TUser?> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); - public abstract Task<TUser> FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TUser?> FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<TUser> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<TUser?> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken = default(CancellationToken)); - public abstract Task<TUser> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TUser?> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken)); - protected abstract Task<TUserToken> FindTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); + protected abstract Task<TUserToken?> FindTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); - protected abstract Task<TUser> FindUserAsync(TKey userId, CancellationToken cancellationToken); + protected abstract Task<TUser?> FindUserAsync(TKey userId, CancellationToken cancellationToken); - protected abstract Task<TUserLogin> FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); + protected abstract Task<TUserLogin?> FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); - protected abstract Task<TUserLogin> FindUserLoginAsync(TKey userId, string loginProvider, string providerKey, CancellationToken cancellationToken); + protected abstract Task<TUserLogin?> FindUserLoginAsync(TKey userId, string loginProvider, string providerKey, CancellationToken cancellationToken); - public virtual Task<string> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); + public virtual Task<string?> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); - public virtual Task<string> GetEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); + public virtual Task<string?> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); - public virtual Task<string> GetUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetEmailAsync(TUser user, string email, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetEmailAsync(TUser user, string? email, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetNormalizedEmailAsync(TUser user, string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetNormalizedEmailAsync(TUser user, string? normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetNormalizedUserNameAsync(TUser user, string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetNormalizedUserNameAsync(TUser user, string? normalizedName, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetPasswordHashAsync(TUser user, string passwordHash, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetPasswordHashAsync(TUser user, string? passwordHash, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetPhoneNumberAsync(TUser user, string phoneNumber, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetPhoneNumberAsync(TUser user, string? phoneNumber, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetTokenAsync(TUser user, string loginProvider, string name, string value, CancellationToken cancellationToken); + public virtual Task SetTokenAsync(TUser user, string loginProvider, string name, string? value, CancellationToken cancellationToken); - public virtual Task SetUserNameAsync(TUser user, string userName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetUserNameAsync(TUser user, string? userName, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim> : UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>, IDisposable, IUserRoleStore<TUser>, IUserStore<TUser> where TUser : IdentityUser<TKey> where TRole : IdentityRole<TKey> where TKey : IEquatable<TKey> where TUserClaim : IdentityUserClaim<TKey>, new() where TUserRole : IdentityUserRole<TKey>, new() where TUserLogin : IdentityUserLogin<TKey>, new() where TUserToken : IdentityUserToken<TKey>, new() where TRoleClaim : IdentityRoleClaim<TKey>, new() { - protected abstract Task<TRole> FindRoleAsync(string normalizedRoleName, CancellationToken cancellationToken); + protected abstract Task<TRole?> FindRoleAsync(string normalizedRoleName, CancellationToken cancellationToken); - protected abstract Task<TUserRole> FindUserRoleAsync(TKey userId, TKey roleId, CancellationToken cancellationToken); + protected abstract Task<TUserRole?> FindUserRoleAsync(TKey userId, TKey roleId, CancellationToken cancellationToken); } public class UserValidator<TUser> : IUserValidator<TUser> where TUser : class { - public UserValidator(IdentityErrorDescriber errors = null); + public UserValidator(IdentityErrorDescriber? errors = null); } }","title":"Microsoft.AspNetCore.Identity"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Identity/#microsoftaspnetcoreidentity","text":"namespace Microsoft.AspNetCore.Identity { public class DefaultPersonalDataProtector : IPersonalDataProtector { - public virtual string Protect(string data); + public virtual string? Protect(string? data); - public virtual string Unprotect(string data); + public virtual string? Unprotect(string? data); } public class ExternalLoginInfo : UserLoginInfo { - public AuthenticationProperties AuthenticationProperties { get; set; } + public AuthenticationProperties? AuthenticationProperties { get; set; } - public IEnumerable<AuthenticationToken> AuthenticationTokens { get; set; } + public IEnumerable<AuthenticationToken>? AuthenticationTokens { get; set; } } public class IdentityBuilder { public IdentityBuilder(Type user, Type role, IServiceCollection services); - public Type RoleType { get; } + public Type? RoleType { get; } public virtual IdentityBuilder AddTokenProvider(string providerName, Type provider); } public class IdentityCookiesBuilder { - public OptionsBuilder<CookieAuthenticationOptions> ApplicationCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? ApplicationCookie { get; set; } - public OptionsBuilder<CookieAuthenticationOptions> ExternalCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? ExternalCookie { get; set; } - public OptionsBuilder<CookieAuthenticationOptions> TwoFactorRememberMeCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? TwoFactorRememberMeCookie { get; set; } - public OptionsBuilder<CookieAuthenticationOptions> TwoFactorUserIdCookie { get; set; } + public OptionsBuilder<CookieAuthenticationOptions>? TwoFactorUserIdCookie { get; set; } } public class IdentityErrorDescriber { - public virtual IdentityError InvalidEmail(string email); + public virtual IdentityError InvalidEmail(string? email); - public virtual IdentityError InvalidRoleName(string role); + public virtual IdentityError InvalidRoleName(string? role); - public virtual IdentityError InvalidUserName(string userName); + public virtual IdentityError InvalidUserName(string? userName); } public class IdentityUserClaim<TKey> where TKey : IEquatable<TKey> { - public virtual string ClaimType { get; set; } + public virtual string? ClaimType { get; set; } - public virtual string ClaimValue { get; set; } + public virtual string? ClaimValue { get; set; } } public class IdentityUserLogin<TKey> where TKey : IEquatable<TKey> { - public virtual string ProviderDisplayName { get; set; } + public virtual string? ProviderDisplayName { get; set; } } public class IdentityUserToken<TKey> where TKey : IEquatable<TKey> { - public virtual string Value { get; set; } + public virtual string? Value { get; set; } } public interface ILookupNormalizer { string NormalizeEmail(string email); string NormalizeName(string name); } public interface ILookupProtector { string Protect(string keyId, string data); string Unprotect(string keyId, string data); } public interface IPasswordValidator<TUser> where TUser : class { - Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string password); + Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string? password); } public interface IPersonalDataProtector { string Protect(string data); string Unprotect(string data); } public interface IRoleStore<TRole> : IDisposable where TRole : class { - Task<TRole> FindByIdAsync(string roleId, CancellationToken cancellationToken); + Task<TRole?> FindByIdAsync(string roleId, CancellationToken cancellationToken); - Task<TRole> FindByNameAsync(string normalizedRoleName, CancellationToken cancellationToken); + Task<TRole?> FindByNameAsync(string normalizedRoleName, CancellationToken cancellationToken); - Task<string> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken); + Task<string?> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken); - Task<string> GetRoleNameAsync(TRole role, CancellationToken cancellationToken); + Task<string?> GetRoleNameAsync(TRole role, CancellationToken cancellationToken); - Task SetNormalizedRoleNameAsync(TRole role, string normalizedName, CancellationToken cancellationToken); + Task SetNormalizedRoleNameAsync(TRole role, string? normalizedName, CancellationToken cancellationToken); - Task SetRoleNameAsync(TRole role, string roleName, CancellationToken cancellationToken); + Task SetRoleNameAsync(TRole role, string? roleName, CancellationToken cancellationToken); } public interface IUserAuthenticationTokenStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); + Task<string?> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); - Task SetTokenAsync(TUser user, string loginProvider, string name, string value, CancellationToken cancellationToken); + Task SetTokenAsync(TUser user, string loginProvider, string name, string? value, CancellationToken cancellationToken); } public interface IUserAuthenticatorKeyStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); } public interface IUserEmailStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<TUser> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken); + Task<TUser?> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken); - Task<string> GetEmailAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetEmailAsync(TUser user, CancellationToken cancellationToken); - Task<string> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken); - Task SetEmailAsync(TUser user, string email, CancellationToken cancellationToken); + Task SetEmailAsync(TUser user, string? email, CancellationToken cancellationToken); - Task SetNormalizedEmailAsync(TUser user, string normalizedEmail, CancellationToken cancellationToken); + Task SetNormalizedEmailAsync(TUser user, string? normalizedEmail, CancellationToken cancellationToken); } public interface IUserLoginStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<TUser> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); + Task<TUser?> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); } public interface IUserPasswordStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken); - Task SetPasswordHashAsync(TUser user, string passwordHash, CancellationToken cancellationToken); + Task SetPasswordHashAsync(TUser user, string? passwordHash, CancellationToken cancellationToken); } public interface IUserPhoneNumberStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken); - Task SetPhoneNumberAsync(TUser user, string phoneNumber, CancellationToken cancellationToken); + Task SetPhoneNumberAsync(TUser user, string? phoneNumber, CancellationToken cancellationToken); } public interface IUserSecurityStampStore<TUser> : IDisposable, IUserStore<TUser> where TUser : class { - Task<string> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken); } public interface IUserStore<TUser> : IDisposable where TUser : class { - Task<TUser> FindByIdAsync(string userId, CancellationToken cancellationToken); + Task<TUser?> FindByIdAsync(string userId, CancellationToken cancellationToken); - Task<TUser> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken); + Task<TUser?> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken); - Task<string> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken); - Task<string> GetUserNameAsync(TUser user, CancellationToken cancellationToken); + Task<string?> GetUserNameAsync(TUser user, CancellationToken cancellationToken); - Task SetNormalizedUserNameAsync(TUser user, string normalizedName, CancellationToken cancellationToken); + Task SetNormalizedUserNameAsync(TUser user, string? normalizedName, CancellationToken cancellationToken); - Task SetUserNameAsync(TUser user, string userName, CancellationToken cancellationToken); + Task SetUserNameAsync(TUser user, string? userName, CancellationToken cancellationToken); } public class PasswordHasher<TUser> : IPasswordHasher<TUser> where TUser : class { - public PasswordHasher(IOptions<PasswordHasherOptions> optionsAccessor = null); + public PasswordHasher(IOptions<PasswordHasherOptions>? optionsAccessor = null); } public class PasswordValidator<TUser> : IPasswordValidator<TUser> where TUser : class { - public PasswordValidator(IdentityErrorDescriber errors = null); + public PasswordValidator(IdentityErrorDescriber? errors = null); - public virtual Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string password); + public virtual Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user, string? password); } public class PersonalDataAttribute : Attribute public class RoleManager<TRole> : IDisposable where TRole : class { - public virtual Task<TRole> FindByIdAsync(string roleId); + public virtual Task<TRole?> FindByIdAsync(string roleId); - public virtual Task<TRole> FindByNameAsync(string roleName); + public virtual Task<TRole?> FindByNameAsync(string roleName); - public virtual Task<string> GetRoleNameAsync(TRole role); + public virtual Task<string?> GetRoleNameAsync(TRole role); - public virtual string NormalizeKey(string key); + public virtual string? NormalizeKey(string? key); - public virtual Task<IdentityResult> SetRoleNameAsync(TRole role, string name); + public virtual Task<IdentityResult> SetRoleNameAsync(TRole role, string? name); } public abstract class RoleStoreBase<TRole, TKey, TUserRole, TRoleClaim> : IDisposable, IQueryableRoleStore<TRole>, IRoleClaimStore<TRole>, IRoleStore<TRole> where TRole : IdentityRole<TKey> where TKey : IEquatable<TKey> where TUserRole : IdentityUserRole<TKey>, new() where TRoleClaim : IdentityRoleClaim<TKey>, new() { - public virtual TKey ConvertIdFromString(string id); + public virtual TKey? ConvertIdFromString(string? id); - public virtual string ConvertIdToString(TKey id); + public virtual string? ConvertIdToString(TKey id); - public abstract Task<TRole> FindByIdAsync(string id, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TRole?> FindByIdAsync(string id, CancellationToken cancellationToken = default(CancellationToken)); - public abstract Task<TRole> FindByNameAsync(string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TRole?> FindByNameAsync(string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetNormalizedRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetRoleNameAsync(TRole role, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetNormalizedRoleNameAsync(TRole role, string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetNormalizedRoleNameAsync(TRole role, string? normalizedName, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetRoleNameAsync(TRole role, string roleName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetRoleNameAsync(TRole role, string? roleName, CancellationToken cancellationToken = default(CancellationToken)); } public class RoleValidator<TRole> : IRoleValidator<TRole> where TRole : class { - public RoleValidator(IdentityErrorDescriber errors = null); + public RoleValidator(IdentityErrorDescriber? errors = null); } public class SecurityStampValidator<TUser> : ISecurityStampValidator where TUser : class { - protected virtual Task<TUser> VerifySecurityStamp(ClaimsPrincipal principal); + protected virtual Task<TUser?> VerifySecurityStamp(ClaimsPrincipal? principal); } public class SecurityStampValidatorOptions { - public Func<SecurityStampRefreshingPrincipalContext, Task> OnRefreshingPrincipal { get; set; } + public Func<SecurityStampRefreshingPrincipalContext, Task>? OnRefreshingPrincipal { get; set; } } public class SignInManager<TUser> where TUser : class { - public virtual AuthenticationProperties ConfigureExternalAuthenticationProperties(string provider, string redirectUrl, string userId = null); + public virtual AuthenticationProperties ConfigureExternalAuthenticationProperties(string? provider, string? redirectUrl, string? userId = null); - public virtual Task<ExternalLoginInfo> GetExternalLoginInfoAsync(string expectedXsrf = null); + public virtual Task<ExternalLoginInfo?> GetExternalLoginInfoAsync(string? expectedXsrf = null); - public virtual Task<TUser> GetTwoFactorAuthenticationUserAsync(); + public virtual Task<TUser?> GetTwoFactorAuthenticationUserAsync(); - protected virtual Task<SignInResult> PreSignInCheck(TUser user); + protected virtual Task<SignInResult?> PreSignInCheck(TUser user); - public virtual Task SignInAsync(TUser user, AuthenticationProperties authenticationProperties, string authenticationMethod = null); + public virtual Task SignInAsync(TUser user, AuthenticationProperties authenticationProperties, string? authenticationMethod = null); - public virtual Task SignInAsync(TUser user, bool isPersistent, string authenticationMethod = null); + public virtual Task SignInAsync(TUser user, bool isPersistent, string? authenticationMethod = null); - protected virtual Task<SignInResult> SignInOrTwoFactorAsync(TUser user, bool isPersistent, string loginProvider = null, bool bypassTwoFactor = false); + protected virtual Task<SignInResult> SignInOrTwoFactorAsync(TUser user, bool isPersistent, string? loginProvider = null, bool bypassTwoFactor = false); - public virtual Task SignInWithClaimsAsync(TUser user, AuthenticationProperties authenticationProperties, IEnumerable<Claim> additionalClaims); + public virtual Task SignInWithClaimsAsync(TUser user, AuthenticationProperties? authenticationProperties, IEnumerable<Claim> additionalClaims); - public virtual Task<TUser> ValidateSecurityStampAsync(ClaimsPrincipal principal); + public virtual Task<TUser?> ValidateSecurityStampAsync(ClaimsPrincipal? principal); - public virtual Task<bool> ValidateSecurityStampAsync(TUser user, string securityStamp); + public virtual Task<bool> ValidateSecurityStampAsync(TUser? user, string? securityStamp); - public virtual Task<TUser> ValidateTwoFactorSecurityStampAsync(ClaimsPrincipal principal); + public virtual Task<TUser?> ValidateTwoFactorSecurityStampAsync(ClaimsPrincipal? principal); } public class TokenProviderDescriptor { - public object ProviderInstance { get; set; } + public object? ProviderInstance { get; set; } } public class TwoFactorSecurityStampValidator<TUser> : SecurityStampValidator<TUser>, ISecurityStampValidator, ITwoFactorSecurityStampValidator where TUser : class { - protected override Task<TUser> VerifySecurityStamp(ClaimsPrincipal principal); + protected override Task<TUser?> VerifySecurityStamp(ClaimsPrincipal? principal); } public sealed class UpperInvariantLookupNormalizer : ILookupNormalizer { - public string NormalizeEmail(string email); + public string? NormalizeEmail(string? email); - public string NormalizeName(string name); + public string? NormalizeName(string? name); } public class UserLoginInfo { - public UserLoginInfo(string loginProvider, string providerKey, string displayName); + public UserLoginInfo(string loginProvider, string providerKey, string? displayName); - public string ProviderDisplayName { get; set; } + public string? ProviderDisplayName { get; set; } } public class UserManager<TUser> : IDisposable where TUser : class { public virtual Task<byte[]> CreateSecurityTokenAsync(TUser user); - public virtual Task<TUser> FindByEmailAsync(string email); + public virtual Task<TUser?> FindByEmailAsync(string email); - public virtual Task<TUser> FindByIdAsync(string userId); + public virtual Task<TUser?> FindByIdAsync(string userId); - public virtual Task<TUser> FindByLoginAsync(string loginProvider, string providerKey); + public virtual Task<TUser?> FindByLoginAsync(string loginProvider, string providerKey); - public virtual Task<TUser> FindByNameAsync(string userName); + public virtual Task<TUser?> FindByNameAsync(string userName); - public virtual Task<IEnumerable<string>> GenerateNewTwoFactorRecoveryCodesAsync(TUser user, int number); + public virtual Task<IEnumerable<string>?> GenerateNewTwoFactorRecoveryCodesAsync(TUser user, int number); - public virtual Task<string> GetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName); + public virtual Task<string?> GetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName); - public virtual Task<string> GetAuthenticatorKeyAsync(TUser user); + public virtual Task<string?> GetAuthenticatorKeyAsync(TUser user); - public virtual Task<string> GetEmailAsync(TUser user); + public virtual Task<string?> GetEmailAsync(TUser user); - public virtual Task<string> GetPhoneNumberAsync(TUser user); + public virtual Task<string?> GetPhoneNumberAsync(TUser user); - public virtual Task<TUser> GetUserAsync(ClaimsPrincipal principal); + public virtual Task<TUser?> GetUserAsync(ClaimsPrincipal principal); - public virtual string GetUserId(ClaimsPrincipal principal); + public virtual string? GetUserId(ClaimsPrincipal principal); - public virtual string GetUserName(ClaimsPrincipal principal); + public virtual string? GetUserName(ClaimsPrincipal principal); - public virtual Task<string> GetUserNameAsync(TUser user); + public virtual Task<string?> GetUserNameAsync(TUser user); - public virtual string NormalizeEmail(string email); + public virtual string? NormalizeEmail(string? email); - public virtual string NormalizeName(string name); + public virtual string? NormalizeName(string? name); public virtual Task<IdentityResult> RedeemTwoFactorRecoveryCodeAsync(TUser user, string code); - public virtual Task<IdentityResult> SetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName, string tokenValue); + public virtual Task<IdentityResult> SetAuthenticationTokenAsync(TUser user, string loginProvider, string tokenName, string? tokenValue); - public virtual Task<IdentityResult> SetEmailAsync(TUser user, string email); + public virtual Task<IdentityResult> SetEmailAsync(TUser user, string? email); - public virtual Task<IdentityResult> SetPhoneNumberAsync(TUser user, string phoneNumber); + public virtual Task<IdentityResult> SetPhoneNumberAsync(TUser user, string? phoneNumber); - public virtual Task<IdentityResult> SetUserNameAsync(TUser user, string userName); + public virtual Task<IdentityResult> SetUserNameAsync(TUser user, string? userName); protected virtual Task<IdentityResult> UpdateUserAsync(TUser user); - protected Task<IdentityResult> ValidatePasswordAsync(TUser user, string password); + protected Task<IdentityResult> ValidatePasswordAsync(TUser user, string? password); protected Task<IdentityResult> ValidateUserAsync(TUser user); } public abstract class UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken> : IDisposable, IQueryableUserStore<TUser>, IUserAuthenticationTokenStore<TUser>, IUserAuthenticatorKeyStore<TUser>, IUserClaimStore<TUser>, IUserEmailStore<TUser>, IUserLockoutStore<TUser>, IUserLoginStore<TUser>, IUserPasswordStore<TUser>, IUserPhoneNumberStore<TUser>, IUserSecurityStampStore<TUser>, IUserStore<TUser>, IUserTwoFactorRecoveryCodeStore<TUser>, IUserTwoFactorStore<TUser> where TUser : IdentityUser<TKey> where TKey : IEquatable<TKey> where TUserClaim : IdentityUserClaim<TKey>, new() where TUserLogin : IdentityUserLogin<TKey>, new() where TUserToken : IdentityUserToken<TKey>, new() { - public virtual TKey ConvertIdFromString(string id); + public virtual TKey? ConvertIdFromString(string? id); - public virtual string ConvertIdToString(TKey id); + public virtual string? ConvertIdToString(TKey id); - protected virtual TUserToken CreateUserToken(TUser user, string loginProvider, string name, string value); + protected virtual TUserToken CreateUserToken(TUser user, string loginProvider, string name, string? value); - public abstract Task<TUser> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TUser?> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); - public abstract Task<TUser> FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TUser?> FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<TUser> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<TUser?> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken = default(CancellationToken)); - public abstract Task<TUser> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken)); + public abstract Task<TUser?> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken)); - protected abstract Task<TUserToken> FindTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); + protected abstract Task<TUserToken?> FindTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); - protected abstract Task<TUser> FindUserAsync(TKey userId, CancellationToken cancellationToken); + protected abstract Task<TUser?> FindUserAsync(TKey userId, CancellationToken cancellationToken); - protected abstract Task<TUserLogin> FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); + protected abstract Task<TUserLogin?> FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken); - protected abstract Task<TUserLogin> FindUserLoginAsync(TKey userId, string loginProvider, string providerKey, CancellationToken cancellationToken); + protected abstract Task<TUserLogin?> FindUserLoginAsync(TKey userId, string loginProvider, string providerKey, CancellationToken cancellationToken); - public virtual Task<string> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); + public virtual Task<string?> GetAuthenticatorKeyAsync(TUser user, CancellationToken cancellationToken); - public virtual Task<string> GetEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetNormalizedEmailAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetNormalizedUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetPasswordHashAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetPhoneNumberAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetSecurityStampAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task<string> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); + public virtual Task<string?> GetTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken); - public virtual Task<string> GetUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task<string?> GetUserNameAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetEmailAsync(TUser user, string email, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetEmailAsync(TUser user, string? email, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetNormalizedEmailAsync(TUser user, string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetNormalizedEmailAsync(TUser user, string? normalizedEmail, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetNormalizedUserNameAsync(TUser user, string normalizedName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetNormalizedUserNameAsync(TUser user, string? normalizedName, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetPasswordHashAsync(TUser user, string passwordHash, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetPasswordHashAsync(TUser user, string? passwordHash, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetPhoneNumberAsync(TUser user, string phoneNumber, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetPhoneNumberAsync(TUser user, string? phoneNumber, CancellationToken cancellationToken = default(CancellationToken)); - public virtual Task SetTokenAsync(TUser user, string loginProvider, string name, string value, CancellationToken cancellationToken); + public virtual Task SetTokenAsync(TUser user, string loginProvider, string name, string? value, CancellationToken cancellationToken); - public virtual Task SetUserNameAsync(TUser user, string userName, CancellationToken cancellationToken = default(CancellationToken)); + public virtual Task SetUserNameAsync(TUser user, string? userName, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class UserStoreBase<TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim> : UserStoreBase<TUser, TKey, TUserClaim, TUserLogin, TUserToken>, IDisposable, IUserRoleStore<TUser>, IUserStore<TUser> where TUser : IdentityUser<TKey> where TRole : IdentityRole<TKey> where TKey : IEquatable<TKey> where TUserClaim : IdentityUserClaim<TKey>, new() where TUserRole : IdentityUserRole<TKey>, new() where TUserLogin : IdentityUserLogin<TKey>, new() where TUserToken : IdentityUserToken<TKey>, new() where TRoleClaim : IdentityRoleClaim<TKey>, new() { - protected abstract Task<TRole> FindRoleAsync(string normalizedRoleName, CancellationToken cancellationToken); + protected abstract Task<TRole?> FindRoleAsync(string normalizedRoleName, CancellationToken cancellationToken); - protected abstract Task<TUserRole> FindUserRoleAsync(TKey userId, TKey roleId, CancellationToken cancellationToken); + protected abstract Task<TUserRole?> FindUserRoleAsync(TKey userId, TKey roleId, CancellationToken cancellationToken); } public class UserValidator<TUser> : IUserValidator<TUser> where TUser : class { - public UserValidator(IdentityErrorDescriber errors = null); + public UserValidator(IdentityErrorDescriber? errors = null); } }","title":"Microsoft.AspNetCore.Identity"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ApplicationModels/","text":"Microsoft.AspNetCore.Mvc.ApplicationModels namespace Microsoft.AspNetCore.Mvc.ApplicationModels { public class AttributeRouteModel { public string Template { get; set; } public static string CombineTemplates(string prefix, string template); public static bool IsOverridePattern(string template); public static string ReplaceTokens(string template, IDictionary<string, string?> values, IOutboundParameterTransformer? routeTokenTransformer); } public class InferParameterBindingInfoConvention : IActionModelConvention { + public InferParameterBindingInfoConvention(IModelMetadataProvider modelMetadataProvider, IServiceProviderIsService serviceProviderIsService); } }","title":"Microsoft.AspNetCore.Mvc.ApplicationModels"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ApplicationModels/#microsoftaspnetcoremvcapplicationmodels","text":"namespace Microsoft.AspNetCore.Mvc.ApplicationModels { public class AttributeRouteModel { public string Template { get; set; } public static string CombineTemplates(string prefix, string template); public static bool IsOverridePattern(string template); public static string ReplaceTokens(string template, IDictionary<string, string?> values, IOutboundParameterTransformer? routeTokenTransformer); } public class InferParameterBindingInfoConvention : IActionModelConvention { + public InferParameterBindingInfoConvention(IModelMetadataProvider modelMetadataProvider, IServiceProviderIsService serviceProviderIsService); } }","title":"Microsoft.AspNetCore.Mvc.ApplicationModels"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Infrastructure/","text":"Microsoft.AspNetCore.Mvc.Infrastructure namespace Microsoft.AspNetCore.Mvc.Infrastructure { public abstract class ConfigureCompatibilityOptions<TOptions> : IPostConfigureOptions<TOptions> where TOptions : class, IEnumerable<ICompatibilitySwitch> { - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public sealed class DefaultStatusCodeAttribute : Attribute }","title":"Microsoft.AspNetCore.Mvc.Infrastructure"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Infrastructure/#microsoftaspnetcoremvcinfrastructure","text":"namespace Microsoft.AspNetCore.Mvc.Infrastructure { public abstract class ConfigureCompatibilityOptions<TOptions> : IPostConfigureOptions<TOptions> where TOptions : class, IEnumerable<ICompatibilitySwitch> { - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public sealed class DefaultStatusCodeAttribute : Attribute }","title":"Microsoft.AspNetCore.Mvc.Infrastructure"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding.Binders/","text":"Microsoft.AspNetCore.Mvc.ModelBinding.Binders namespace Microsoft.AspNetCore.Mvc.ModelBinding.Binders { + public sealed class TryParseModelBinderProvider : IModelBinderProvider { + public TryParseModelBinderProvider(); + public IModelBinder? GetBinder(ModelBinderProviderContext context); + } }","title":"Microsoft.AspNetCore.Mvc.ModelBinding.Binders"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding.Binders/#microsoftaspnetcoremvcmodelbindingbinders","text":"namespace Microsoft.AspNetCore.Mvc.ModelBinding.Binders { + public sealed class TryParseModelBinderProvider : IModelBinderProvider { + public TryParseModelBinderProvider(); + public IModelBinder? GetBinder(ModelBinderProviderContext context); + } }","title":"Microsoft.AspNetCore.Mvc.ModelBinding.Binders"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding.Metadata/","text":"Microsoft.AspNetCore.Mvc.ModelBinding.Metadata namespace Microsoft.AspNetCore.Mvc.ModelBinding.Metadata { + public sealed class SystemTextJsonValidationMetadataProvider : IDisplayMetadataProvider, IMetadataDetailsProvider, IValidationMetadataProvider { + public SystemTextJsonValidationMetadataProvider(); + public SystemTextJsonValidationMetadataProvider(JsonNamingPolicy namingPolicy); + public void CreateDisplayMetadata(DisplayMetadataProviderContext context); + public void CreateValidationMetadata(ValidationMetadataProviderContext context); + } public class ValidationMetadata { + public string ValidationModelName { get; set; } } }","title":"Microsoft.AspNetCore.Mvc.ModelBinding.Metadata"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding.Metadata/#microsoftaspnetcoremvcmodelbindingmetadata","text":"namespace Microsoft.AspNetCore.Mvc.ModelBinding.Metadata { + public sealed class SystemTextJsonValidationMetadataProvider : IDisplayMetadataProvider, IMetadataDetailsProvider, IValidationMetadataProvider { + public SystemTextJsonValidationMetadataProvider(); + public SystemTextJsonValidationMetadataProvider(JsonNamingPolicy namingPolicy); + public void CreateDisplayMetadata(DisplayMetadataProviderContext context); + public void CreateValidationMetadata(ValidationMetadataProviderContext context); + } public class ValidationMetadata { + public string ValidationModelName { get; set; } } }","title":"Microsoft.AspNetCore.Mvc.ModelBinding.Metadata"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding/","text":"Microsoft.AspNetCore.Mvc.ModelBinding namespace Microsoft.AspNetCore.Mvc.ModelBinding { public class DefaultPropertyFilterProvider<TModel> : IPropertyFilterProvider where TModel : class { - public virtual IEnumerable<Expression<Func<TModel, object>>>? PropertyIncludeExpressions { get; } + public virtual IEnumerable<Expression<Func<TModel, object?>>>? PropertyIncludeExpressions { get; } } public class JQueryFormValueProvider : JQueryValueProvider { + public override ValueProviderResult GetValue(string key); } public abstract class ModelMetadata : IEquatable<ModelMetadata?>, IModelMetadataProvider { public bool IsComplexType { get; } } }","title":"Microsoft.AspNetCore.Mvc.ModelBinding"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ModelBinding/#microsoftaspnetcoremvcmodelbinding","text":"namespace Microsoft.AspNetCore.Mvc.ModelBinding { public class DefaultPropertyFilterProvider<TModel> : IPropertyFilterProvider where TModel : class { - public virtual IEnumerable<Expression<Func<TModel, object>>>? PropertyIncludeExpressions { get; } + public virtual IEnumerable<Expression<Func<TModel, object?>>>? PropertyIncludeExpressions { get; } } public class JQueryFormValueProvider : JQueryValueProvider { + public override ValueProviderResult GetValue(string key); } public abstract class ModelMetadata : IEquatable<ModelMetadata?>, IModelMetadataProvider { public bool IsComplexType { get; } } }","title":"Microsoft.AspNetCore.Mvc.ModelBinding"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.RazorPages/","text":"Microsoft.AspNetCore.Mvc.RazorPages namespace Microsoft.AspNetCore.Mvc.RazorPages { public abstract class PageBase : RazorPageBase { - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; } public abstract class PageModel : IAsyncPageFilter, IFilterMetadata, IPageFilter { - protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, IValueProvider valueProvider, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, IValueProvider valueProvider, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; - protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; } }","title":"Microsoft.AspNetCore.Mvc.RazorPages"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.RazorPages/#microsoftaspnetcoremvcrazorpages","text":"namespace Microsoft.AspNetCore.Mvc.RazorPages { public abstract class PageBase : RazorPageBase { - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; } public abstract class PageModel : IAsyncPageFilter, IFilterMetadata, IPageFilter { - protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, IValueProvider valueProvider, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, IValueProvider valueProvider, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; - protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + protected internal Task<bool> TryUpdateModelAsync<TModel>(TModel model, string name, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; } }","title":"Microsoft.AspNetCore.Mvc.RazorPages"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Rendering/","text":"Microsoft.AspNetCore.Mvc.Rendering namespace Microsoft.AspNetCore.Mvc.Rendering { + public enum FormInputRenderMode { + AlwaysUseCurrentCulture = 1, + DetectCultureFromInputType = 0, + } public static class HtmlHelperComponentExtensions { public static Task<IHtmlContent> RenderComponentAsync(this IHtmlHelper htmlHelper, Type componentType, RenderMode renderMode, object parameters); } }","title":"Microsoft.AspNetCore.Mvc.Rendering"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Rendering/#microsoftaspnetcoremvcrendering","text":"namespace Microsoft.AspNetCore.Mvc.Rendering { + public enum FormInputRenderMode { + AlwaysUseCurrentCulture = 1, + DetectCultureFromInputType = 0, + } public static class HtmlHelperComponentExtensions { public static Task<IHtmlContent> RenderComponentAsync(this IHtmlHelper htmlHelper, Type componentType, RenderMode renderMode, object parameters); } }","title":"Microsoft.AspNetCore.Mvc.Rendering"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Routing/","text":"Microsoft.AspNetCore.Mvc.Routing namespace Microsoft.AspNetCore.Mvc.Routing { public abstract class HttpMethodAttribute : Attribute, IActionHttpMethodProvider, IRouteTemplateProvider { public HttpMethodAttribute(IEnumerable<string> httpMethods, string? template); public string Template { get; } } public interface IRouteTemplateProvider { string Template { get; } } }","title":"Microsoft.AspNetCore.Mvc.Routing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.Routing/#microsoftaspnetcoremvcrouting","text":"namespace Microsoft.AspNetCore.Mvc.Routing { public abstract class HttpMethodAttribute : Attribute, IActionHttpMethodProvider, IRouteTemplateProvider { public HttpMethodAttribute(IEnumerable<string> httpMethods, string? template); public string Template { get; } } public interface IRouteTemplateProvider { string Template { get; } } }","title":"Microsoft.AspNetCore.Mvc.Routing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ViewFeatures/","text":"Microsoft.AspNetCore.Mvc.ViewFeatures namespace Microsoft.AspNetCore.Mvc.ViewFeatures { public class HtmlHelperOptions { + public FormInputRenderMode FormInputRenderMode { get; set; } } }","title":"Microsoft.AspNetCore.Mvc.ViewFeatures"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc.ViewFeatures/#microsoftaspnetcoremvcviewfeatures","text":"namespace Microsoft.AspNetCore.Mvc.ViewFeatures { public class HtmlHelperOptions { + public FormInputRenderMode FormInputRenderMode { get; set; } } }","title":"Microsoft.AspNetCore.Mvc.ViewFeatures"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc/","text":"Microsoft.AspNetCore.Mvc namespace Microsoft.AspNetCore.Mvc { public sealed class AcceptVerbsAttribute : Attribute, IActionHttpMethodProvider, IRouteTemplateProvider { public string Route { get; set; } } public class ApiBehaviorOptions : IEnumerable, IEnumerable<ICompatibilitySwitch> { + public bool DisableImplicitFromServicesParameters { get; set; } } public abstract class ControllerBase { + public static EmptyResult Empty { get; } public virtual Task<bool> TryUpdateModelAsync(object model, Type modelType, string prefix); public virtual Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix) where TModel : class; - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, Func<ModelMetadata, bool> propertyFilter) where TModel : class; - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; public virtual ActionResult ValidationProblem(); public virtual ActionResult ValidationProblem(ModelStateDictionary modelStateDictionary); public virtual ActionResult ValidationProblem(ValidationProblemDetails descriptor); public virtual ActionResult ValidationProblem(string? detail = null, string? instance = null, int? statusCode = default(int?), string? title = null, string? type = null, ModelStateDictionary? modelStateDictionary = null); } - public class DisableRequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter { + public class DisableRequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter, IRequestSizeLimitMetadata { + long? Microsoft.AspNetCore.Http.Metadata.IRequestSizeLimitMetadata.MaxRequestBodySize { get; } } - public class FromFormAttribute : Attribute, IBindingSourceMetadata, IModelNameProvider + public class FromFormAttribute : Attribute, IBindingSourceMetadata, IFromFormMetadata, IModelNameProvider public class FromServicesAttribute : Attribute, IBindingSourceMetadata, IFromServiceMetadata public class HttpDeleteAttribute : HttpMethodAttribute { public HttpDeleteAttribute(string template); } public class HttpGetAttribute : HttpMethodAttribute { public HttpGetAttribute(string template); } public class HttpHeadAttribute : HttpMethodAttribute { public HttpHeadAttribute(string template); } public class HttpOptionsAttribute : HttpMethodAttribute { public HttpOptionsAttribute(string template); } public class HttpPatchAttribute : HttpMethodAttribute { public HttpPatchAttribute(string template); } public class HttpPostAttribute : HttpMethodAttribute { public HttpPostAttribute(string template); } public class HttpPutAttribute : HttpMethodAttribute { public HttpPutAttribute(string template); } - public class RequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter { + public class RequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter, IRequestSizeLimitMetadata { + long? Microsoft.AspNetCore.Http.Metadata.IRequestSizeLimitMetadata.MaxRequestBodySize { get; } } public class RouteAttribute : Attribute, IRouteTemplateProvider { public RouteAttribute(string template); public string Template { get; } } - public class SkipStatusCodePagesAttribute : Attribute, IFilterMetadata, IResourceFilter + public class SkipStatusCodePagesAttribute : Attribute, IFilterMetadata, IResourceFilter, ISkipStatusCodePagesMetadata }","title":"Microsoft.AspNetCore.Mvc"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Mvc/#microsoftaspnetcoremvc","text":"namespace Microsoft.AspNetCore.Mvc { public sealed class AcceptVerbsAttribute : Attribute, IActionHttpMethodProvider, IRouteTemplateProvider { public string Route { get; set; } } public class ApiBehaviorOptions : IEnumerable, IEnumerable<ICompatibilitySwitch> { + public bool DisableImplicitFromServicesParameters { get; set; } } public abstract class ControllerBase { + public static EmptyResult Empty { get; } public virtual Task<bool> TryUpdateModelAsync(object model, Type modelType, string prefix); public virtual Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix) where TModel : class; - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, IValueProvider valueProvider, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, Func<ModelMetadata, bool> propertyFilter) where TModel : class; - public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object>>[] includeExpressions) where TModel : class; + public Task<bool> TryUpdateModelAsync<TModel>(TModel model, string prefix, params Expression<Func<TModel, object?>>[] includeExpressions) where TModel : class; public virtual ActionResult ValidationProblem(); public virtual ActionResult ValidationProblem(ModelStateDictionary modelStateDictionary); public virtual ActionResult ValidationProblem(ValidationProblemDetails descriptor); public virtual ActionResult ValidationProblem(string? detail = null, string? instance = null, int? statusCode = default(int?), string? title = null, string? type = null, ModelStateDictionary? modelStateDictionary = null); } - public class DisableRequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter { + public class DisableRequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter, IRequestSizeLimitMetadata { + long? Microsoft.AspNetCore.Http.Metadata.IRequestSizeLimitMetadata.MaxRequestBodySize { get; } } - public class FromFormAttribute : Attribute, IBindingSourceMetadata, IModelNameProvider + public class FromFormAttribute : Attribute, IBindingSourceMetadata, IFromFormMetadata, IModelNameProvider public class FromServicesAttribute : Attribute, IBindingSourceMetadata, IFromServiceMetadata public class HttpDeleteAttribute : HttpMethodAttribute { public HttpDeleteAttribute(string template); } public class HttpGetAttribute : HttpMethodAttribute { public HttpGetAttribute(string template); } public class HttpHeadAttribute : HttpMethodAttribute { public HttpHeadAttribute(string template); } public class HttpOptionsAttribute : HttpMethodAttribute { public HttpOptionsAttribute(string template); } public class HttpPatchAttribute : HttpMethodAttribute { public HttpPatchAttribute(string template); } public class HttpPostAttribute : HttpMethodAttribute { public HttpPostAttribute(string template); } public class HttpPutAttribute : HttpMethodAttribute { public HttpPutAttribute(string template); } - public class RequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter { + public class RequestSizeLimitAttribute : Attribute, IFilterFactory, IFilterMetadata, IOrderedFilter, IRequestSizeLimitMetadata { + long? Microsoft.AspNetCore.Http.Metadata.IRequestSizeLimitMetadata.MaxRequestBodySize { get; } } public class RouteAttribute : Attribute, IRouteTemplateProvider { public RouteAttribute(string template); public string Template { get; } } - public class SkipStatusCodePagesAttribute : Attribute, IFilterMetadata, IResourceFilter + public class SkipStatusCodePagesAttribute : Attribute, IFilterMetadata, IResourceFilter, ISkipStatusCodePagesMetadata }","title":"Microsoft.AspNetCore.Mvc"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.OutputCaching/","text":"Microsoft.AspNetCore.OutputCaching +namespace Microsoft.AspNetCore.OutputCaching { + public sealed class CacheVaryByRules { + public CacheVaryByRules(); + public string CacheKeyPrefix { get; set; } + public StringValues HeaderNames { get; set; } + public StringValues QueryKeys { get; set; } + public StringValues RouteValueNames { get; set; } + public bool VaryByHost { get; set; } + public IDictionary<string, string> VaryByValues { get; } + } + public interface IOutputCacheFeature { + OutputCacheContext Context { get; } + } + public interface IOutputCachePolicy { + ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation); + ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation); + ValueTask ServeResponseAsync(OutputCacheContext context, CancellationToken cancellation); + } + public interface IOutputCacheStore { + ValueTask EvictByTagAsync(string tag, CancellationToken cancellationToken); + ValueTask<byte[]?> GetAsync(string key, CancellationToken cancellationToken); + ValueTask SetAsync(string key, byte[] value, string[]? tags, TimeSpan validFor, CancellationToken cancellationToken); + } + public sealed class OutputCacheAttribute : Attribute { + public OutputCacheAttribute(); + public int Duration { get; set; } + public bool NoStore { get; set; } + public string PolicyName { get; set; } + public string[]? VaryByHeaderNames { get; set; } + public string[]? VaryByQueryKeys { get; set; } + public string[]? VaryByRouteValueNames { get; set; } + } + public sealed class OutputCacheContext { + public OutputCacheContext(); + public bool AllowCacheLookup { get; set; } + public bool AllowCacheStorage { get; set; } + public bool AllowLocking { get; set; } + public CacheVaryByRules CacheVaryByRules { get; } + public bool EnableOutputCaching { get; set; } + public required HttpContext HttpContext { get; set; } + public TimeSpan? ResponseExpirationTimeSpan { get; set; } + public DateTimeOffset? ResponseTime { get; set; } + public HashSet<string> Tags { get; } + } + public class OutputCacheOptions { + public OutputCacheOptions(); + public IServiceProvider ApplicationServices { get; internal set; } + public TimeSpan DefaultExpirationTimeSpan { get; set; } + public long MaximumBodySize { get; set; } + public long SizeLimit { get; set; } + public bool UseCaseSensitivePaths { get; set; } + public void AddBasePolicy(IOutputCachePolicy policy); + public void AddBasePolicy(Action<OutputCachePolicyBuilder> build); + public void AddBasePolicy(Action<OutputCachePolicyBuilder> build, bool excludeDefaultPolicy); + public void AddPolicy(string name, IOutputCachePolicy policy); + public void AddPolicy(string name, Action<OutputCachePolicyBuilder> build); + public void AddPolicy(string name, Action<OutputCachePolicyBuilder> build, bool excludeDefaultPolicy); + } + public sealed class OutputCachePolicyBuilder { + public OutputCachePolicyBuilder AddPolicy(Type policyType); + public OutputCachePolicyBuilder AddPolicy<T>() where T : IOutputCachePolicy; + public OutputCachePolicyBuilder Cache(); + public OutputCachePolicyBuilder Expire(TimeSpan expiration); + public OutputCachePolicyBuilder NoCache(); + public OutputCachePolicyBuilder SetCacheKeyPrefix(Func<HttpContext, string> keyPrefix); + public OutputCachePolicyBuilder SetCacheKeyPrefix(Func<HttpContext, CancellationToken, ValueTask<string>> keyPrefix); + public OutputCachePolicyBuilder SetCacheKeyPrefix(string keyPrefix); + public OutputCachePolicyBuilder SetLocking(bool enabled); + public OutputCachePolicyBuilder SetVaryByHeader(string headerName, params string[] headerNames); + public OutputCachePolicyBuilder SetVaryByHeader(string[] headerNames); + public OutputCachePolicyBuilder SetVaryByHost(bool enabled); + public OutputCachePolicyBuilder SetVaryByQuery(string queryKey, params string[] queryKeys); + public OutputCachePolicyBuilder SetVaryByQuery(string[] queryKeys); + public OutputCachePolicyBuilder SetVaryByRouteValue(string routeValueName, params string[] routeValueNames); + public OutputCachePolicyBuilder SetVaryByRouteValue(string[] routeValueNames); + public OutputCachePolicyBuilder Tag(params string[] tags); + public OutputCachePolicyBuilder VaryByValue(Func<HttpContext, KeyValuePair<string, string>> varyBy); + public OutputCachePolicyBuilder VaryByValue(Func<HttpContext, CancellationToken, ValueTask<KeyValuePair<string, string>>> varyBy); + public OutputCachePolicyBuilder VaryByValue(string key, string value); + public OutputCachePolicyBuilder With(Func<OutputCacheContext, bool> predicate); + public OutputCachePolicyBuilder With(Func<OutputCacheContext, CancellationToken, ValueTask<bool>> predicate); + } +}","title":"Microsoft.AspNetCore.OutputCaching"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.OutputCaching/#microsoftaspnetcoreoutputcaching","text":"+namespace Microsoft.AspNetCore.OutputCaching { + public sealed class CacheVaryByRules { + public CacheVaryByRules(); + public string CacheKeyPrefix { get; set; } + public StringValues HeaderNames { get; set; } + public StringValues QueryKeys { get; set; } + public StringValues RouteValueNames { get; set; } + public bool VaryByHost { get; set; } + public IDictionary<string, string> VaryByValues { get; } + } + public interface IOutputCacheFeature { + OutputCacheContext Context { get; } + } + public interface IOutputCachePolicy { + ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation); + ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation); + ValueTask ServeResponseAsync(OutputCacheContext context, CancellationToken cancellation); + } + public interface IOutputCacheStore { + ValueTask EvictByTagAsync(string tag, CancellationToken cancellationToken); + ValueTask<byte[]?> GetAsync(string key, CancellationToken cancellationToken); + ValueTask SetAsync(string key, byte[] value, string[]? tags, TimeSpan validFor, CancellationToken cancellationToken); + } + public sealed class OutputCacheAttribute : Attribute { + public OutputCacheAttribute(); + public int Duration { get; set; } + public bool NoStore { get; set; } + public string PolicyName { get; set; } + public string[]? VaryByHeaderNames { get; set; } + public string[]? VaryByQueryKeys { get; set; } + public string[]? VaryByRouteValueNames { get; set; } + } + public sealed class OutputCacheContext { + public OutputCacheContext(); + public bool AllowCacheLookup { get; set; } + public bool AllowCacheStorage { get; set; } + public bool AllowLocking { get; set; } + public CacheVaryByRules CacheVaryByRules { get; } + public bool EnableOutputCaching { get; set; } + public required HttpContext HttpContext { get; set; } + public TimeSpan? ResponseExpirationTimeSpan { get; set; } + public DateTimeOffset? ResponseTime { get; set; } + public HashSet<string> Tags { get; } + } + public class OutputCacheOptions { + public OutputCacheOptions(); + public IServiceProvider ApplicationServices { get; internal set; } + public TimeSpan DefaultExpirationTimeSpan { get; set; } + public long MaximumBodySize { get; set; } + public long SizeLimit { get; set; } + public bool UseCaseSensitivePaths { get; set; } + public void AddBasePolicy(IOutputCachePolicy policy); + public void AddBasePolicy(Action<OutputCachePolicyBuilder> build); + public void AddBasePolicy(Action<OutputCachePolicyBuilder> build, bool excludeDefaultPolicy); + public void AddPolicy(string name, IOutputCachePolicy policy); + public void AddPolicy(string name, Action<OutputCachePolicyBuilder> build); + public void AddPolicy(string name, Action<OutputCachePolicyBuilder> build, bool excludeDefaultPolicy); + } + public sealed class OutputCachePolicyBuilder { + public OutputCachePolicyBuilder AddPolicy(Type policyType); + public OutputCachePolicyBuilder AddPolicy<T>() where T : IOutputCachePolicy; + public OutputCachePolicyBuilder Cache(); + public OutputCachePolicyBuilder Expire(TimeSpan expiration); + public OutputCachePolicyBuilder NoCache(); + public OutputCachePolicyBuilder SetCacheKeyPrefix(Func<HttpContext, string> keyPrefix); + public OutputCachePolicyBuilder SetCacheKeyPrefix(Func<HttpContext, CancellationToken, ValueTask<string>> keyPrefix); + public OutputCachePolicyBuilder SetCacheKeyPrefix(string keyPrefix); + public OutputCachePolicyBuilder SetLocking(bool enabled); + public OutputCachePolicyBuilder SetVaryByHeader(string headerName, params string[] headerNames); + public OutputCachePolicyBuilder SetVaryByHeader(string[] headerNames); + public OutputCachePolicyBuilder SetVaryByHost(bool enabled); + public OutputCachePolicyBuilder SetVaryByQuery(string queryKey, params string[] queryKeys); + public OutputCachePolicyBuilder SetVaryByQuery(string[] queryKeys); + public OutputCachePolicyBuilder SetVaryByRouteValue(string routeValueName, params string[] routeValueNames); + public OutputCachePolicyBuilder SetVaryByRouteValue(string[] routeValueNames); + public OutputCachePolicyBuilder Tag(params string[] tags); + public OutputCachePolicyBuilder VaryByValue(Func<HttpContext, KeyValuePair<string, string>> varyBy); + public OutputCachePolicyBuilder VaryByValue(Func<HttpContext, CancellationToken, ValueTask<KeyValuePair<string, string>>> varyBy); + public OutputCachePolicyBuilder VaryByValue(string key, string value); + public OutputCachePolicyBuilder With(Func<OutputCacheContext, bool> predicate); + public OutputCachePolicyBuilder With(Func<OutputCacheContext, CancellationToken, ValueTask<bool>> predicate); + } +}","title":"Microsoft.AspNetCore.OutputCaching"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.RateLimiting/","text":"Microsoft.AspNetCore.RateLimiting +namespace Microsoft.AspNetCore.RateLimiting { + public sealed class DisableRateLimitingAttribute : Attribute { + public DisableRateLimitingAttribute(); + } + public sealed class EnableRateLimitingAttribute : Attribute { + public EnableRateLimitingAttribute(string policyName); + public string PolicyName { get; } + } + public interface IRateLimiterPolicy<TPartitionKey> { + Func<OnRejectedContext, CancellationToken, ValueTask>? OnRejected { get; } + RateLimitPartition<TPartitionKey> GetPartition(HttpContext httpContext); + } + public sealed class OnRejectedContext { + public OnRejectedContext(); + public required HttpContext HttpContext { get; set; } + public required RateLimitLease Lease { get; set; } + } + public sealed class RateLimiterOptions { + public RateLimiterOptions(); + public PartitionedRateLimiter<HttpContext>? GlobalLimiter { get; set; } + public Func<OnRejectedContext, CancellationToken, ValueTask>? OnRejected { get; set; } + public int RejectionStatusCode { get; set; } + public RateLimiterOptions AddPolicy<TPartitionKey, TPolicy>(string policyName) where TPolicy : IRateLimiterPolicy<TPartitionKey>; + public RateLimiterOptions AddPolicy<TPartitionKey>(string policyName, IRateLimiterPolicy<TPartitionKey> policy); + public RateLimiterOptions AddPolicy<TPartitionKey>(string policyName, Func<HttpContext, RateLimitPartition<TPartitionKey>> partitioner); + } + public static class RateLimiterOptionsExtensions { + public static RateLimiterOptions AddConcurrencyLimiter(this RateLimiterOptions options, string policyName, Action<ConcurrencyLimiterOptions> configureOptions); + public static RateLimiterOptions AddFixedWindowLimiter(this RateLimiterOptions options, string policyName, Action<FixedWindowRateLimiterOptions> configureOptions); + public static RateLimiterOptions AddSlidingWindowLimiter(this RateLimiterOptions options, string policyName, Action<SlidingWindowRateLimiterOptions> configureOptions); + public static RateLimiterOptions AddTokenBucketLimiter(this RateLimiterOptions options, string policyName, Action<TokenBucketRateLimiterOptions> configureOptions); + } +}","title":"Microsoft.AspNetCore.RateLimiting"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.RateLimiting/#microsoftaspnetcoreratelimiting","text":"+namespace Microsoft.AspNetCore.RateLimiting { + public sealed class DisableRateLimitingAttribute : Attribute { + public DisableRateLimitingAttribute(); + } + public sealed class EnableRateLimitingAttribute : Attribute { + public EnableRateLimitingAttribute(string policyName); + public string PolicyName { get; } + } + public interface IRateLimiterPolicy<TPartitionKey> { + Func<OnRejectedContext, CancellationToken, ValueTask>? OnRejected { get; } + RateLimitPartition<TPartitionKey> GetPartition(HttpContext httpContext); + } + public sealed class OnRejectedContext { + public OnRejectedContext(); + public required HttpContext HttpContext { get; set; } + public required RateLimitLease Lease { get; set; } + } + public sealed class RateLimiterOptions { + public RateLimiterOptions(); + public PartitionedRateLimiter<HttpContext>? GlobalLimiter { get; set; } + public Func<OnRejectedContext, CancellationToken, ValueTask>? OnRejected { get; set; } + public int RejectionStatusCode { get; set; } + public RateLimiterOptions AddPolicy<TPartitionKey, TPolicy>(string policyName) where TPolicy : IRateLimiterPolicy<TPartitionKey>; + public RateLimiterOptions AddPolicy<TPartitionKey>(string policyName, IRateLimiterPolicy<TPartitionKey> policy); + public RateLimiterOptions AddPolicy<TPartitionKey>(string policyName, Func<HttpContext, RateLimitPartition<TPartitionKey>> partitioner); + } + public static class RateLimiterOptionsExtensions { + public static RateLimiterOptions AddConcurrencyLimiter(this RateLimiterOptions options, string policyName, Action<ConcurrencyLimiterOptions> configureOptions); + public static RateLimiterOptions AddFixedWindowLimiter(this RateLimiterOptions options, string policyName, Action<FixedWindowRateLimiterOptions> configureOptions); + public static RateLimiterOptions AddSlidingWindowLimiter(this RateLimiterOptions options, string policyName, Action<SlidingWindowRateLimiterOptions> configureOptions); + public static RateLimiterOptions AddTokenBucketLimiter(this RateLimiterOptions options, string policyName, Action<TokenBucketRateLimiterOptions> configureOptions); + } +}","title":"Microsoft.AspNetCore.RateLimiting"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.RequestDecompression/","text":"Microsoft.AspNetCore.RequestDecompression +namespace Microsoft.AspNetCore.RequestDecompression { + public interface IDecompressionProvider { + Stream GetDecompressionStream(Stream stream); + } + public interface IRequestDecompressionProvider { + Stream? GetDecompressionStream(HttpContext context); + } + public sealed class RequestDecompressionOptions { + public RequestDecompressionOptions(); + public IDictionary<string, IDecompressionProvider> DecompressionProviders { get; } + } +}","title":"Microsoft.AspNetCore.RequestDecompression"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.RequestDecompression/#microsoftaspnetcorerequestdecompression","text":"+namespace Microsoft.AspNetCore.RequestDecompression { + public interface IDecompressionProvider { + Stream GetDecompressionStream(Stream stream); + } + public interface IRequestDecompressionProvider { + Stream? GetDecompressionStream(HttpContext context); + } + public sealed class RequestDecompressionOptions { + public RequestDecompressionOptions(); + public IDictionary<string, IDecompressionProvider> DecompressionProviders { get; } + } +}","title":"Microsoft.AspNetCore.RequestDecompression"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.ResponseCompression/","text":"Microsoft.AspNetCore.ResponseCompression namespace Microsoft.AspNetCore.ResponseCompression { public class CompressionProviderCollection : Collection<ICompressionProvider> { public void Add(Type providerType); } }","title":"Microsoft.AspNetCore.ResponseCompression"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.ResponseCompression/#microsoftaspnetcoreresponsecompression","text":"namespace Microsoft.AspNetCore.ResponseCompression { public class CompressionProviderCollection : Collection<ICompressionProvider> { public void Add(Type providerType); } }","title":"Microsoft.AspNetCore.ResponseCompression"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Routing.Patterns/","text":"Microsoft.AspNetCore.Routing.Patterns namespace Microsoft.AspNetCore.Routing.Patterns { public sealed class RoutePatternException : Exception { public RoutePatternException(string pattern, string message); } public static class RoutePatternFactory { + public static RoutePattern Combine(RoutePattern? left, RoutePattern right); public static RoutePattern Parse(string pattern); + public static RoutePattern Parse(string pattern, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies); + public static RoutePattern Parse(string pattern, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, RouteValueDictionary? requiredValues); public static RoutePattern Parse(string pattern, object? defaults, object? parameterPolicies); public static RoutePattern Parse(string pattern, object? defaults, object? parameterPolicies, object? requiredValues); + public static RoutePattern Pattern(RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, params RoutePatternPathSegment[] segments); + public static RoutePattern Pattern(RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); public static RoutePattern Pattern(object? defaults, object? parameterPolicies, params RoutePatternPathSegment[] segments); public static RoutePattern Pattern(object? defaults, object? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); + public static RoutePattern Pattern(string? rawText, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, params RoutePatternPathSegment[] segments); + public static RoutePattern Pattern(string? rawText, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); public static RoutePattern Pattern(string? rawText, object? defaults, object? parameterPolicies, params RoutePatternPathSegment[] segments); public static RoutePattern Pattern(string? rawText, object? defaults, object? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); } public abstract class RoutePatternTransformer { + public virtual RoutePattern? SubstituteRequiredValues(RoutePattern original, RouteValueDictionary requiredValues); public abstract RoutePattern? SubstituteRequiredValues(RoutePattern original, object requiredValues); } }","title":"Microsoft.AspNetCore.Routing.Patterns"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Routing.Patterns/#microsoftaspnetcoreroutingpatterns","text":"namespace Microsoft.AspNetCore.Routing.Patterns { public sealed class RoutePatternException : Exception { public RoutePatternException(string pattern, string message); } public static class RoutePatternFactory { + public static RoutePattern Combine(RoutePattern? left, RoutePattern right); public static RoutePattern Parse(string pattern); + public static RoutePattern Parse(string pattern, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies); + public static RoutePattern Parse(string pattern, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, RouteValueDictionary? requiredValues); public static RoutePattern Parse(string pattern, object? defaults, object? parameterPolicies); public static RoutePattern Parse(string pattern, object? defaults, object? parameterPolicies, object? requiredValues); + public static RoutePattern Pattern(RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, params RoutePatternPathSegment[] segments); + public static RoutePattern Pattern(RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); public static RoutePattern Pattern(object? defaults, object? parameterPolicies, params RoutePatternPathSegment[] segments); public static RoutePattern Pattern(object? defaults, object? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); + public static RoutePattern Pattern(string? rawText, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, params RoutePatternPathSegment[] segments); + public static RoutePattern Pattern(string? rawText, RouteValueDictionary? defaults, RouteValueDictionary? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); public static RoutePattern Pattern(string? rawText, object? defaults, object? parameterPolicies, params RoutePatternPathSegment[] segments); public static RoutePattern Pattern(string? rawText, object? defaults, object? parameterPolicies, IEnumerable<RoutePatternPathSegment> segments); } public abstract class RoutePatternTransformer { + public virtual RoutePattern? SubstituteRequiredValues(RoutePattern original, RouteValueDictionary requiredValues); public abstract RoutePattern? SubstituteRequiredValues(RoutePattern original, object requiredValues); } }","title":"Microsoft.AspNetCore.Routing.Patterns"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Routing/","text":"Microsoft.AspNetCore.Routing namespace Microsoft.AspNetCore.Routing { - public sealed class CompositeEndpointDataSource : EndpointDataSource { + public sealed class CompositeEndpointDataSource : EndpointDataSource, IDisposable { + public void Dispose(); + public override IReadOnlyList<Endpoint> GetGroupedEndpoints(RouteGroupContext context); } public sealed class DefaultEndpointDataSource : EndpointDataSource public abstract class EndpointDataSource { + public virtual IReadOnlyList<Endpoint> GetGroupedEndpoints(RouteGroupContext context); } public sealed class HttpMethodMetadata : IHttpMethodMetadata { - public bool AcceptCorsPreflight { get; } + public bool AcceptCorsPreflight { get; set; } } public interface IHttpMethodMetadata { - bool AcceptCorsPreflight { get; } + bool AcceptCorsPreflight { get; set; } } public static class LinkGeneratorEndpointNameAddressExtensions { + public static string? GetPathByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, RouteValueDictionary? values = null, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetPathByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, object? values, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); + public static string? GetPathByName(this LinkGenerator generator, string endpointName, RouteValueDictionary? values = null, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetPathByName(this LinkGenerator generator, string endpointName, object? values, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); + public static string? GetUriByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, RouteValueDictionary? values = null, string? scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetUriByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, object? values, string? scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); + public static string? GetUriByName(this LinkGenerator generator, string endpointName, RouteValueDictionary values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetUriByName(this LinkGenerator generator, string endpointName, object? values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); } public static class LinkGeneratorRouteValuesAddressExtensions { + public static string GetPathByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, RouteValueDictionary values = null, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); public static string GetPathByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, object values, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); + public static string GetPathByRouteValues(this LinkGenerator generator, string routeName, RouteValueDictionary values = null, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions options = null); public static string GetPathByRouteValues(this LinkGenerator generator, string routeName, object values, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions options = null); + public static string GetUriByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, RouteValueDictionary values = null, string scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); public static string GetUriByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, object values, string scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); + public static string? GetUriByRouteValues(this LinkGenerator generator, string? routeName, RouteValueDictionary values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string GetUriByRouteValues(this LinkGenerator generator, string routeName, object values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions options = null); } public static class RequestDelegateRouteBuilderExtensions { public static IRouteBuilder MapDelete(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapDelete(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapGet(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapGet(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapMiddlewareDelete(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewareGet(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewarePost(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewarePut(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewareRoute(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewareVerb(this IRouteBuilder builder, string verb, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapPost(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapPost(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapPut(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapPut(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapRoute(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapVerb(this IRouteBuilder builder, string verb, string template, RequestDelegate handler); public static IRouteBuilder MapVerb(this IRouteBuilder builder, string verb, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); } public class Route : RouteBase { public Route(IRouter target, string routeTemplate, IInlineConstraintResolver inlineConstraintResolver); public Route(IRouter target, string routeTemplate, RouteValueDictionary? defaults, IDictionary<string, object>? constraints, RouteValueDictionary? dataTokens, IInlineConstraintResolver inlineConstraintResolver); public Route(IRouter target, string? routeName, string? routeTemplate, RouteValueDictionary? defaults, IDictionary<string, object>? constraints, RouteValueDictionary? dataTokens, IInlineConstraintResolver inlineConstraintResolver); } public abstract class RouteBase : INamedRouter, IRouter { public RouteBase(string? template, string? name, IInlineConstraintResolver constraintResolver, RouteValueDictionary? defaults, IDictionary<string, object>? constraints, RouteValueDictionary? dataTokens); } public class RouteCollection : IRouteCollection, IRouter { public virtual Task RouteAsync(RouteContext context); } public sealed class RouteEndpointBuilder : EndpointBuilder { - public RouteEndpointBuilder(RequestDelegate requestDelegate, RoutePattern routePattern, int order); + public RouteEndpointBuilder(RequestDelegate? requestDelegate, RoutePattern routePattern, int order); } + public sealed class RouteGroupBuilder : IEndpointConventionBuilder, IEndpointRouteBuilder { + ICollection<EndpointDataSource> Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.DataSources { get; } + IServiceProvider Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.ServiceProvider { get; } + void IEndpointConventionBuilder.Add(Action<EndpointBuilder> convention); + void IEndpointConventionBuilder.Finally(Action<EndpointBuilder> finalConvention); + IApplicationBuilder IEndpointRouteBuilder.CreateApplicationBuilder(); + } + public sealed class RouteGroupContext { + public RouteGroupContext(); + public IServiceProvider ApplicationServices { get; set; } + public IReadOnlyList<Action<EndpointBuilder>> Conventions { get; set; } + public IReadOnlyList<Action<EndpointBuilder>> FinallyConventions { get; set; } + public required RoutePattern Prefix { get; set; } + } public class RouteOptions { public IDictionary<string, Type> ConstraintMap { get; set; } + public void SetParameterPolicy(string token, Type type); + public void SetParameterPolicy<T>(string token) where T : IParameterPolicy; } public class RouteValueDictionary : ICollection<KeyValuePair<string, object?>>, IDictionary<string, object?>, IEnumerable, IEnumerable<KeyValuePair<string, object?>>, IReadOnlyCollection<KeyValuePair<string, object?>>, IReadOnlyDictionary<string, object?> { + public RouteValueDictionary(RouteValueDictionary? dictionary); + public RouteValueDictionary(IEnumerable<KeyValuePair<string, object?>>? values); + public RouteValueDictionary(IEnumerable<KeyValuePair<string, string?>>? values); public RouteValueDictionary(object? values); } public class RouteValuesAddress { + public override string ToString(); } }","title":"Microsoft.AspNetCore.Routing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Routing/#microsoftaspnetcorerouting","text":"namespace Microsoft.AspNetCore.Routing { - public sealed class CompositeEndpointDataSource : EndpointDataSource { + public sealed class CompositeEndpointDataSource : EndpointDataSource, IDisposable { + public void Dispose(); + public override IReadOnlyList<Endpoint> GetGroupedEndpoints(RouteGroupContext context); } public sealed class DefaultEndpointDataSource : EndpointDataSource public abstract class EndpointDataSource { + public virtual IReadOnlyList<Endpoint> GetGroupedEndpoints(RouteGroupContext context); } public sealed class HttpMethodMetadata : IHttpMethodMetadata { - public bool AcceptCorsPreflight { get; } + public bool AcceptCorsPreflight { get; set; } } public interface IHttpMethodMetadata { - bool AcceptCorsPreflight { get; } + bool AcceptCorsPreflight { get; set; } } public static class LinkGeneratorEndpointNameAddressExtensions { + public static string? GetPathByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, RouteValueDictionary? values = null, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetPathByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, object? values, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); + public static string? GetPathByName(this LinkGenerator generator, string endpointName, RouteValueDictionary? values = null, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetPathByName(this LinkGenerator generator, string endpointName, object? values, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); + public static string? GetUriByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, RouteValueDictionary? values = null, string? scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetUriByName(this LinkGenerator generator, HttpContext httpContext, string endpointName, object? values, string? scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions? options = null); + public static string? GetUriByName(this LinkGenerator generator, string endpointName, RouteValueDictionary values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string? GetUriByName(this LinkGenerator generator, string endpointName, object? values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); } public static class LinkGeneratorRouteValuesAddressExtensions { + public static string GetPathByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, RouteValueDictionary values = null, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); public static string GetPathByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, object values, PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); + public static string GetPathByRouteValues(this LinkGenerator generator, string routeName, RouteValueDictionary values = null, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions options = null); public static string GetPathByRouteValues(this LinkGenerator generator, string routeName, object values, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions options = null); + public static string GetUriByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, RouteValueDictionary values = null, string scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); public static string GetUriByRouteValues(this LinkGenerator generator, HttpContext httpContext, string routeName, object values, string scheme = null, HostString? host = default(HostString?), PathString? pathBase = default(PathString?), FragmentString fragment = default(FragmentString), LinkOptions options = null); + public static string? GetUriByRouteValues(this LinkGenerator generator, string? routeName, RouteValueDictionary values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions? options = null); public static string GetUriByRouteValues(this LinkGenerator generator, string routeName, object values, string scheme, HostString host, PathString pathBase = default(PathString), FragmentString fragment = default(FragmentString), LinkOptions options = null); } public static class RequestDelegateRouteBuilderExtensions { public static IRouteBuilder MapDelete(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapDelete(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapGet(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapGet(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapMiddlewareDelete(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewareGet(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewarePost(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewarePut(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewareRoute(this IRouteBuilder builder, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapMiddlewareVerb(this IRouteBuilder builder, string verb, string template, Action<IApplicationBuilder> action); public static IRouteBuilder MapPost(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapPost(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapPut(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapPut(this IRouteBuilder builder, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); public static IRouteBuilder MapRoute(this IRouteBuilder builder, string template, RequestDelegate handler); public static IRouteBuilder MapVerb(this IRouteBuilder builder, string verb, string template, RequestDelegate handler); public static IRouteBuilder MapVerb(this IRouteBuilder builder, string verb, string template, Func<HttpRequest, HttpResponse, RouteData, Task> handler); } public class Route : RouteBase { public Route(IRouter target, string routeTemplate, IInlineConstraintResolver inlineConstraintResolver); public Route(IRouter target, string routeTemplate, RouteValueDictionary? defaults, IDictionary<string, object>? constraints, RouteValueDictionary? dataTokens, IInlineConstraintResolver inlineConstraintResolver); public Route(IRouter target, string? routeName, string? routeTemplate, RouteValueDictionary? defaults, IDictionary<string, object>? constraints, RouteValueDictionary? dataTokens, IInlineConstraintResolver inlineConstraintResolver); } public abstract class RouteBase : INamedRouter, IRouter { public RouteBase(string? template, string? name, IInlineConstraintResolver constraintResolver, RouteValueDictionary? defaults, IDictionary<string, object>? constraints, RouteValueDictionary? dataTokens); } public class RouteCollection : IRouteCollection, IRouter { public virtual Task RouteAsync(RouteContext context); } public sealed class RouteEndpointBuilder : EndpointBuilder { - public RouteEndpointBuilder(RequestDelegate requestDelegate, RoutePattern routePattern, int order); + public RouteEndpointBuilder(RequestDelegate? requestDelegate, RoutePattern routePattern, int order); } + public sealed class RouteGroupBuilder : IEndpointConventionBuilder, IEndpointRouteBuilder { + ICollection<EndpointDataSource> Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.DataSources { get; } + IServiceProvider Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.ServiceProvider { get; } + void IEndpointConventionBuilder.Add(Action<EndpointBuilder> convention); + void IEndpointConventionBuilder.Finally(Action<EndpointBuilder> finalConvention); + IApplicationBuilder IEndpointRouteBuilder.CreateApplicationBuilder(); + } + public sealed class RouteGroupContext { + public RouteGroupContext(); + public IServiceProvider ApplicationServices { get; set; } + public IReadOnlyList<Action<EndpointBuilder>> Conventions { get; set; } + public IReadOnlyList<Action<EndpointBuilder>> FinallyConventions { get; set; } + public required RoutePattern Prefix { get; set; } + } public class RouteOptions { public IDictionary<string, Type> ConstraintMap { get; set; } + public void SetParameterPolicy(string token, Type type); + public void SetParameterPolicy<T>(string token) where T : IParameterPolicy; } public class RouteValueDictionary : ICollection<KeyValuePair<string, object?>>, IDictionary<string, object?>, IEnumerable, IEnumerable<KeyValuePair<string, object?>>, IReadOnlyCollection<KeyValuePair<string, object?>>, IReadOnlyDictionary<string, object?> { + public RouteValueDictionary(RouteValueDictionary? dictionary); + public RouteValueDictionary(IEnumerable<KeyValuePair<string, object?>>? values); + public RouteValueDictionary(IEnumerable<KeyValuePair<string, string?>>? values); public RouteValueDictionary(object? values); } public class RouteValuesAddress { + public override string ToString(); } }","title":"Microsoft.AspNetCore.Routing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.IIS.Core/","text":"Microsoft.AspNetCore.Server.IIS.Core namespace Microsoft.AspNetCore.Server.IIS.Core { public abstract class WriteOnlyStream : Stream { + public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken); } }","title":"Microsoft.AspNetCore.Server.IIS.Core"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.IIS.Core/#microsoftaspnetcoreserveriiscore","text":"namespace Microsoft.AspNetCore.Server.IIS.Core { public abstract class WriteOnlyStream : Stream { + public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken); } }","title":"Microsoft.AspNetCore.Server.IIS.Core"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Core/","text":"Microsoft.AspNetCore.Server.Kestrel.Core namespace Microsoft.AspNetCore.Server.Kestrel.Core { public enum HttpProtocols { Http1AndHttp2AndHttp3 = 7, Http3 = 4, } }","title":"Microsoft.AspNetCore.Server.Kestrel.Core"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Core/#microsoftaspnetcoreserverkestrelcore","text":"namespace Microsoft.AspNetCore.Server.Kestrel.Core { public enum HttpProtocols { Http1AndHttp2AndHttp3 = 7, Http3 = 4, } }","title":"Microsoft.AspNetCore.Server.Kestrel.Core"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Https/","text":"Microsoft.AspNetCore.Server.Kestrel.Https namespace Microsoft.AspNetCore.Server.Kestrel.Https { public class HttpsConnectionAdapterOptions { + public X509Certificate2Collection ServerCertificateChain { get; set; } } }","title":"Microsoft.AspNetCore.Server.Kestrel.Https"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Https/#microsoftaspnetcoreserverkestrelhttps","text":"namespace Microsoft.AspNetCore.Server.Kestrel.Https { public class HttpsConnectionAdapterOptions { + public X509Certificate2Collection ServerCertificateChain { get; set; } } }","title":"Microsoft.AspNetCore.Server.Kestrel.Https"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Transport.Quic/","text":"Microsoft.AspNetCore.Server.Kestrel.Transport.Quic namespace Microsoft.AspNetCore.Server.Kestrel.Transport.Quic { - public class QuicTransportOptions { + public sealed class QuicTransportOptions { + public long DefaultCloseErrorCode { get; set; } + public long DefaultStreamErrorCode { get; set; } - public TimeSpan IdleTimeout { get; set; } - public ushort MaxBidirectionalStreamCount { get; set; } + public int MaxBidirectionalStreamCount { get; set; } public long? MaxReadBufferSize { get; set; } - public ushort MaxUnidirectionalStreamCount { get; set; } + public int MaxUnidirectionalStreamCount { get; set; } public long? MaxWriteBufferSize { get; set; } } }","title":"Microsoft.AspNetCore.Server.Kestrel.Transport.Quic"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.Server.Kestrel.Transport.Quic/#microsoftaspnetcoreserverkestreltransportquic","text":"namespace Microsoft.AspNetCore.Server.Kestrel.Transport.Quic { - public class QuicTransportOptions { + public sealed class QuicTransportOptions { + public long DefaultCloseErrorCode { get; set; } + public long DefaultStreamErrorCode { get; set; } - public TimeSpan IdleTimeout { get; set; } - public ushort MaxBidirectionalStreamCount { get; set; } + public int MaxBidirectionalStreamCount { get; set; } public long? MaxReadBufferSize { get; set; } - public ushort MaxUnidirectionalStreamCount { get; set; } + public int MaxUnidirectionalStreamCount { get; set; } public long? MaxWriteBufferSize { get; set; } } }","title":"Microsoft.AspNetCore.Server.Kestrel.Transport.Quic"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.SignalR.Protocol/","text":"Microsoft.AspNetCore.SignalR.Protocol namespace Microsoft.AspNetCore.SignalR.Protocol { + public sealed class RawResult { + public RawResult(ReadOnlySequence<byte> rawBytes); + public ReadOnlySequence<byte> RawSerializedData { get; } + } }","title":"Microsoft.AspNetCore.SignalR.Protocol"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.SignalR.Protocol/#microsoftaspnetcoresignalrprotocol","text":"namespace Microsoft.AspNetCore.SignalR.Protocol { + public sealed class RawResult { + public RawResult(ReadOnlySequence<byte> rawBytes); + public ReadOnlySequence<byte> RawSerializedData { get; } + } }","title":"Microsoft.AspNetCore.SignalR.Protocol"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.SignalR/","text":"Microsoft.AspNetCore.SignalR namespace Microsoft.AspNetCore.SignalR { public static class ClientProxyExtensions { + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, object arg9, object arg10, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, object arg9, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object? arg1, object? arg2, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object? arg1, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, CancellationToken cancellationToken); } public class DefaultHubLifetimeManager<THub> : HubLifetimeManager<THub> where THub : Hub { + public override Task<T> InvokeConnectionAsync<T>(string connectionId, string methodName, object?[] args, CancellationToken cancellationToken); + public override Task SetConnectionResultAsync(string connectionId, CompletionMessage result); + public override bool TryGetReturnType(string invocationId, out Type? type); } public abstract class HubLifetimeManager<THub> where THub : Hub { + public virtual Task<T> InvokeConnectionAsync<T>(string connectionId, string methodName, object?[] args, CancellationToken cancellationToken); + public virtual Task SetConnectionResultAsync(string connectionId, CompletionMessage result); + public virtual bool TryGetReturnType(string invocationId, out Type? type); } public class HubOptions { + public bool DisableImplicitFromServicesParameters { get; set; } } public interface IHubCallerClients : IHubCallerClients<IClientProxy>, IHubClients<IClientProxy> { + new ISingleClientProxy Caller { get; } + new ISingleClientProxy Client(string connectionId); } public interface IHubClients : IHubClients<IClientProxy> { + new ISingleClientProxy Client(string connectionId); } public interface IInvocationBinder { + string? GetTarget(ReadOnlySpan<byte> utf8Bytes); } + public interface ISingleClientProxy : IClientProxy { + Task<T> InvokeCoreAsync<T>(string method, object?[] args, CancellationToken cancellationToken); + } }","title":"Microsoft.AspNetCore.SignalR"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.SignalR/#microsoftaspnetcoresignalr","text":"namespace Microsoft.AspNetCore.SignalR { public static class ClientProxyExtensions { + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, object arg9, object arg10, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, object arg9, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, object arg5, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, object arg4, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object arg1, object arg2, object arg3, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object? arg1, object? arg2, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, object? arg1, CancellationToken cancellationToken); + public static Task<T> InvokeAsync<T>(this ISingleClientProxy clientProxy, string method, CancellationToken cancellationToken); } public class DefaultHubLifetimeManager<THub> : HubLifetimeManager<THub> where THub : Hub { + public override Task<T> InvokeConnectionAsync<T>(string connectionId, string methodName, object?[] args, CancellationToken cancellationToken); + public override Task SetConnectionResultAsync(string connectionId, CompletionMessage result); + public override bool TryGetReturnType(string invocationId, out Type? type); } public abstract class HubLifetimeManager<THub> where THub : Hub { + public virtual Task<T> InvokeConnectionAsync<T>(string connectionId, string methodName, object?[] args, CancellationToken cancellationToken); + public virtual Task SetConnectionResultAsync(string connectionId, CompletionMessage result); + public virtual bool TryGetReturnType(string invocationId, out Type? type); } public class HubOptions { + public bool DisableImplicitFromServicesParameters { get; set; } } public interface IHubCallerClients : IHubCallerClients<IClientProxy>, IHubClients<IClientProxy> { + new ISingleClientProxy Caller { get; } + new ISingleClientProxy Client(string connectionId); } public interface IHubClients : IHubClients<IClientProxy> { + new ISingleClientProxy Client(string connectionId); } public interface IInvocationBinder { + string? GetTarget(ReadOnlySpan<byte> utf8Bytes); } + public interface ISingleClientProxy : IClientProxy { + Task<T> InvokeCoreAsync<T>(string method, object?[] args, CancellationToken cancellationToken); + } }","title":"Microsoft.AspNetCore.SignalR"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.WebUtilities/","text":"Microsoft.AspNetCore.WebUtilities namespace Microsoft.AspNetCore.WebUtilities { public class BufferedReadStream : Stream { public Task<bool> EnsureBufferedAsync(int minCount, CancellationToken cancellationToken); public Task<bool> EnsureBufferedAsync(CancellationToken cancellationToken); public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken); public Task<string> ReadLineAsync(int lengthLimit, CancellationToken cancellationToken); + public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken); } public class FileBufferingReadStream : Stream { public override ValueTask DisposeAsync(); + public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken); } public sealed class FileBufferingWriteStream : Stream { public override ValueTask DisposeAsync(); public Task DrainBufferAsync(PipeWriter destination, CancellationToken cancellationToken = default(CancellationToken)); public Task DrainBufferAsync(Stream destination, CancellationToken cancellationToken = default(CancellationToken)); + public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken); public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken); public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); } public class FormMultipartSection { + public ValueTask<string> GetValueAsync(CancellationToken cancellationToken); } public class HttpResponseStreamWriter : TextWriter { public override ValueTask DisposeAsync(); + public override Task WriteLineAsync(char value); + public override Task WriteLineAsync(char[] values, int index, int count); + public override Task WriteLineAsync(string? value); } public static class MultipartSectionStreamExtensions { public static Task<string> ReadAsStringAsync(this MultipartSection section); + public static ValueTask<string> ReadAsStringAsync(this MultipartSection section, CancellationToken cancellationToken); } }","title":"Microsoft.AspNetCore.WebUtilities"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.AspNetCore.WebUtilities/#microsoftaspnetcorewebutilities","text":"namespace Microsoft.AspNetCore.WebUtilities { public class BufferedReadStream : Stream { public Task<bool> EnsureBufferedAsync(int minCount, CancellationToken cancellationToken); public Task<bool> EnsureBufferedAsync(CancellationToken cancellationToken); public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken); public Task<string> ReadLineAsync(int lengthLimit, CancellationToken cancellationToken); + public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken); } public class FileBufferingReadStream : Stream { public override ValueTask DisposeAsync(); + public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken); } public sealed class FileBufferingWriteStream : Stream { public override ValueTask DisposeAsync(); public Task DrainBufferAsync(PipeWriter destination, CancellationToken cancellationToken = default(CancellationToken)); public Task DrainBufferAsync(Stream destination, CancellationToken cancellationToken = default(CancellationToken)); + public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken); public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken); public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); } public class FormMultipartSection { + public ValueTask<string> GetValueAsync(CancellationToken cancellationToken); } public class HttpResponseStreamWriter : TextWriter { public override ValueTask DisposeAsync(); + public override Task WriteLineAsync(char value); + public override Task WriteLineAsync(char[] values, int index, int count); + public override Task WriteLineAsync(string? value); } public static class MultipartSectionStreamExtensions { public static Task<string> ReadAsStringAsync(this MultipartSection section); + public static ValueTask<string> ReadAsStringAsync(this MultipartSection section, CancellationToken cancellationToken); } }","title":"Microsoft.AspNetCore.WebUtilities"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Caching.Distributed/","text":"Microsoft.Extensions.Caching.Distributed namespace Microsoft.Extensions.Caching.Distributed { public static class DistributedCacheExtensions { - public static string GetString(this IDistributedCache cache, string key); + public static string? GetString(this IDistributedCache cache, string key); - public static Task<string> GetStringAsync(this IDistributedCache cache, string key, CancellationToken token = default(CancellationToken)); + public static Task<string?> GetStringAsync(this IDistributedCache cache, string key, CancellationToken token = default(CancellationToken)); } public interface IDistributedCache { - byte[] Get(string key); + byte[]? Get(string key); - Task<byte[]> GetAsync(string key, CancellationToken token = default(CancellationToken)); + Task<byte[]?> GetAsync(string key, CancellationToken token = default(CancellationToken)); } public class MemoryDistributedCache : IDistributedCache { - public byte[] Get(string key); + public byte[]? Get(string key); - public Task<byte[]> GetAsync(string key, CancellationToken token = default(CancellationToken)); + public Task<byte[]?> GetAsync(string key, CancellationToken token = default(CancellationToken)); } }","title":"Microsoft.Extensions.Caching.Distributed"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Caching.Distributed/#microsoftextensionscachingdistributed","text":"namespace Microsoft.Extensions.Caching.Distributed { public static class DistributedCacheExtensions { - public static string GetString(this IDistributedCache cache, string key); + public static string? GetString(this IDistributedCache cache, string key); - public static Task<string> GetStringAsync(this IDistributedCache cache, string key, CancellationToken token = default(CancellationToken)); + public static Task<string?> GetStringAsync(this IDistributedCache cache, string key, CancellationToken token = default(CancellationToken)); } public interface IDistributedCache { - byte[] Get(string key); + byte[]? Get(string key); - Task<byte[]> GetAsync(string key, CancellationToken token = default(CancellationToken)); + Task<byte[]?> GetAsync(string key, CancellationToken token = default(CancellationToken)); } public class MemoryDistributedCache : IDistributedCache { - public byte[] Get(string key); + public byte[]? Get(string key); - public Task<byte[]> GetAsync(string key, CancellationToken token = default(CancellationToken)); + public Task<byte[]?> GetAsync(string key, CancellationToken token = default(CancellationToken)); } }","title":"Microsoft.Extensions.Caching.Distributed"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Caching.Memory/","text":"Microsoft.Extensions.Caching.Memory namespace Microsoft.Extensions.Caching.Memory { public static class CacheEntryExtensions { - public static ICacheEntry RegisterPostEvictionCallback(this ICacheEntry entry, PostEvictionDelegate callback, object state); + public static ICacheEntry RegisterPostEvictionCallback(this ICacheEntry entry, PostEvictionDelegate callback, object? state); } public static class CacheExtensions { - public static object Get(this IMemoryCache cache, object key); + public static object? Get(this IMemoryCache cache, object key); - public static TItem Get<TItem>(this IMemoryCache cache, object key); + public static TItem? Get<TItem>(this IMemoryCache cache, object key); - public static TItem GetOrCreate<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, TItem> factory); + public static TItem? GetOrCreate<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, TItem> factory); - public static Task<TItem> GetOrCreateAsync<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, Task<TItem>> factory); + public static Task<TItem?> GetOrCreateAsync<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, Task<TItem>> factory); - public static TItem Set<TItem>(this IMemoryCache cache, object key, TItem value, MemoryCacheEntryOptions options); + public static TItem Set<TItem>(this IMemoryCache cache, object key, TItem value, MemoryCacheEntryOptions? options); - public static bool TryGetValue<TItem>(this IMemoryCache cache, object key, out TItem value); + public static bool TryGetValue<TItem>(this IMemoryCache cache, object key, out TItem? value); } public interface ICacheEntry : IDisposable { - object Value { get; set; } + object? Value { get; set; } } public interface IMemoryCache : IDisposable { + MemoryCacheStatistics? GetCurrentStatistics(); - bool TryGetValue(object key, out object value); + bool TryGetValue(object key, out object? value); } public class MemoryCache : IDisposable, IMemoryCache { + public void Clear(); + public MemoryCacheStatistics? GetCurrentStatistics(); - public bool TryGetValue(object key, out object result); + public bool TryGetValue(object key, out object? result); } public static class MemoryCacheEntryExtensions { - public static MemoryCacheEntryOptions RegisterPostEvictionCallback(this MemoryCacheEntryOptions options, PostEvictionDelegate callback, object state); + public static MemoryCacheEntryOptions RegisterPostEvictionCallback(this MemoryCacheEntryOptions options, PostEvictionDelegate callback, object? state); } public class MemoryCacheOptions : IOptions<MemoryCacheOptions> { - MemoryCacheOptions Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>.Value { get; } + MemoryCacheOptions IOptions<MemoryCacheOptions>.Value { get; } + public bool TrackLinkedCacheEntries { get; set; } + public bool TrackStatistics { get; set; } } + public class MemoryCacheStatistics { + public MemoryCacheStatistics(); + public long CurrentEntryCount { get; set; } + public long? CurrentEstimatedSize { get; set; } + public long TotalHits { get; set; } + public long TotalMisses { get; set; } + } - public delegate void PostEvictionDelegate(object key, object value, EvictionReason reason, object state); + public delegate void PostEvictionDelegate(object key, object? value, EvictionReason reason, object? state); }","title":"Microsoft.Extensions.Caching.Memory"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Caching.Memory/#microsoftextensionscachingmemory","text":"namespace Microsoft.Extensions.Caching.Memory { public static class CacheEntryExtensions { - public static ICacheEntry RegisterPostEvictionCallback(this ICacheEntry entry, PostEvictionDelegate callback, object state); + public static ICacheEntry RegisterPostEvictionCallback(this ICacheEntry entry, PostEvictionDelegate callback, object? state); } public static class CacheExtensions { - public static object Get(this IMemoryCache cache, object key); + public static object? Get(this IMemoryCache cache, object key); - public static TItem Get<TItem>(this IMemoryCache cache, object key); + public static TItem? Get<TItem>(this IMemoryCache cache, object key); - public static TItem GetOrCreate<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, TItem> factory); + public static TItem? GetOrCreate<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, TItem> factory); - public static Task<TItem> GetOrCreateAsync<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, Task<TItem>> factory); + public static Task<TItem?> GetOrCreateAsync<TItem>(this IMemoryCache cache, object key, Func<ICacheEntry, Task<TItem>> factory); - public static TItem Set<TItem>(this IMemoryCache cache, object key, TItem value, MemoryCacheEntryOptions options); + public static TItem Set<TItem>(this IMemoryCache cache, object key, TItem value, MemoryCacheEntryOptions? options); - public static bool TryGetValue<TItem>(this IMemoryCache cache, object key, out TItem value); + public static bool TryGetValue<TItem>(this IMemoryCache cache, object key, out TItem? value); } public interface ICacheEntry : IDisposable { - object Value { get; set; } + object? Value { get; set; } } public interface IMemoryCache : IDisposable { + MemoryCacheStatistics? GetCurrentStatistics(); - bool TryGetValue(object key, out object value); + bool TryGetValue(object key, out object? value); } public class MemoryCache : IDisposable, IMemoryCache { + public void Clear(); + public MemoryCacheStatistics? GetCurrentStatistics(); - public bool TryGetValue(object key, out object result); + public bool TryGetValue(object key, out object? result); } public static class MemoryCacheEntryExtensions { - public static MemoryCacheEntryOptions RegisterPostEvictionCallback(this MemoryCacheEntryOptions options, PostEvictionDelegate callback, object state); + public static MemoryCacheEntryOptions RegisterPostEvictionCallback(this MemoryCacheEntryOptions options, PostEvictionDelegate callback, object? state); } public class MemoryCacheOptions : IOptions<MemoryCacheOptions> { - MemoryCacheOptions Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>.Value { get; } + MemoryCacheOptions IOptions<MemoryCacheOptions>.Value { get; } + public bool TrackLinkedCacheEntries { get; set; } + public bool TrackStatistics { get; set; } } + public class MemoryCacheStatistics { + public MemoryCacheStatistics(); + public long CurrentEntryCount { get; set; } + public long? CurrentEstimatedSize { get; set; } + public long TotalHits { get; set; } + public long TotalMisses { get; set; } + } - public delegate void PostEvictionDelegate(object key, object value, EvictionReason reason, object state); + public delegate void PostEvictionDelegate(object key, object? value, EvictionReason reason, object? state); }","title":"Microsoft.Extensions.Caching.Memory"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.CommandLine/","text":"Microsoft.Extensions.Configuration.CommandLine namespace Microsoft.Extensions.Configuration.CommandLine { public class CommandLineConfigurationProvider : ConfigurationProvider { - public CommandLineConfigurationProvider(IEnumerable<string> args, IDictionary<string, string> switchMappings = null); + public CommandLineConfigurationProvider(IEnumerable<string> args, IDictionary<string, string>? switchMappings = null); } public class CommandLineConfigurationSource : IConfigurationSource { - public IDictionary<string, string> SwitchMappings { get; set; } + public IDictionary<string, string>? SwitchMappings { get; set; } } }","title":"Microsoft.Extensions.Configuration.CommandLine"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.CommandLine/#microsoftextensionsconfigurationcommandline","text":"namespace Microsoft.Extensions.Configuration.CommandLine { public class CommandLineConfigurationProvider : ConfigurationProvider { - public CommandLineConfigurationProvider(IEnumerable<string> args, IDictionary<string, string> switchMappings = null); + public CommandLineConfigurationProvider(IEnumerable<string> args, IDictionary<string, string>? switchMappings = null); } public class CommandLineConfigurationSource : IConfigurationSource { - public IDictionary<string, string> SwitchMappings { get; set; } + public IDictionary<string, string>? SwitchMappings { get; set; } } }","title":"Microsoft.Extensions.Configuration.CommandLine"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.EnvironmentVariables/","text":"Microsoft.Extensions.Configuration.EnvironmentVariables namespace Microsoft.Extensions.Configuration.EnvironmentVariables { public class EnvironmentVariablesConfigurationProvider : ConfigurationProvider { - public EnvironmentVariablesConfigurationProvider(string prefix); + public EnvironmentVariablesConfigurationProvider(string? prefix); } }","title":"Microsoft.Extensions.Configuration.EnvironmentVariables"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.EnvironmentVariables/#microsoftextensionsconfigurationenvironmentvariables","text":"namespace Microsoft.Extensions.Configuration.EnvironmentVariables { public class EnvironmentVariablesConfigurationProvider : ConfigurationProvider { - public EnvironmentVariablesConfigurationProvider(string prefix); + public EnvironmentVariablesConfigurationProvider(string? prefix); } }","title":"Microsoft.Extensions.Configuration.EnvironmentVariables"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Ini/","text":"Microsoft.Extensions.Configuration.Ini namespace Microsoft.Extensions.Configuration.Ini { public class IniStreamConfigurationProvider : StreamConfigurationProvider { - public static IDictionary<string, string> Read(Stream stream); + public static IDictionary<string, string?> Read(Stream stream); } }","title":"Microsoft.Extensions.Configuration.Ini"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Ini/#microsoftextensionsconfigurationini","text":"namespace Microsoft.Extensions.Configuration.Ini { public class IniStreamConfigurationProvider : StreamConfigurationProvider { - public static IDictionary<string, string> Read(Stream stream); + public static IDictionary<string, string?> Read(Stream stream); } }","title":"Microsoft.Extensions.Configuration.Ini"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Memory/","text":"Microsoft.Extensions.Configuration.Memory namespace Microsoft.Extensions.Configuration.Memory { - public class MemoryConfigurationProvider : ConfigurationProvider, IEnumerable, IEnumerable<KeyValuePair<string, string>> { + public class MemoryConfigurationProvider : ConfigurationProvider, IEnumerable, IEnumerable<KeyValuePair<string, string?>> { - public void Add(string key, string value); + public void Add(string key, string? value); - public IEnumerator<KeyValuePair<string, string>> GetEnumerator(); + public IEnumerator<KeyValuePair<string, string?>> GetEnumerator(); } public class MemoryConfigurationSource : IConfigurationSource { - public IEnumerable<KeyValuePair<string, string>> InitialData { get; set; } + public IEnumerable<KeyValuePair<string, string?>>? InitialData { get; set; } } }","title":"Microsoft.Extensions.Configuration.Memory"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Memory/#microsoftextensionsconfigurationmemory","text":"namespace Microsoft.Extensions.Configuration.Memory { - public class MemoryConfigurationProvider : ConfigurationProvider, IEnumerable, IEnumerable<KeyValuePair<string, string>> { + public class MemoryConfigurationProvider : ConfigurationProvider, IEnumerable, IEnumerable<KeyValuePair<string, string?>> { - public void Add(string key, string value); + public void Add(string key, string? value); - public IEnumerator<KeyValuePair<string, string>> GetEnumerator(); + public IEnumerator<KeyValuePair<string, string?>> GetEnumerator(); } public class MemoryConfigurationSource : IConfigurationSource { - public IEnumerable<KeyValuePair<string, string>> InitialData { get; set; } + public IEnumerable<KeyValuePair<string, string?>>? InitialData { get; set; } } }","title":"Microsoft.Extensions.Configuration.Memory"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Xml/","text":"Microsoft.Extensions.Configuration.Xml namespace Microsoft.Extensions.Configuration.Xml { public class XmlDocumentDecryptor { - public XmlReader CreateDecryptingXmlReader(Stream input, XmlReaderSettings settings); + public XmlReader CreateDecryptingXmlReader(Stream input, XmlReaderSettings? settings); protected virtual XmlReader DecryptDocumentAndCreateXmlReader(XmlDocument document); } public class XmlStreamConfigurationProvider : StreamConfigurationProvider { - public static IDictionary<string, string> Read(Stream stream, XmlDocumentDecryptor decryptor); + public static IDictionary<string, string?> Read(Stream stream, XmlDocumentDecryptor decryptor); } }","title":"Microsoft.Extensions.Configuration.Xml"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration.Xml/#microsoftextensionsconfigurationxml","text":"namespace Microsoft.Extensions.Configuration.Xml { public class XmlDocumentDecryptor { - public XmlReader CreateDecryptingXmlReader(Stream input, XmlReaderSettings settings); + public XmlReader CreateDecryptingXmlReader(Stream input, XmlReaderSettings? settings); protected virtual XmlReader DecryptDocumentAndCreateXmlReader(XmlDocument document); } public class XmlStreamConfigurationProvider : StreamConfigurationProvider { - public static IDictionary<string, string> Read(Stream stream, XmlDocumentDecryptor decryptor); + public static IDictionary<string, string?> Read(Stream stream, XmlDocumentDecryptor decryptor); } }","title":"Microsoft.Extensions.Configuration.Xml"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration/","text":"Microsoft.Extensions.Configuration namespace Microsoft.Extensions.Configuration { public class ChainedConfigurationProvider : IConfigurationProvider, IDisposable { + public IConfiguration Configuration { get; } - public IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string parentPath); + public IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath); - public void Set(string key, string value); + public void Set(string key, string? value); - public bool TryGet(string key, out string value); + public bool TryGet(string key, out string? value); } public class ChainedConfigurationSource : IConfigurationSource { public IConfiguration Configuration { get; set; } } public static class CommandLineConfigurationExtensions { - public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder builder, Action<CommandLineConfigurationSource> configureSource); + public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder builder, Action<CommandLineConfigurationSource>? configureSource); - public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder configurationBuilder, string[] args, IDictionary<string, string> switchMappings); + public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder configurationBuilder, string[] args, IDictionary<string, string>? switchMappings); } public static class ConfigurationBinder { - public static void Bind(this IConfiguration configuration, object instance); + public static void Bind(this IConfiguration configuration, object? instance); - public static void Bind(this IConfiguration configuration, object instance, Action<BinderOptions> configureOptions); + public static void Bind(this IConfiguration configuration, object? instance, Action<BinderOptions>? configureOptions); - public static void Bind(this IConfiguration configuration, string key, object instance); + public static void Bind(this IConfiguration configuration, string key, object? instance); - public static object Get(this IConfiguration configuration, Type type); + public static object? Get(this IConfiguration configuration, Type type); - public static object Get(this IConfiguration configuration, Type type, Action<BinderOptions> configureOptions); + public static object? Get(this IConfiguration configuration, Type type, Action<BinderOptions>? configureOptions); - public static T Get<T>(this IConfiguration configuration); + public static T? Get<T>(this IConfiguration configuration); - public static T Get<T>(this IConfiguration configuration, Action<BinderOptions> configureOptions); + public static T? Get<T>(this IConfiguration configuration, Action<BinderOptions>? configureOptions); - public static object GetValue(this IConfiguration configuration, Type type, string key); + public static object? GetValue(this IConfiguration configuration, Type type, string key); - public static object GetValue(this IConfiguration configuration, Type type, string key, object defaultValue); + public static object? GetValue(this IConfiguration configuration, Type type, string key, object? defaultValue); - public static T GetValue<T>(this IConfiguration configuration, string key); + public static T? GetValue<T>(this IConfiguration configuration, string key); - public static T GetValue<T>(this IConfiguration configuration, string key, T defaultValue); + public static T? GetValue<T>(this IConfiguration configuration, string key, T defaultValue); } + public readonly struct ConfigurationDebugViewContext { + public ConfigurationDebugViewContext(string path, string key, string? value, IConfigurationProvider configurationProvider); + public IConfigurationProvider ConfigurationProvider { get; } + public string Key { get; } + public string Path { get; } + public string? Value { get; } + } public static class ConfigurationExtensions { - public static IConfigurationBuilder Add<TSource>(this IConfigurationBuilder builder, Action<TSource> configureSource) where TSource : IConfigurationSource, new(); + public static IConfigurationBuilder Add<TSource>(this IConfigurationBuilder builder, Action<TSource>? configureSource) where TSource : IConfigurationSource, new(); - public static IEnumerable<KeyValuePair<string, string>> AsEnumerable(this IConfiguration configuration); + public static IEnumerable<KeyValuePair<string, string?>> AsEnumerable(this IConfiguration configuration); - public static IEnumerable<KeyValuePair<string, string>> AsEnumerable(this IConfiguration configuration, bool makePathsRelative); + public static IEnumerable<KeyValuePair<string, string?>> AsEnumerable(this IConfiguration configuration, bool makePathsRelative); - public static bool Exists(this IConfigurationSection section); + public static bool Exists(this IConfigurationSection? section); - public static string GetConnectionString(this IConfiguration configuration, string name); + public static string? GetConnectionString(this IConfiguration configuration, string name); } public class ConfigurationKeyComparer : IComparer<string> { - public int Compare(string x, string y); + public int Compare(string? x, string? y); } public sealed class ConfigurationManager : IConfiguration, IConfigurationBuilder, IConfigurationRoot, IDisposable { - IDictionary<string, object> Microsoft.Extensions.Configuration.IConfigurationBuilder.Properties { get; } + IDictionary<string, object> IConfigurationBuilder.Properties { get; } - IList<IConfigurationSource> Microsoft.Extensions.Configuration.IConfigurationBuilder.Sources { get; } - IEnumerable<IConfigurationProvider> Microsoft.Extensions.Configuration.IConfigurationRoot.Providers { get; } + IEnumerable<IConfigurationProvider> IConfigurationRoot.Providers { get; } + public IList<IConfigurationSource> Sources { get; } - public string this[string key] { get; set; } + public string? this[string key] { get; set; } } public static class ConfigurationPath { - public static string GetParentPath(string path); + public static string? GetParentPath(string? path); - public static string GetSectionKey(string path); + public static string? GetSectionKey(string? path); } public abstract class ConfigurationProvider : IConfigurationProvider { - protected IDictionary<string, string> Data { get; set; } + protected IDictionary<string, string?> Data { get; set; } - public virtual IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string parentPath); + public virtual IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath); - public virtual void Set(string key, string value); + public virtual void Set(string key, string? value); - public virtual bool TryGet(string key, out string value); + public virtual bool TryGet(string key, out string? value); } public class ConfigurationReloadToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } public class ConfigurationRoot : IConfiguration, IConfigurationRoot, IDisposable { - public string this[string key] { get; set; } + public string? this[string key] { get; set; } } public static class ConfigurationRootExtensions { + public static string GetDebugView(this IConfigurationRoot root, Func<ConfigurationDebugViewContext, string>? processValue); } public class ConfigurationSection : IConfiguration, IConfigurationSection { - public string this[string key] { get; set; } + public string? this[string key] { get; set; } - public string Value { get; set; } + public string? Value { get; set; } } public static class EnvironmentVariablesExtensions { - public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder builder, Action<EnvironmentVariablesConfigurationSource> configureSource); + public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder builder, Action<EnvironmentVariablesConfigurationSource>? configureSource); - public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder configurationBuilder, string prefix); + public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder configurationBuilder, string? prefix); } public static class FileConfigurationExtensions { - public static Action<FileLoadExceptionContext> GetFileLoadExceptionHandler(this IConfigurationBuilder builder); + public static Action<FileLoadExceptionContext>? GetFileLoadExceptionHandler(this IConfigurationBuilder builder); } public abstract class FileConfigurationSource : IConfigurationSource { - public Action<FileLoadExceptionContext> OnLoadException { get; set; } + public Action<FileLoadExceptionContext>? OnLoadException { get; set; } public string Path { get; set; } } public interface IConfiguration { - string this[string key] { get; set; } + string? this[string key] { get; set; } } public interface IConfigurationProvider { - IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string parentPath); + IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath); - void Set(string key, string value); + void Set(string key, string? value); - bool TryGet(string key, out string value); + bool TryGet(string key, out string? value); } public interface IConfigurationSection : IConfiguration { - string Value { get; set; } + string? Value { get; set; } } public static class IniConfigurationExtensions { - public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange); + public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, IFileProvider? provider, string path, bool optional, bool reloadOnChange); - public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, Action<IniConfigurationSource> configureSource); + public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, Action<IniConfigurationSource>? configureSource); } public static class JsonConfigurationExtensions { - public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange); + public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, IFileProvider? provider, string path, bool optional, bool reloadOnChange); - public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, Action<JsonConfigurationSource> configureSource); + public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, Action<JsonConfigurationSource>? configureSource); } public static class MemoryConfigurationBuilderExtensions { - public static IConfigurationBuilder AddInMemoryCollection(this IConfigurationBuilder configurationBuilder, IEnumerable<KeyValuePair<string, string>> initialData); + public static IConfigurationBuilder AddInMemoryCollection(this IConfigurationBuilder configurationBuilder, IEnumerable<KeyValuePair<string, string?>>? initialData); } public abstract class StreamConfigurationSource : IConfigurationSource { public Stream Stream { get; set; } } public static class XmlConfigurationExtensions { - public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange); + public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, IFileProvider? provider, string path, bool optional, bool reloadOnChange); - public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, Action<XmlConfigurationSource> configureSource); + public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, Action<XmlConfigurationSource>? configureSource); } }","title":"Microsoft.Extensions.Configuration"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Configuration/#microsoftextensionsconfiguration","text":"namespace Microsoft.Extensions.Configuration { public class ChainedConfigurationProvider : IConfigurationProvider, IDisposable { + public IConfiguration Configuration { get; } - public IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string parentPath); + public IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath); - public void Set(string key, string value); + public void Set(string key, string? value); - public bool TryGet(string key, out string value); + public bool TryGet(string key, out string? value); } public class ChainedConfigurationSource : IConfigurationSource { public IConfiguration Configuration { get; set; } } public static class CommandLineConfigurationExtensions { - public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder builder, Action<CommandLineConfigurationSource> configureSource); + public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder builder, Action<CommandLineConfigurationSource>? configureSource); - public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder configurationBuilder, string[] args, IDictionary<string, string> switchMappings); + public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder configurationBuilder, string[] args, IDictionary<string, string>? switchMappings); } public static class ConfigurationBinder { - public static void Bind(this IConfiguration configuration, object instance); + public static void Bind(this IConfiguration configuration, object? instance); - public static void Bind(this IConfiguration configuration, object instance, Action<BinderOptions> configureOptions); + public static void Bind(this IConfiguration configuration, object? instance, Action<BinderOptions>? configureOptions); - public static void Bind(this IConfiguration configuration, string key, object instance); + public static void Bind(this IConfiguration configuration, string key, object? instance); - public static object Get(this IConfiguration configuration, Type type); + public static object? Get(this IConfiguration configuration, Type type); - public static object Get(this IConfiguration configuration, Type type, Action<BinderOptions> configureOptions); + public static object? Get(this IConfiguration configuration, Type type, Action<BinderOptions>? configureOptions); - public static T Get<T>(this IConfiguration configuration); + public static T? Get<T>(this IConfiguration configuration); - public static T Get<T>(this IConfiguration configuration, Action<BinderOptions> configureOptions); + public static T? Get<T>(this IConfiguration configuration, Action<BinderOptions>? configureOptions); - public static object GetValue(this IConfiguration configuration, Type type, string key); + public static object? GetValue(this IConfiguration configuration, Type type, string key); - public static object GetValue(this IConfiguration configuration, Type type, string key, object defaultValue); + public static object? GetValue(this IConfiguration configuration, Type type, string key, object? defaultValue); - public static T GetValue<T>(this IConfiguration configuration, string key); + public static T? GetValue<T>(this IConfiguration configuration, string key); - public static T GetValue<T>(this IConfiguration configuration, string key, T defaultValue); + public static T? GetValue<T>(this IConfiguration configuration, string key, T defaultValue); } + public readonly struct ConfigurationDebugViewContext { + public ConfigurationDebugViewContext(string path, string key, string? value, IConfigurationProvider configurationProvider); + public IConfigurationProvider ConfigurationProvider { get; } + public string Key { get; } + public string Path { get; } + public string? Value { get; } + } public static class ConfigurationExtensions { - public static IConfigurationBuilder Add<TSource>(this IConfigurationBuilder builder, Action<TSource> configureSource) where TSource : IConfigurationSource, new(); + public static IConfigurationBuilder Add<TSource>(this IConfigurationBuilder builder, Action<TSource>? configureSource) where TSource : IConfigurationSource, new(); - public static IEnumerable<KeyValuePair<string, string>> AsEnumerable(this IConfiguration configuration); + public static IEnumerable<KeyValuePair<string, string?>> AsEnumerable(this IConfiguration configuration); - public static IEnumerable<KeyValuePair<string, string>> AsEnumerable(this IConfiguration configuration, bool makePathsRelative); + public static IEnumerable<KeyValuePair<string, string?>> AsEnumerable(this IConfiguration configuration, bool makePathsRelative); - public static bool Exists(this IConfigurationSection section); + public static bool Exists(this IConfigurationSection? section); - public static string GetConnectionString(this IConfiguration configuration, string name); + public static string? GetConnectionString(this IConfiguration configuration, string name); } public class ConfigurationKeyComparer : IComparer<string> { - public int Compare(string x, string y); + public int Compare(string? x, string? y); } public sealed class ConfigurationManager : IConfiguration, IConfigurationBuilder, IConfigurationRoot, IDisposable { - IDictionary<string, object> Microsoft.Extensions.Configuration.IConfigurationBuilder.Properties { get; } + IDictionary<string, object> IConfigurationBuilder.Properties { get; } - IList<IConfigurationSource> Microsoft.Extensions.Configuration.IConfigurationBuilder.Sources { get; } - IEnumerable<IConfigurationProvider> Microsoft.Extensions.Configuration.IConfigurationRoot.Providers { get; } + IEnumerable<IConfigurationProvider> IConfigurationRoot.Providers { get; } + public IList<IConfigurationSource> Sources { get; } - public string this[string key] { get; set; } + public string? this[string key] { get; set; } } public static class ConfigurationPath { - public static string GetParentPath(string path); + public static string? GetParentPath(string? path); - public static string GetSectionKey(string path); + public static string? GetSectionKey(string? path); } public abstract class ConfigurationProvider : IConfigurationProvider { - protected IDictionary<string, string> Data { get; set; } + protected IDictionary<string, string?> Data { get; set; } - public virtual IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string parentPath); + public virtual IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath); - public virtual void Set(string key, string value); + public virtual void Set(string key, string? value); - public virtual bool TryGet(string key, out string value); + public virtual bool TryGet(string key, out string? value); } public class ConfigurationReloadToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } public class ConfigurationRoot : IConfiguration, IConfigurationRoot, IDisposable { - public string this[string key] { get; set; } + public string? this[string key] { get; set; } } public static class ConfigurationRootExtensions { + public static string GetDebugView(this IConfigurationRoot root, Func<ConfigurationDebugViewContext, string>? processValue); } public class ConfigurationSection : IConfiguration, IConfigurationSection { - public string this[string key] { get; set; } + public string? this[string key] { get; set; } - public string Value { get; set; } + public string? Value { get; set; } } public static class EnvironmentVariablesExtensions { - public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder builder, Action<EnvironmentVariablesConfigurationSource> configureSource); + public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder builder, Action<EnvironmentVariablesConfigurationSource>? configureSource); - public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder configurationBuilder, string prefix); + public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder configurationBuilder, string? prefix); } public static class FileConfigurationExtensions { - public static Action<FileLoadExceptionContext> GetFileLoadExceptionHandler(this IConfigurationBuilder builder); + public static Action<FileLoadExceptionContext>? GetFileLoadExceptionHandler(this IConfigurationBuilder builder); } public abstract class FileConfigurationSource : IConfigurationSource { - public Action<FileLoadExceptionContext> OnLoadException { get; set; } + public Action<FileLoadExceptionContext>? OnLoadException { get; set; } public string Path { get; set; } } public interface IConfiguration { - string this[string key] { get; set; } + string? this[string key] { get; set; } } public interface IConfigurationProvider { - IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string parentPath); + IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath); - void Set(string key, string value); + void Set(string key, string? value); - bool TryGet(string key, out string value); + bool TryGet(string key, out string? value); } public interface IConfigurationSection : IConfiguration { - string Value { get; set; } + string? Value { get; set; } } public static class IniConfigurationExtensions { - public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange); + public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, IFileProvider? provider, string path, bool optional, bool reloadOnChange); - public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, Action<IniConfigurationSource> configureSource); + public static IConfigurationBuilder AddIniFile(this IConfigurationBuilder builder, Action<IniConfigurationSource>? configureSource); } public static class JsonConfigurationExtensions { - public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange); + public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, IFileProvider? provider, string path, bool optional, bool reloadOnChange); - public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, Action<JsonConfigurationSource> configureSource); + public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, Action<JsonConfigurationSource>? configureSource); } public static class MemoryConfigurationBuilderExtensions { - public static IConfigurationBuilder AddInMemoryCollection(this IConfigurationBuilder configurationBuilder, IEnumerable<KeyValuePair<string, string>> initialData); + public static IConfigurationBuilder AddInMemoryCollection(this IConfigurationBuilder configurationBuilder, IEnumerable<KeyValuePair<string, string?>>? initialData); } public abstract class StreamConfigurationSource : IConfigurationSource { public Stream Stream { get; set; } } public static class XmlConfigurationExtensions { - public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange); + public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, IFileProvider? provider, string path, bool optional, bool reloadOnChange); - public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, Action<XmlConfigurationSource> configureSource); + public static IConfigurationBuilder AddXmlFile(this IConfigurationBuilder builder, Action<XmlConfigurationSource>? configureSource); } }","title":"Microsoft.Extensions.Configuration"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.DependencyInjection.Extensions/","text":"Microsoft.Extensions.DependencyInjection.Extensions namespace Microsoft.Extensions.DependencyInjection.Extensions { public static class ServiceCollectionDescriptorExtensions { public static void TryAddScoped(this IServiceCollection collection, Type service); public static void TryAddScoped(this IServiceCollection collection, Type service, Type implementationType); public static void TryAddSingleton(this IServiceCollection collection, Type service); public static void TryAddSingleton(this IServiceCollection collection, Type service, Type implementationType); public static void TryAddTransient(this IServiceCollection collection, Type service); public static void TryAddTransient(this IServiceCollection collection, Type service, Type implementationType); } }","title":"Microsoft.Extensions.DependencyInjection.Extensions"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.DependencyInjection.Extensions/#microsoftextensionsdependencyinjectionextensions","text":"namespace Microsoft.Extensions.DependencyInjection.Extensions { public static class ServiceCollectionDescriptorExtensions { public static void TryAddScoped(this IServiceCollection collection, Type service); public static void TryAddScoped(this IServiceCollection collection, Type service, Type implementationType); public static void TryAddSingleton(this IServiceCollection collection, Type service); public static void TryAddSingleton(this IServiceCollection collection, Type service, Type implementationType); public static void TryAddTransient(this IServiceCollection collection, Type service); public static void TryAddTransient(this IServiceCollection collection, Type service, Type implementationType); } }","title":"Microsoft.Extensions.DependencyInjection.Extensions"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.DependencyInjection/","text":"Microsoft.Extensions.DependencyInjection namespace Microsoft.Extensions.DependencyInjection { public static class ActivatorUtilities { public static ObjectFactory CreateFactory(Type instanceType, Type[] argumentTypes); public static object CreateInstance(IServiceProvider provider, Type instanceType, params object[] parameters); public static object GetServiceOrCreateInstance(IServiceProvider provider, Type type); } public class DefaultServiceProviderFactory : IServiceProviderFactory<IServiceCollection> + public static class HttpJsonServiceExtensions { + public static IServiceCollection ConfigureHttpJsonOptions(this IServiceCollection services, Action<JsonOptions> configureOptions); + } public class OAuthPostConfigureOptions<TOptions, THandler> : IPostConfigureOptions<TOptions> where TOptions : OAuthOptions, new() where THandler : OAuthHandler<TOptions> { - public void PostConfigure(string name, TOptions options); + public void PostConfigure(string? name, TOptions options); } public static class OptionsBuilderConfigurationExtensions { public static OptionsBuilder<TOptions> Bind<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, IConfiguration config) where TOptions : class; - public static OptionsBuilder<TOptions> Bind<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, IConfiguration config, Action<BinderOptions> configureBinder) where TOptions : class; + public static OptionsBuilder<TOptions> Bind<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, IConfiguration config, Action<BinderOptions>? configureBinder) where TOptions : class; - public static OptionsBuilder<TOptions> BindConfiguration<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, string configSectionPath, Action<BinderOptions> configureBinder = null) where TOptions : class; + public static OptionsBuilder<TOptions> BindConfiguration<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, string configSectionPath, Action<BinderOptions>? configureBinder = null) where TOptions : class; } public static class OptionsBuilderDataAnnotationsExtensions { public static OptionsBuilder<TOptions> ValidateDataAnnotations<TOptions>(this OptionsBuilder<TOptions> optionsBuilder) where TOptions : class; } public static class OptionsConfigurationServiceCollectionExtensions { public static IServiceCollection Configure<TOptions>(this IServiceCollection services, IConfiguration config) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, IConfiguration config, Action<BinderOptions> configureBinder) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, IConfiguration config, Action<BinderOptions>? configureBinder) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string? name, IConfiguration config) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config, Action<BinderOptions> configureBinder) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string? name, IConfiguration config, Action<BinderOptions>? configureBinder) where TOptions : class; } public static class OptionsServiceCollectionExtensions { - public static OptionsBuilder<TOptions> AddOptions<TOptions>(this IServiceCollection services, string name) where TOptions : class; + public static OptionsBuilder<TOptions> AddOptions<TOptions>(this IServiceCollection services, string? name) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, Action<TOptions> configureOptions) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string? name, Action<TOptions> configureOptions) where TOptions : class; public static IServiceCollection ConfigureOptions(this IServiceCollection services, Type configureType); - public static IServiceCollection PostConfigure<TOptions>(this IServiceCollection services, string name, Action<TOptions> configureOptions) where TOptions : class; + public static IServiceCollection PostConfigure<TOptions>(this IServiceCollection services, string? name, Action<TOptions> configureOptions) where TOptions : class; } + public static class OutputCacheConventionBuilderExtensions { + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, IOutputCachePolicy policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, Action<OutputCachePolicyBuilder> policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, Action<OutputCachePolicyBuilder> policy, bool excludeDefaultPolicy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, string policyName) where TBuilder : IEndpointConventionBuilder; + } + public static class OutputCacheServiceCollectionExtensions { + public static IServiceCollection AddOutputCache(this IServiceCollection services); + public static IServiceCollection AddOutputCache(this IServiceCollection services, Action<OutputCacheOptions> configureOptions); + } public static class PageConventionCollectionExtensions { public static PageConventionCollection AddAreaPageRoute(this PageConventionCollection conventions, string areaName, string pageName, string route); public static PageConventionCollection AddPageRoute(this PageConventionCollection conventions, string pageName, string route); } public static class PolicyServiceCollectionExtensions { + public static AuthorizationBuilder AddAuthorizationBuilder(this IServiceCollection services); } + public static class ProblemDetailsServiceCollectionExtensions { + public static IServiceCollection AddProblemDetails(this IServiceCollection services); + public static IServiceCollection AddProblemDetails(this IServiceCollection services, Action<ProblemDetailsOptions>? configure); + } + public static class RequestDecompressionServiceExtensions { + public static IServiceCollection AddRequestDecompression(this IServiceCollection services); + public static IServiceCollection AddRequestDecompression(this IServiceCollection services, Action<RequestDecompressionOptions> configureOptions); + } public class ServiceCollection : ICollection<ServiceDescriptor>, IEnumerable, IEnumerable<ServiceDescriptor>, IList<ServiceDescriptor>, IServiceCollection { + public void MakeReadOnly(); } public static class ServiceCollectionContainerBuilderExtensions { public static ServiceProvider BuildServiceProvider(this IServiceCollection services); public static ServiceProvider BuildServiceProvider(this IServiceCollection services, ServiceProviderOptions options); public static ServiceProvider BuildServiceProvider(this IServiceCollection services, bool validateScopes); } public static class ServiceCollectionServiceExtensions { public static IServiceCollection AddScoped(this IServiceCollection services, Type serviceType); public static IServiceCollection AddScoped(this IServiceCollection services, Type serviceType, Type implementationType); public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType); public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType, Type implementationType); public static IServiceCollection AddTransient(this IServiceCollection services, Type serviceType); public static IServiceCollection AddTransient(this IServiceCollection services, Type serviceType, Type implementationType); } public class ServiceDescriptor { public ServiceDescriptor(Type serviceType, Type implementationType, ServiceLifetime lifetime); public Type? ImplementationType { get; } public static ServiceDescriptor Describe(Type serviceType, Type implementationType, ServiceLifetime lifetime); public static ServiceDescriptor Scoped(Type service, Type implementationType); public static ServiceDescriptor Singleton(Type service, Type implementationType); public static ServiceDescriptor Transient(Type service, Type implementationType); } public sealed class ServiceProvider : IAsyncDisposable, IDisposable, IServiceProvider { - public object GetService(Type serviceType); + public object? GetService(Type serviceType); } public static class ServiceProviderServiceExtensions { public static IEnumerable<object?> GetServices(this IServiceProvider provider, Type serviceType); } }","title":"Microsoft.Extensions.DependencyInjection"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.DependencyInjection/#microsoftextensionsdependencyinjection","text":"namespace Microsoft.Extensions.DependencyInjection { public static class ActivatorUtilities { public static ObjectFactory CreateFactory(Type instanceType, Type[] argumentTypes); public static object CreateInstance(IServiceProvider provider, Type instanceType, params object[] parameters); public static object GetServiceOrCreateInstance(IServiceProvider provider, Type type); } public class DefaultServiceProviderFactory : IServiceProviderFactory<IServiceCollection> + public static class HttpJsonServiceExtensions { + public static IServiceCollection ConfigureHttpJsonOptions(this IServiceCollection services, Action<JsonOptions> configureOptions); + } public class OAuthPostConfigureOptions<TOptions, THandler> : IPostConfigureOptions<TOptions> where TOptions : OAuthOptions, new() where THandler : OAuthHandler<TOptions> { - public void PostConfigure(string name, TOptions options); + public void PostConfigure(string? name, TOptions options); } public static class OptionsBuilderConfigurationExtensions { public static OptionsBuilder<TOptions> Bind<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, IConfiguration config) where TOptions : class; - public static OptionsBuilder<TOptions> Bind<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, IConfiguration config, Action<BinderOptions> configureBinder) where TOptions : class; + public static OptionsBuilder<TOptions> Bind<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, IConfiguration config, Action<BinderOptions>? configureBinder) where TOptions : class; - public static OptionsBuilder<TOptions> BindConfiguration<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, string configSectionPath, Action<BinderOptions> configureBinder = null) where TOptions : class; + public static OptionsBuilder<TOptions> BindConfiguration<TOptions>(this OptionsBuilder<TOptions> optionsBuilder, string configSectionPath, Action<BinderOptions>? configureBinder = null) where TOptions : class; } public static class OptionsBuilderDataAnnotationsExtensions { public static OptionsBuilder<TOptions> ValidateDataAnnotations<TOptions>(this OptionsBuilder<TOptions> optionsBuilder) where TOptions : class; } public static class OptionsConfigurationServiceCollectionExtensions { public static IServiceCollection Configure<TOptions>(this IServiceCollection services, IConfiguration config) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, IConfiguration config, Action<BinderOptions> configureBinder) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, IConfiguration config, Action<BinderOptions>? configureBinder) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string? name, IConfiguration config) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, IConfiguration config, Action<BinderOptions> configureBinder) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string? name, IConfiguration config, Action<BinderOptions>? configureBinder) where TOptions : class; } public static class OptionsServiceCollectionExtensions { - public static OptionsBuilder<TOptions> AddOptions<TOptions>(this IServiceCollection services, string name) where TOptions : class; + public static OptionsBuilder<TOptions> AddOptions<TOptions>(this IServiceCollection services, string? name) where TOptions : class; - public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string name, Action<TOptions> configureOptions) where TOptions : class; + public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string? name, Action<TOptions> configureOptions) where TOptions : class; public static IServiceCollection ConfigureOptions(this IServiceCollection services, Type configureType); - public static IServiceCollection PostConfigure<TOptions>(this IServiceCollection services, string name, Action<TOptions> configureOptions) where TOptions : class; + public static IServiceCollection PostConfigure<TOptions>(this IServiceCollection services, string? name, Action<TOptions> configureOptions) where TOptions : class; } + public static class OutputCacheConventionBuilderExtensions { + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, IOutputCachePolicy policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, Action<OutputCachePolicyBuilder> policy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, Action<OutputCachePolicyBuilder> policy, bool excludeDefaultPolicy) where TBuilder : IEndpointConventionBuilder; + public static TBuilder CacheOutput<TBuilder>(this TBuilder builder, string policyName) where TBuilder : IEndpointConventionBuilder; + } + public static class OutputCacheServiceCollectionExtensions { + public static IServiceCollection AddOutputCache(this IServiceCollection services); + public static IServiceCollection AddOutputCache(this IServiceCollection services, Action<OutputCacheOptions> configureOptions); + } public static class PageConventionCollectionExtensions { public static PageConventionCollection AddAreaPageRoute(this PageConventionCollection conventions, string areaName, string pageName, string route); public static PageConventionCollection AddPageRoute(this PageConventionCollection conventions, string pageName, string route); } public static class PolicyServiceCollectionExtensions { + public static AuthorizationBuilder AddAuthorizationBuilder(this IServiceCollection services); } + public static class ProblemDetailsServiceCollectionExtensions { + public static IServiceCollection AddProblemDetails(this IServiceCollection services); + public static IServiceCollection AddProblemDetails(this IServiceCollection services, Action<ProblemDetailsOptions>? configure); + } + public static class RequestDecompressionServiceExtensions { + public static IServiceCollection AddRequestDecompression(this IServiceCollection services); + public static IServiceCollection AddRequestDecompression(this IServiceCollection services, Action<RequestDecompressionOptions> configureOptions); + } public class ServiceCollection : ICollection<ServiceDescriptor>, IEnumerable, IEnumerable<ServiceDescriptor>, IList<ServiceDescriptor>, IServiceCollection { + public void MakeReadOnly(); } public static class ServiceCollectionContainerBuilderExtensions { public static ServiceProvider BuildServiceProvider(this IServiceCollection services); public static ServiceProvider BuildServiceProvider(this IServiceCollection services, ServiceProviderOptions options); public static ServiceProvider BuildServiceProvider(this IServiceCollection services, bool validateScopes); } public static class ServiceCollectionServiceExtensions { public static IServiceCollection AddScoped(this IServiceCollection services, Type serviceType); public static IServiceCollection AddScoped(this IServiceCollection services, Type serviceType, Type implementationType); public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType); public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType, Type implementationType); public static IServiceCollection AddTransient(this IServiceCollection services, Type serviceType); public static IServiceCollection AddTransient(this IServiceCollection services, Type serviceType, Type implementationType); } public class ServiceDescriptor { public ServiceDescriptor(Type serviceType, Type implementationType, ServiceLifetime lifetime); public Type? ImplementationType { get; } public static ServiceDescriptor Describe(Type serviceType, Type implementationType, ServiceLifetime lifetime); public static ServiceDescriptor Scoped(Type service, Type implementationType); public static ServiceDescriptor Singleton(Type service, Type implementationType); public static ServiceDescriptor Transient(Type service, Type implementationType); } public sealed class ServiceProvider : IAsyncDisposable, IDisposable, IServiceProvider { - public object GetService(Type serviceType); + public object? GetService(Type serviceType); } public static class ServiceProviderServiceExtensions { public static IEnumerable<object?> GetServices(this IServiceProvider provider, Type serviceType); } }","title":"Microsoft.Extensions.DependencyInjection"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileProviders.Physical/","text":"Microsoft.Extensions.FileProviders.Physical namespace Microsoft.Extensions.FileProviders.Physical { public class PhysicalFilesWatcher : IDisposable { - public PhysicalFilesWatcher(string root, FileSystemWatcher fileSystemWatcher, bool pollForChanges); + public PhysicalFilesWatcher(string root, FileSystemWatcher? fileSystemWatcher, bool pollForChanges); - public PhysicalFilesWatcher(string root, FileSystemWatcher fileSystemWatcher, bool pollForChanges, ExclusionFilters filters); + public PhysicalFilesWatcher(string root, FileSystemWatcher? fileSystemWatcher, bool pollForChanges, ExclusionFilters filters); } public class PollingFileChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } }","title":"Microsoft.Extensions.FileProviders.Physical"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileProviders.Physical/#microsoftextensionsfileprovidersphysical","text":"namespace Microsoft.Extensions.FileProviders.Physical { public class PhysicalFilesWatcher : IDisposable { - public PhysicalFilesWatcher(string root, FileSystemWatcher fileSystemWatcher, bool pollForChanges); + public PhysicalFilesWatcher(string root, FileSystemWatcher? fileSystemWatcher, bool pollForChanges); - public PhysicalFilesWatcher(string root, FileSystemWatcher fileSystemWatcher, bool pollForChanges, ExclusionFilters filters); + public PhysicalFilesWatcher(string root, FileSystemWatcher? fileSystemWatcher, bool pollForChanges, ExclusionFilters filters); } public class PollingFileChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } }","title":"Microsoft.Extensions.FileProviders.Physical"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileProviders/","text":"Microsoft.Extensions.FileProviders namespace Microsoft.Extensions.FileProviders { public class CompositeFileProvider : IFileProvider { - public CompositeFileProvider(params IFileProvider[] fileProviders); + public CompositeFileProvider(params IFileProvider[]? fileProviders); } public interface IFileInfo { - string PhysicalPath { get; } + string? PhysicalPath { get; } } public class NotFoundFileInfo : IFileInfo { - public string PhysicalPath { get; } + public string? PhysicalPath { get; } public Stream CreateReadStream(); } public class NullChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } }","title":"Microsoft.Extensions.FileProviders"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileProviders/#microsoftextensionsfileproviders","text":"namespace Microsoft.Extensions.FileProviders { public class CompositeFileProvider : IFileProvider { - public CompositeFileProvider(params IFileProvider[] fileProviders); + public CompositeFileProvider(params IFileProvider[]? fileProviders); } public interface IFileInfo { - string PhysicalPath { get; } + string? PhysicalPath { get; } } public class NotFoundFileInfo : IFileInfo { - public string PhysicalPath { get; } + public string? PhysicalPath { get; } public Stream CreateReadStream(); } public class NullChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } }","title":"Microsoft.Extensions.FileProviders"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Abstractions/","text":"Microsoft.Extensions.FileSystemGlobbing.Abstractions namespace Microsoft.Extensions.FileSystemGlobbing.Abstractions { public abstract class DirectoryInfoBase : FileSystemInfoBase { - public abstract DirectoryInfoBase GetDirectory(string path); + public abstract DirectoryInfoBase? GetDirectory(string path); - public abstract FileInfoBase GetFile(string path); + public abstract FileInfoBase? GetFile(string path); } public class DirectoryInfoWrapper : DirectoryInfoBase { - public override DirectoryInfoBase ParentDirectory { get; } + public override DirectoryInfoBase? ParentDirectory { get; } - public override DirectoryInfoBase GetDirectory(string name); + public override DirectoryInfoBase? GetDirectory(string name); } public class FileInfoWrapper : FileInfoBase { - public override DirectoryInfoBase ParentDirectory { get; } + public override DirectoryInfoBase? ParentDirectory { get; } } public abstract class FileSystemInfoBase { - public abstract DirectoryInfoBase ParentDirectory { get; } + public abstract DirectoryInfoBase? ParentDirectory { get; } } }","title":"Microsoft.Extensions.FileSystemGlobbing.Abstractions"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Abstractions/#microsoftextensionsfilesystemglobbingabstractions","text":"namespace Microsoft.Extensions.FileSystemGlobbing.Abstractions { public abstract class DirectoryInfoBase : FileSystemInfoBase { - public abstract DirectoryInfoBase GetDirectory(string path); + public abstract DirectoryInfoBase? GetDirectory(string path); - public abstract FileInfoBase GetFile(string path); + public abstract FileInfoBase? GetFile(string path); } public class DirectoryInfoWrapper : DirectoryInfoBase { - public override DirectoryInfoBase ParentDirectory { get; } + public override DirectoryInfoBase? ParentDirectory { get; } - public override DirectoryInfoBase GetDirectory(string name); + public override DirectoryInfoBase? GetDirectory(string name); } public class FileInfoWrapper : FileInfoBase { - public override DirectoryInfoBase ParentDirectory { get; } + public override DirectoryInfoBase? ParentDirectory { get; } } public abstract class FileSystemInfoBase { - public abstract DirectoryInfoBase ParentDirectory { get; } + public abstract DirectoryInfoBase? ParentDirectory { get; } } }","title":"Microsoft.Extensions.FileSystemGlobbing.Abstractions"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments/","text":"Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments namespace Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments { public class LiteralPathSegment : IPathSegment { - public override bool Equals(object obj); + public override bool Equals(object? obj); } }","title":"Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments/#microsoftextensionsfilesystemglobbinginternalpathsegments","text":"namespace Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments { public class LiteralPathSegment : IPathSegment { - public override bool Equals(object obj); + public override bool Equals(object? obj); } }","title":"Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts/","text":"Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts namespace Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts { - public abstract class PatternContext<TFrame> : IPatternContext + public abstract class PatternContext<TFrame> : IPatternContext where TFrame : struct public abstract class PatternContextLinear : PatternContext<PatternContextLinear.FrameData> { public struct FrameData { - public string Stem { get; } + public string? Stem { get; } } } public abstract class PatternContextRagged : PatternContext<PatternContextRagged.FrameData> { public struct FrameData { - public string Stem { get; } + public string? Stem { get; } } } }","title":"Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts/#microsoftextensionsfilesystemglobbinginternalpatterncontexts","text":"namespace Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts { - public abstract class PatternContext<TFrame> : IPatternContext + public abstract class PatternContext<TFrame> : IPatternContext where TFrame : struct public abstract class PatternContextLinear : PatternContext<PatternContextLinear.FrameData> { public struct FrameData { - public string Stem { get; } + public string? Stem { get; } } } public abstract class PatternContextRagged : PatternContext<PatternContextRagged.FrameData> { public struct FrameData { - public string Stem { get; } + public string? Stem { get; } } } }","title":"Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing/","text":"Microsoft.Extensions.FileSystemGlobbing namespace Microsoft.Extensions.FileSystemGlobbing { public struct FilePatternMatch : IEquatable<FilePatternMatch> { - public FilePatternMatch(string path, string stem); + public FilePatternMatch(string path, string? stem); - public string Stem { get; } + public string? Stem { get; } - public override bool Equals(object obj); + public override bool Equals(object? obj); } public class InMemoryDirectoryInfo : DirectoryInfoBase { - public InMemoryDirectoryInfo(string rootDir, IEnumerable<string> files); + public InMemoryDirectoryInfo(string rootDir, IEnumerable<string>? files); - public override DirectoryInfoBase ParentDirectory { get; } + public override DirectoryInfoBase? ParentDirectory { get; } - public override FileInfoBase GetFile(string path); + public override FileInfoBase? GetFile(string path); } public static class MatcherExtensions { - public static PatternMatchingResult Match(this Matcher matcher, IEnumerable<string> files); + public static PatternMatchingResult Match(this Matcher matcher, IEnumerable<string>? files); - public static PatternMatchingResult Match(this Matcher matcher, string rootDir, IEnumerable<string> files); + public static PatternMatchingResult Match(this Matcher matcher, string rootDir, IEnumerable<string>? files); } }","title":"Microsoft.Extensions.FileSystemGlobbing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.FileSystemGlobbing/#microsoftextensionsfilesystemglobbing","text":"namespace Microsoft.Extensions.FileSystemGlobbing { public struct FilePatternMatch : IEquatable<FilePatternMatch> { - public FilePatternMatch(string path, string stem); + public FilePatternMatch(string path, string? stem); - public string Stem { get; } + public string? Stem { get; } - public override bool Equals(object obj); + public override bool Equals(object? obj); } public class InMemoryDirectoryInfo : DirectoryInfoBase { - public InMemoryDirectoryInfo(string rootDir, IEnumerable<string> files); + public InMemoryDirectoryInfo(string rootDir, IEnumerable<string>? files); - public override DirectoryInfoBase ParentDirectory { get; } + public override DirectoryInfoBase? ParentDirectory { get; } - public override FileInfoBase GetFile(string path); + public override FileInfoBase? GetFile(string path); } public static class MatcherExtensions { - public static PatternMatchingResult Match(this Matcher matcher, IEnumerable<string> files); + public static PatternMatchingResult Match(this Matcher matcher, IEnumerable<string>? files); - public static PatternMatchingResult Match(this Matcher matcher, string rootDir, IEnumerable<string> files); + public static PatternMatchingResult Match(this Matcher matcher, string rootDir, IEnumerable<string>? files); } }","title":"Microsoft.Extensions.FileSystemGlobbing"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Hosting.Internal/","text":"Microsoft.Extensions.Hosting.Internal namespace Microsoft.Extensions.Hosting.Internal { public class ConsoleLifetime : IDisposable, IHostLifetime }","title":"Microsoft.Extensions.Hosting.Internal"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Hosting.Internal/#microsoftextensionshostinginternal","text":"namespace Microsoft.Extensions.Hosting.Internal { public class ConsoleLifetime : IDisposable, IHostLifetime }","title":"Microsoft.Extensions.Hosting.Internal"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Hosting/","text":"Microsoft.Extensions.Hosting namespace Microsoft.Extensions.Hosting { public abstract class BackgroundService : IDisposable, IHostedService { - public virtual Task ExecuteTask { get; } + public virtual Task? ExecuteTask { get; } } public static class GenericHostBuilderExtensions { + public static IHostBuilder ConfigureWebHostDefaults(this IHostBuilder builder, Action<IWebHostBuilder> configure, Action<WebHostBuilderOptions> configureOptions); } public static class Host { + public static HostApplicationBuilder CreateApplicationBuilder(); + public static HostApplicationBuilder CreateApplicationBuilder(string[]? args); public static IHostBuilder CreateDefaultBuilder(); - public static IHostBuilder CreateDefaultBuilder(string[] args); + public static IHostBuilder CreateDefaultBuilder(string[]? args); } + public sealed class HostAbortedException : Exception { + public HostAbortedException(); + public HostAbortedException(string message); + public HostAbortedException(string message, Exception innerException); + } + public sealed class HostApplicationBuilder { + public HostApplicationBuilder(); + public HostApplicationBuilder(HostApplicationBuilderSettings? settings); + public HostApplicationBuilder(string[]? args); + public ConfigurationManager Configuration { get; } + public IHostEnvironment Environment { get; } + public ILoggingBuilder Logging { get; } + public IServiceCollection Services { get; } + public IHost Build(); + public void ConfigureContainer<TContainerBuilder>(IServiceProviderFactory<TContainerBuilder> factory, Action<TContainerBuilder>? configure = null); + } + public sealed class HostApplicationBuilderSettings { + public HostApplicationBuilderSettings(); + public string ApplicationName { get; set; } + public string[]? Args { get; set; } + public ConfigurationManager Configuration { get; set; } + public string ContentRootPath { get; set; } + public bool DisableDefaults { get; set; } + public string EnvironmentName { get; set; } + } public class HostBuilder : IHostBuilder { public HostBuilder(); } public static class HostingHostBuilderExtensions { - public static IHostBuilder ConfigureDefaults(this IHostBuilder builder, string[] args); + public static IHostBuilder ConfigureDefaults(this IHostBuilder builder, string[]? args); public static Task RunConsoleAsync(this IHostBuilder hostBuilder, Action<ConsoleLifetimeOptions> configureOptions, CancellationToken cancellationToken = default(CancellationToken)); public static Task RunConsoleAsync(this IHostBuilder hostBuilder, CancellationToken cancellationToken = default(CancellationToken)); public static IHostBuilder UseConsoleLifetime(this IHostBuilder hostBuilder); public static IHostBuilder UseConsoleLifetime(this IHostBuilder hostBuilder, Action<ConsoleLifetimeOptions> configureOptions); public static IHostBuilder UseDefaultServiceProvider(this IHostBuilder hostBuilder, Action<ServiceProviderOptions> configure); public static IHostBuilder UseDefaultServiceProvider(this IHostBuilder hostBuilder, Action<HostBuilderContext, ServiceProviderOptions> configure); } }","title":"Microsoft.Extensions.Hosting"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Hosting/#microsoftextensionshosting","text":"namespace Microsoft.Extensions.Hosting { public abstract class BackgroundService : IDisposable, IHostedService { - public virtual Task ExecuteTask { get; } + public virtual Task? ExecuteTask { get; } } public static class GenericHostBuilderExtensions { + public static IHostBuilder ConfigureWebHostDefaults(this IHostBuilder builder, Action<IWebHostBuilder> configure, Action<WebHostBuilderOptions> configureOptions); } public static class Host { + public static HostApplicationBuilder CreateApplicationBuilder(); + public static HostApplicationBuilder CreateApplicationBuilder(string[]? args); public static IHostBuilder CreateDefaultBuilder(); - public static IHostBuilder CreateDefaultBuilder(string[] args); + public static IHostBuilder CreateDefaultBuilder(string[]? args); } + public sealed class HostAbortedException : Exception { + public HostAbortedException(); + public HostAbortedException(string message); + public HostAbortedException(string message, Exception innerException); + } + public sealed class HostApplicationBuilder { + public HostApplicationBuilder(); + public HostApplicationBuilder(HostApplicationBuilderSettings? settings); + public HostApplicationBuilder(string[]? args); + public ConfigurationManager Configuration { get; } + public IHostEnvironment Environment { get; } + public ILoggingBuilder Logging { get; } + public IServiceCollection Services { get; } + public IHost Build(); + public void ConfigureContainer<TContainerBuilder>(IServiceProviderFactory<TContainerBuilder> factory, Action<TContainerBuilder>? configure = null); + } + public sealed class HostApplicationBuilderSettings { + public HostApplicationBuilderSettings(); + public string ApplicationName { get; set; } + public string[]? Args { get; set; } + public ConfigurationManager Configuration { get; set; } + public string ContentRootPath { get; set; } + public bool DisableDefaults { get; set; } + public string EnvironmentName { get; set; } + } public class HostBuilder : IHostBuilder { public HostBuilder(); } public static class HostingHostBuilderExtensions { - public static IHostBuilder ConfigureDefaults(this IHostBuilder builder, string[] args); + public static IHostBuilder ConfigureDefaults(this IHostBuilder builder, string[]? args); public static Task RunConsoleAsync(this IHostBuilder hostBuilder, Action<ConsoleLifetimeOptions> configureOptions, CancellationToken cancellationToken = default(CancellationToken)); public static Task RunConsoleAsync(this IHostBuilder hostBuilder, CancellationToken cancellationToken = default(CancellationToken)); public static IHostBuilder UseConsoleLifetime(this IHostBuilder hostBuilder); public static IHostBuilder UseConsoleLifetime(this IHostBuilder hostBuilder, Action<ConsoleLifetimeOptions> configureOptions); public static IHostBuilder UseDefaultServiceProvider(this IHostBuilder hostBuilder, Action<ServiceProviderOptions> configure); public static IHostBuilder UseDefaultServiceProvider(this IHostBuilder hostBuilder, Action<HostBuilderContext, ServiceProviderOptions> configure); } }","title":"Microsoft.Extensions.Hosting"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Http/","text":"Microsoft.Extensions.Http namespace Microsoft.Extensions.Http { public abstract class HttpMessageHandlerBuilder { - public abstract string Name { get; set; } + public abstract string? Name { get; set; } } }","title":"Microsoft.Extensions.Http"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Http/#microsoftextensionshttp","text":"namespace Microsoft.Extensions.Http { public abstract class HttpMessageHandlerBuilder { - public abstract string Name { get; set; } + public abstract string? Name { get; set; } } }","title":"Microsoft.Extensions.Http"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Abstractions/","text":"Microsoft.Extensions.Logging.Abstractions namespace Microsoft.Extensions.Logging.Abstractions { public readonly struct LogEntry<TState> { - public Func<TState, Exception?, string>? Formatter { get; } + public Func<TState, Exception?, string> Formatter { get; } } public class NullLogger<T> : ILogger, ILogger<T> { - public IDisposable BeginScope<TState>(TState state); + public IDisposable BeginScope<TState>(TState state) where TState : notnull; } }","title":"Microsoft.Extensions.Logging.Abstractions"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Abstractions/#microsoftextensionsloggingabstractions","text":"namespace Microsoft.Extensions.Logging.Abstractions { public readonly struct LogEntry<TState> { - public Func<TState, Exception?, string>? Formatter { get; } + public Func<TState, Exception?, string> Formatter { get; } } public class NullLogger<T> : ILogger, ILogger<T> { - public IDisposable BeginScope<TState>(TState state); + public IDisposable BeginScope<TState>(TState state) where TState : notnull; } }","title":"Microsoft.Extensions.Logging.Abstractions"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Configuration/","text":"Microsoft.Extensions.Logging.Configuration namespace Microsoft.Extensions.Logging.Configuration { public static class LoggerProviderOptions { public static void RegisterProviderOptions<TOptions, TProvider>(IServiceCollection services) where TOptions : class; } }","title":"Microsoft.Extensions.Logging.Configuration"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Configuration/#microsoftextensionsloggingconfiguration","text":"namespace Microsoft.Extensions.Logging.Configuration { public static class LoggerProviderOptions { public static void RegisterProviderOptions<TOptions, TProvider>(IServiceCollection services) where TOptions : class; } }","title":"Microsoft.Extensions.Logging.Configuration"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Console/","text":"Microsoft.Extensions.Logging.Console namespace Microsoft.Extensions.Logging.Console { public abstract class ConsoleFormatter { - public abstract void Write<TState>(in LogEntry<TState> logEntry, IExternalScopeProvider scopeProvider, TextWriter textWriter); + public abstract void Write<TState>(in LogEntry<TState> logEntry, IExternalScopeProvider? scopeProvider, TextWriter textWriter); } public class ConsoleFormatterOptions { public string TimestampFormat { get; set; } } public class ConsoleLoggerOptions { + public int MaxQueueLength { get; set; } + public ConsoleLoggerQueueFullMode QueueFullMode { get; set; } } public class ConsoleLoggerProvider : IDisposable, ILoggerProvider, ISupportExternalScope { - public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options, IEnumerable<ConsoleFormatter> formatters); + public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options, IEnumerable<ConsoleFormatter>? formatters); } + public enum ConsoleLoggerQueueFullMode { + DropWrite = 1, + Wait = 0, + } }","title":"Microsoft.Extensions.Logging.Console"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.Console/#microsoftextensionsloggingconsole","text":"namespace Microsoft.Extensions.Logging.Console { public abstract class ConsoleFormatter { - public abstract void Write<TState>(in LogEntry<TState> logEntry, IExternalScopeProvider scopeProvider, TextWriter textWriter); + public abstract void Write<TState>(in LogEntry<TState> logEntry, IExternalScopeProvider? scopeProvider, TextWriter textWriter); } public class ConsoleFormatterOptions { public string TimestampFormat { get; set; } } public class ConsoleLoggerOptions { + public int MaxQueueLength { get; set; } + public ConsoleLoggerQueueFullMode QueueFullMode { get; set; } } public class ConsoleLoggerProvider : IDisposable, ILoggerProvider, ISupportExternalScope { - public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options, IEnumerable<ConsoleFormatter> formatters); + public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options, IEnumerable<ConsoleFormatter>? formatters); } + public enum ConsoleLoggerQueueFullMode { + DropWrite = 1, + Wait = 0, + } }","title":"Microsoft.Extensions.Logging.Console"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.EventLog/","text":"Microsoft.Extensions.Logging.EventLog namespace Microsoft.Extensions.Logging.EventLog { public class EventLogLoggerProvider : IDisposable, ILoggerProvider, ISupportExternalScope { - public EventLogLoggerProvider(EventLogSettings settings); + public EventLogLoggerProvider(EventLogSettings? settings); } public class EventLogSettings { - public Func<string, LogLevel, bool> Filter { get; set; } + public Func<string, LogLevel, bool>? Filter { get; set; } } }","title":"Microsoft.Extensions.Logging.EventLog"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.EventLog/#microsoftextensionsloggingeventlog","text":"namespace Microsoft.Extensions.Logging.EventLog { public class EventLogLoggerProvider : IDisposable, ILoggerProvider, ISupportExternalScope { - public EventLogLoggerProvider(EventLogSettings settings); + public EventLogLoggerProvider(EventLogSettings? settings); } public class EventLogSettings { - public Func<string, LogLevel, bool> Filter { get; set; } + public Func<string, LogLevel, bool>? Filter { get; set; } } }","title":"Microsoft.Extensions.Logging.EventLog"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.TraceSource/","text":"Microsoft.Extensions.Logging.TraceSource namespace Microsoft.Extensions.Logging.TraceSource { public class TraceSourceLoggerProvider : IDisposable, ILoggerProvider { - public TraceSourceLoggerProvider(SourceSwitch rootSourceSwitch, TraceListener rootTraceListener); + public TraceSourceLoggerProvider(SourceSwitch rootSourceSwitch, TraceListener? rootTraceListener); } }","title":"Microsoft.Extensions.Logging.TraceSource"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging.TraceSource/#microsoftextensionsloggingtracesource","text":"namespace Microsoft.Extensions.Logging.TraceSource { public class TraceSourceLoggerProvider : IDisposable, ILoggerProvider { - public TraceSourceLoggerProvider(SourceSwitch rootSourceSwitch, TraceListener rootTraceListener); + public TraceSourceLoggerProvider(SourceSwitch rootSourceSwitch, TraceListener? rootTraceListener); } }","title":"Microsoft.Extensions.Logging.TraceSource"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging/","text":"Microsoft.Extensions.Logging namespace Microsoft.Extensions.Logging { public static class ConsoleLoggerExtensions { public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder) where TFormatter : ConsoleFormatter where TOptions : ConsoleFormatterOptions; public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder, Action<TOptions> configure) where TFormatter : ConsoleFormatter where TOptions : ConsoleFormatterOptions; } - public readonly struct EventId + public readonly struct EventId : IEquatable<EventId> public static class FilterLoggingBuilderExtensions { - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string, LogLevel, bool> categoryLevelFilter); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter); - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string, string, LogLevel, bool> filter); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, string?, LogLevel, bool> filter); - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string category, LogLevel level); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, LogLevel level); - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string category, Func<LogLevel, bool> levelFilter); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string, LogLevel, bool> categoryLevelFilter); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string, string, LogLevel, bool> filter); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, string?, LogLevel, bool> filter); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string category, LogLevel level); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, LogLevel level); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string category, Func<LogLevel, bool> levelFilter); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter); - public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<string, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; + public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; - public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string category, LogLevel level) where T : ILoggerProvider; + public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, LogLevel level) where T : ILoggerProvider; - public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; + public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; - public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<string, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; + public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; - public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string category, LogLevel level) where T : ILoggerProvider; + public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, LogLevel level) where T : ILoggerProvider; - public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; + public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; } public interface ILogger { - IDisposable BeginScope<TState>(TState state); + IDisposable? BeginScope<TState>(TState state); } public static class LoggerExtensions { - public static IDisposable BeginScope(this ILogger logger, string messageFormat, params object?[] args); + public static IDisposable? BeginScope(this ILogger logger, string messageFormat, params object?[] args); } public class LoggerFactory : IDisposable, ILoggerFactory { - public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions> options = null); + public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options); + public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options = null, IExternalScopeProvider? scopeProvider = null); public static ILoggerFactory Create(Action<ILoggingBuilder> configure); } public static class LoggerMessage { - public static Func<ILogger, IDisposable> DefineScope(string formatString); + public static Func<ILogger, IDisposable?> DefineScope(string formatString); - public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString); + public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable?> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString); - public static Func<ILogger, T1, T2, T3, T4, T5, IDisposable> DefineScope<T1, T2, T3, T4, T5>(string formatString); + public static Func<ILogger, T1, T2, T3, T4, T5, IDisposable?> DefineScope<T1, T2, T3, T4, T5>(string formatString); - public static Func<ILogger, T1, T2, T3, T4, IDisposable> DefineScope<T1, T2, T3, T4>(string formatString); + public static Func<ILogger, T1, T2, T3, T4, IDisposable?> DefineScope<T1, T2, T3, T4>(string formatString); - public static Func<ILogger, T1, T2, T3, IDisposable> DefineScope<T1, T2, T3>(string formatString); + public static Func<ILogger, T1, T2, T3, IDisposable?> DefineScope<T1, T2, T3>(string formatString); - public static Func<ILogger, T1, T2, IDisposable> DefineScope<T1, T2>(string formatString); + public static Func<ILogger, T1, T2, IDisposable?> DefineScope<T1, T2>(string formatString); - public static Func<ILogger, T1, IDisposable> DefineScope<T1>(string formatString); + public static Func<ILogger, T1, IDisposable?> DefineScope<T1>(string formatString); } }","title":"Microsoft.Extensions.Logging"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Logging/#microsoftextensionslogging","text":"namespace Microsoft.Extensions.Logging { public static class ConsoleLoggerExtensions { public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder) where TFormatter : ConsoleFormatter where TOptions : ConsoleFormatterOptions; public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder, Action<TOptions> configure) where TFormatter : ConsoleFormatter where TOptions : ConsoleFormatterOptions; } - public readonly struct EventId + public readonly struct EventId : IEquatable<EventId> public static class FilterLoggingBuilderExtensions { - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string, LogLevel, bool> categoryLevelFilter); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter); - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string, string, LogLevel, bool> filter); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, string?, LogLevel, bool> filter); - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string category, LogLevel level); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, LogLevel level); - public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string category, Func<LogLevel, bool> levelFilter); + public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string, LogLevel, bool> categoryLevelFilter); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string, string, LogLevel, bool> filter); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, string?, LogLevel, bool> filter); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string category, LogLevel level); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, LogLevel level); - public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string category, Func<LogLevel, bool> levelFilter); + public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter); - public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<string, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; + public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; - public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string category, LogLevel level) where T : ILoggerProvider; + public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, LogLevel level) where T : ILoggerProvider; - public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; + public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; - public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<string, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; + public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider; - public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string category, LogLevel level) where T : ILoggerProvider; + public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, LogLevel level) where T : ILoggerProvider; - public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; + public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider; } public interface ILogger { - IDisposable BeginScope<TState>(TState state); + IDisposable? BeginScope<TState>(TState state); } public static class LoggerExtensions { - public static IDisposable BeginScope(this ILogger logger, string messageFormat, params object?[] args); + public static IDisposable? BeginScope(this ILogger logger, string messageFormat, params object?[] args); } public class LoggerFactory : IDisposable, ILoggerFactory { - public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions> options = null); + public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options); + public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options = null, IExternalScopeProvider? scopeProvider = null); public static ILoggerFactory Create(Action<ILoggingBuilder> configure); } public static class LoggerMessage { - public static Func<ILogger, IDisposable> DefineScope(string formatString); + public static Func<ILogger, IDisposable?> DefineScope(string formatString); - public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString); + public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable?> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString); - public static Func<ILogger, T1, T2, T3, T4, T5, IDisposable> DefineScope<T1, T2, T3, T4, T5>(string formatString); + public static Func<ILogger, T1, T2, T3, T4, T5, IDisposable?> DefineScope<T1, T2, T3, T4, T5>(string formatString); - public static Func<ILogger, T1, T2, T3, T4, IDisposable> DefineScope<T1, T2, T3, T4>(string formatString); + public static Func<ILogger, T1, T2, T3, T4, IDisposable?> DefineScope<T1, T2, T3, T4>(string formatString); - public static Func<ILogger, T1, T2, T3, IDisposable> DefineScope<T1, T2, T3>(string formatString); + public static Func<ILogger, T1, T2, T3, IDisposable?> DefineScope<T1, T2, T3>(string formatString); - public static Func<ILogger, T1, T2, IDisposable> DefineScope<T1, T2>(string formatString); + public static Func<ILogger, T1, T2, IDisposable?> DefineScope<T1, T2>(string formatString); - public static Func<ILogger, T1, IDisposable> DefineScope<T1>(string formatString); + public static Func<ILogger, T1, IDisposable?> DefineScope<T1>(string formatString); } }","title":"Microsoft.Extensions.Logging"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.ObjectPool/","text":"Microsoft.Extensions.ObjectPool namespace Microsoft.Extensions.ObjectPool { public class LeakTrackingObjectPool<T> : ObjectPool<T> where T : class public class LeakTrackingObjectPoolProvider : ObjectPoolProvider }","title":"Microsoft.Extensions.ObjectPool"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.ObjectPool/#microsoftextensionsobjectpool","text":"namespace Microsoft.Extensions.ObjectPool { public class LeakTrackingObjectPool<T> : ObjectPool<T> where T : class public class LeakTrackingObjectPoolProvider : ObjectPoolProvider }","title":"Microsoft.Extensions.ObjectPool"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Options/","text":"Microsoft.Extensions.Options namespace Microsoft.Extensions.Options { public class ConfigurationChangeTokenSource<TOptions> : IOptionsChangeTokenSource<TOptions> { - public ConfigurationChangeTokenSource(string name, IConfiguration config); + public ConfigurationChangeTokenSource(string? name, IConfiguration config); } public class ConfigureFromConfigurationOptions<TOptions> : ConfigureOptions<TOptions> where TOptions : class { public ConfigureFromConfigurationOptions(IConfiguration config); } public class ConfigureNamedOptions<TOptions> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class { - public ConfigureNamedOptions(string name, Action<TOptions> action); + public ConfigureNamedOptions(string? name, Action<TOptions>? action); - public Action<TOptions> Action { get; } + public Action<TOptions>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep : class { - public ConfigureNamedOptions(string name, TDep dependency, Action<TOptions, TDep> action); + public ConfigureNamedOptions(string? name, TDep dependency, Action<TOptions, TDep>? action); - public Action<TOptions, TDep> Action { get; } + public Action<TOptions, TDep>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class { - public ConfigureNamedOptions(string name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2> action); + public ConfigureNamedOptions(string? name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2>? action); - public Action<TOptions, TDep1, TDep2> Action { get; } + public Action<TOptions, TDep1, TDep2>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2, TDep3> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class { - public ConfigureNamedOptions(string name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3> action); + public ConfigureNamedOptions(string? name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3>? action); - public Action<TOptions, TDep1, TDep2, TDep3> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2, TDep3, TDep4> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class { - public ConfigureNamedOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4> action); + public ConfigureNamedOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class where TDep5 : class { - public ConfigureNamedOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> action); + public ConfigureNamedOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureOptions<TOptions> : IConfigureOptions<TOptions> where TOptions : class { - public ConfigureOptions(Action<TOptions> action); + public ConfigureOptions(Action<TOptions>? action); - public Action<TOptions> Action { get; } + public Action<TOptions>? Action { get; } } public class DataAnnotationValidateOptions<TOptions> : IValidateOptions<TOptions> where TOptions : class { public DataAnnotationValidateOptions(string name); - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public interface IConfigureNamedOptions<in TOptions> : IConfigureOptions<TOptions> where TOptions : class { - void Configure(string name, TOptions options); + void Configure(string? name, TOptions options); } public interface IOptionsMonitor<out TOptions> { - TOptions Get(string name); + TOptions Get(string? name); - IDisposable OnChange(Action<TOptions, string> listener); + IDisposable? OnChange(Action<TOptions, string?> listener); } public interface IOptionsMonitorCache<TOptions> where TOptions : class { - TOptions GetOrAdd(string name, Func<TOptions> createOptions); + TOptions GetOrAdd(string? name, Func<TOptions> createOptions); - bool TryAdd(string name, TOptions options); + bool TryAdd(string? name, TOptions options); - bool TryRemove(string name); + bool TryRemove(string? name); } public interface IOptionsSnapshot<out TOptions> : IOptions<TOptions> where TOptions : class { - TOptions Get(string name); + TOptions Get(string? name); } public interface IPostConfigureOptions<in TOptions> where TOptions : class { - void PostConfigure(string name, TOptions options); + void PostConfigure(string? name, TOptions options); } public interface IValidateOptions<TOptions> where TOptions : class { - ValidateOptionsResult Validate(string name, TOptions options); + ValidateOptionsResult Validate(string? name, TOptions options); } public class NamedConfigureFromConfigurationOptions<TOptions> : ConfigureNamedOptions<TOptions> where TOptions : class { - public NamedConfigureFromConfigurationOptions(string name, IConfiguration config); + public NamedConfigureFromConfigurationOptions(string? name, IConfiguration config); - public NamedConfigureFromConfigurationOptions(string name, IConfiguration config, Action<BinderOptions> configureBinder); + public NamedConfigureFromConfigurationOptions(string? name, IConfiguration config, Action<BinderOptions>? configureBinder); } public class OptionsBuilder<TOptions> where TOptions : class { - public OptionsBuilder(IServiceCollection services, string name); + public OptionsBuilder(IServiceCollection services, string? name); } public class OptionsCache<TOptions> : IOptionsMonitorCache<TOptions> where TOptions : class { - public virtual TOptions GetOrAdd(string name, Func<TOptions> createOptions); + public virtual TOptions GetOrAdd(string? name, Func<TOptions> createOptions); - public virtual bool TryAdd(string name, TOptions options); + public virtual bool TryAdd(string? name, TOptions options); - public virtual bool TryRemove(string name); + public virtual bool TryRemove(string? name); } public class OptionsManager<TOptions> : IOptions<TOptions>, IOptionsSnapshot<TOptions> where TOptions : class { - public virtual TOptions Get(string name); + public virtual TOptions Get(string? name); } public class OptionsMonitor<TOptions> : IDisposable, IOptionsMonitor<TOptions> where TOptions : class { - public virtual TOptions Get(string name); + public virtual TOptions Get(string? name); } public static class OptionsMonitorExtensions { - public static IDisposable OnChange<TOptions>(this IOptionsMonitor<TOptions> monitor, Action<TOptions> listener); + public static IDisposable? OnChange<TOptions>(this IOptionsMonitor<TOptions> monitor, Action<TOptions> listener); } public class OptionsValidationException : Exception { - public OptionsValidationException(string optionsName, Type optionsType, IEnumerable<string> failureMessages); + public OptionsValidationException(string optionsName, Type optionsType, IEnumerable<string>? failureMessages); } public class PostConfigureOptions<TOptions> : IPostConfigureOptions<TOptions> where TOptions : class { - public PostConfigureOptions(string name, Action<TOptions> action); + public PostConfigureOptions(string name, Action<TOptions>? action); - public Action<TOptions> Action { get; } + public Action<TOptions>? Action { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep> : IPostConfigureOptions<TOptions> where TOptions : class where TDep : class { - public PostConfigureOptions(string name, TDep dependency, Action<TOptions, TDep> action); + public PostConfigureOptions(string? name, TDep dependency, Action<TOptions, TDep>? action); - public Action<TOptions, TDep> Action { get; } + public Action<TOptions, TDep>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class { - public PostConfigureOptions(string name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2> action); + public PostConfigureOptions(string? name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2>? action); - public Action<TOptions, TDep1, TDep2> Action { get; } + public Action<TOptions, TDep1, TDep2>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2, TDep3> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class { - public PostConfigureOptions(string name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3> action); + public PostConfigureOptions(string? name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3>? action); - public Action<TOptions, TDep1, TDep2, TDep3> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2, TDep3, TDep4> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class { - public PostConfigureOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4> action); + public PostConfigureOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class where TDep5 : class { - public PostConfigureOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> action); + public PostConfigureOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class ValidateOptions<TOptions> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, Func<TOptions, bool> validation, string failureMessage); + public ValidateOptions(string? name, Func<TOptions, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep dependency, Func<TOptions, TDep, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep dependency, Func<TOptions, TDep, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, Func<TOptions, TDep1, TDep2, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, Func<TOptions, TDep1, TDep2, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2, TDep3> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, Func<TOptions, TDep1, TDep2, TDep3, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, Func<TOptions, TDep1, TDep2, TDep3, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2, TDep3, TDep4> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Func<TOptions, TDep1, TDep2, TDep3, TDep4, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Func<TOptions, TDep1, TDep2, TDep3, TDep4, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Func<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Func<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptionsResult { public bool Failed { get; protected set; } - public string FailureMessage { get; protected set; } + public string? FailureMessage { get; protected set; } - public IEnumerable<string> Failures { get; protected set; } + public IEnumerable<string>? Failures { get; protected set; } } }","title":"Microsoft.Extensions.Options"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Options/#microsoftextensionsoptions","text":"namespace Microsoft.Extensions.Options { public class ConfigurationChangeTokenSource<TOptions> : IOptionsChangeTokenSource<TOptions> { - public ConfigurationChangeTokenSource(string name, IConfiguration config); + public ConfigurationChangeTokenSource(string? name, IConfiguration config); } public class ConfigureFromConfigurationOptions<TOptions> : ConfigureOptions<TOptions> where TOptions : class { public ConfigureFromConfigurationOptions(IConfiguration config); } public class ConfigureNamedOptions<TOptions> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class { - public ConfigureNamedOptions(string name, Action<TOptions> action); + public ConfigureNamedOptions(string? name, Action<TOptions>? action); - public Action<TOptions> Action { get; } + public Action<TOptions>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep : class { - public ConfigureNamedOptions(string name, TDep dependency, Action<TOptions, TDep> action); + public ConfigureNamedOptions(string? name, TDep dependency, Action<TOptions, TDep>? action); - public Action<TOptions, TDep> Action { get; } + public Action<TOptions, TDep>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class { - public ConfigureNamedOptions(string name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2> action); + public ConfigureNamedOptions(string? name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2>? action); - public Action<TOptions, TDep1, TDep2> Action { get; } + public Action<TOptions, TDep1, TDep2>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2, TDep3> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class { - public ConfigureNamedOptions(string name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3> action); + public ConfigureNamedOptions(string? name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3>? action); - public Action<TOptions, TDep1, TDep2, TDep3> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2, TDep3, TDep4> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class { - public ConfigureNamedOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4> action); + public ConfigureNamedOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureNamedOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> : IConfigureNamedOptions<TOptions>, IConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class where TDep5 : class { - public ConfigureNamedOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> action); + public ConfigureNamedOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void Configure(string name, TOptions options); + public virtual void Configure(string? name, TOptions options); } public class ConfigureOptions<TOptions> : IConfigureOptions<TOptions> where TOptions : class { - public ConfigureOptions(Action<TOptions> action); + public ConfigureOptions(Action<TOptions>? action); - public Action<TOptions> Action { get; } + public Action<TOptions>? Action { get; } } public class DataAnnotationValidateOptions<TOptions> : IValidateOptions<TOptions> where TOptions : class { public DataAnnotationValidateOptions(string name); - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public interface IConfigureNamedOptions<in TOptions> : IConfigureOptions<TOptions> where TOptions : class { - void Configure(string name, TOptions options); + void Configure(string? name, TOptions options); } public interface IOptionsMonitor<out TOptions> { - TOptions Get(string name); + TOptions Get(string? name); - IDisposable OnChange(Action<TOptions, string> listener); + IDisposable? OnChange(Action<TOptions, string?> listener); } public interface IOptionsMonitorCache<TOptions> where TOptions : class { - TOptions GetOrAdd(string name, Func<TOptions> createOptions); + TOptions GetOrAdd(string? name, Func<TOptions> createOptions); - bool TryAdd(string name, TOptions options); + bool TryAdd(string? name, TOptions options); - bool TryRemove(string name); + bool TryRemove(string? name); } public interface IOptionsSnapshot<out TOptions> : IOptions<TOptions> where TOptions : class { - TOptions Get(string name); + TOptions Get(string? name); } public interface IPostConfigureOptions<in TOptions> where TOptions : class { - void PostConfigure(string name, TOptions options); + void PostConfigure(string? name, TOptions options); } public interface IValidateOptions<TOptions> where TOptions : class { - ValidateOptionsResult Validate(string name, TOptions options); + ValidateOptionsResult Validate(string? name, TOptions options); } public class NamedConfigureFromConfigurationOptions<TOptions> : ConfigureNamedOptions<TOptions> where TOptions : class { - public NamedConfigureFromConfigurationOptions(string name, IConfiguration config); + public NamedConfigureFromConfigurationOptions(string? name, IConfiguration config); - public NamedConfigureFromConfigurationOptions(string name, IConfiguration config, Action<BinderOptions> configureBinder); + public NamedConfigureFromConfigurationOptions(string? name, IConfiguration config, Action<BinderOptions>? configureBinder); } public class OptionsBuilder<TOptions> where TOptions : class { - public OptionsBuilder(IServiceCollection services, string name); + public OptionsBuilder(IServiceCollection services, string? name); } public class OptionsCache<TOptions> : IOptionsMonitorCache<TOptions> where TOptions : class { - public virtual TOptions GetOrAdd(string name, Func<TOptions> createOptions); + public virtual TOptions GetOrAdd(string? name, Func<TOptions> createOptions); - public virtual bool TryAdd(string name, TOptions options); + public virtual bool TryAdd(string? name, TOptions options); - public virtual bool TryRemove(string name); + public virtual bool TryRemove(string? name); } public class OptionsManager<TOptions> : IOptions<TOptions>, IOptionsSnapshot<TOptions> where TOptions : class { - public virtual TOptions Get(string name); + public virtual TOptions Get(string? name); } public class OptionsMonitor<TOptions> : IDisposable, IOptionsMonitor<TOptions> where TOptions : class { - public virtual TOptions Get(string name); + public virtual TOptions Get(string? name); } public static class OptionsMonitorExtensions { - public static IDisposable OnChange<TOptions>(this IOptionsMonitor<TOptions> monitor, Action<TOptions> listener); + public static IDisposable? OnChange<TOptions>(this IOptionsMonitor<TOptions> monitor, Action<TOptions> listener); } public class OptionsValidationException : Exception { - public OptionsValidationException(string optionsName, Type optionsType, IEnumerable<string> failureMessages); + public OptionsValidationException(string optionsName, Type optionsType, IEnumerable<string>? failureMessages); } public class PostConfigureOptions<TOptions> : IPostConfigureOptions<TOptions> where TOptions : class { - public PostConfigureOptions(string name, Action<TOptions> action); + public PostConfigureOptions(string name, Action<TOptions>? action); - public Action<TOptions> Action { get; } + public Action<TOptions>? Action { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep> : IPostConfigureOptions<TOptions> where TOptions : class where TDep : class { - public PostConfigureOptions(string name, TDep dependency, Action<TOptions, TDep> action); + public PostConfigureOptions(string? name, TDep dependency, Action<TOptions, TDep>? action); - public Action<TOptions, TDep> Action { get; } + public Action<TOptions, TDep>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class { - public PostConfigureOptions(string name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2> action); + public PostConfigureOptions(string? name, TDep1 dependency, TDep2 dependency2, Action<TOptions, TDep1, TDep2>? action); - public Action<TOptions, TDep1, TDep2> Action { get; } + public Action<TOptions, TDep1, TDep2>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2, TDep3> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class { - public PostConfigureOptions(string name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3> action); + public PostConfigureOptions(string? name, TDep1 dependency, TDep2 dependency2, TDep3 dependency3, Action<TOptions, TDep1, TDep2, TDep3>? action); - public Action<TOptions, TDep1, TDep2, TDep3> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2, TDep3, TDep4> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class { - public PostConfigureOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4> action); + public PostConfigureOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Action<TOptions, TDep1, TDep2, TDep3, TDep4>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class PostConfigureOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> : IPostConfigureOptions<TOptions> where TOptions : class where TDep1 : class where TDep2 : class where TDep3 : class where TDep4 : class where TDep5 : class { - public PostConfigureOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> action); + public PostConfigureOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? action); - public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> Action { get; } + public Action<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>? Action { get; } - public string Name { get; } + public string? Name { get; } - public virtual void PostConfigure(string name, TOptions options); + public virtual void PostConfigure(string? name, TOptions options); } public class ValidateOptions<TOptions> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, Func<TOptions, bool> validation, string failureMessage); + public ValidateOptions(string? name, Func<TOptions, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep dependency, Func<TOptions, TDep, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep dependency, Func<TOptions, TDep, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, Func<TOptions, TDep1, TDep2, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, Func<TOptions, TDep1, TDep2, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2, TDep3> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, Func<TOptions, TDep1, TDep2, TDep3, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, Func<TOptions, TDep1, TDep2, TDep3, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2, TDep3, TDep4> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Func<TOptions, TDep1, TDep2, TDep3, TDep4, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, Func<TOptions, TDep1, TDep2, TDep3, TDep4, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5> : IValidateOptions<TOptions> where TOptions : class { - public ValidateOptions(string name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Func<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5, bool> validation, string failureMessage); + public ValidateOptions(string? name, TDep1 dependency1, TDep2 dependency2, TDep3 dependency3, TDep4 dependency4, TDep5 dependency5, Func<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5, bool> validation, string failureMessage); - public string Name { get; } + public string? Name { get; } - public ValidateOptionsResult Validate(string name, TOptions options); + public ValidateOptionsResult Validate(string? name, TOptions options); } public class ValidateOptionsResult { public bool Failed { get; protected set; } - public string FailureMessage { get; protected set; } + public string? FailureMessage { get; protected set; } - public IEnumerable<string> Failures { get; protected set; } + public IEnumerable<string>? Failures { get; protected set; } } }","title":"Microsoft.Extensions.Options"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Primitives/","text":"Microsoft.Extensions.Primitives namespace Microsoft.Extensions.Primitives { public class CancellationChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } public static class ChangeToken { - public static IDisposable OnChange(Func<IChangeToken> changeTokenProducer, Action changeTokenConsumer); + public static IDisposable OnChange(Func<IChangeToken?> changeTokenProducer, Action changeTokenConsumer); - public static IDisposable OnChange<TState>(Func<IChangeToken> changeTokenProducer, Action<TState> changeTokenConsumer, TState state); + public static IDisposable OnChange<TState>(Func<IChangeToken?> changeTokenProducer, Action<TState> changeTokenConsumer, TState state); } public class CompositeChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } public interface IChangeToken { - IDisposable RegisterChangeCallback(Action<object> callback, object state); + IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } - public readonly struct StringSegment : IEquatable<string>, IEquatable<StringSegment> { + public readonly struct StringSegment : IEquatable<string?>, IEquatable<StringSegment> { - public StringSegment(string buffer); + public StringSegment(string? buffer); - public string Buffer { get; } + public string? Buffer { get; } public bool HasValue { get; } - public string Value { get; } + public string? Value { get; } - public override bool Equals(object obj); + public override bool Equals(object? obj); - public bool Equals(string text); + public bool Equals(string? text); - public bool Equals(string text, StringComparison comparisonType); + public bool Equals(string? text, StringComparison comparisonType); - public static implicit operator StringSegment (string value); + public static implicit operator StringSegment (string? value); } - public readonly struct StringValues : ICollection<string>, IEnumerable, IEnumerable<string>, IEquatable<string>, IEquatable<StringValues>, IEquatable<string[]>, IList<string>, IReadOnlyCollection<string>, IReadOnlyList<string> { + public readonly struct StringValues : ICollection<string?>, IEnumerable, IEnumerable<string?>, IEquatable<string?>, IEquatable<StringValues>, IEquatable<string?[]>, IList<string?>, IReadOnlyCollection<string?>, IReadOnlyList<string?> { - bool System.Collections.Generic.ICollection<System.String>.IsReadOnly { get; } + bool ICollection<string?>.IsReadOnly { get; } - string System.Collections.Generic.IList<System.String>.this[int index] { get; set; } + string IList<string?>.this[int index] { get; set; } - void ICollection<string>.Add(string item); + void ICollection<string?>.Add(string item); - void ICollection<string>.Clear(); + void ICollection<string?>.Clear(); - bool ICollection<string>.Contains(string item); + bool ICollection<string?>.Contains(string item); - void ICollection<string>.CopyTo(string[] array, int arrayIndex); + void ICollection<string?>.CopyTo(string[] array, int arrayIndex); - bool ICollection<string>.Remove(string item); + bool ICollection<string?>.Remove(string item); - IEnumerator<string> IEnumerable<string>.GetEnumerator(); + IEnumerator<string> IEnumerable<string?>.GetEnumerator(); - int IList<string>.IndexOf(string item); + int IList<string?>.IndexOf(string item); - void IList<string>.Insert(int index, string item); + void IList<string?>.Insert(int index, string item); - void IList<string>.RemoveAt(int index); + void IList<string?>.RemoveAt(int index); - public string[] ToArray(); + public string?[] ToArray(); - public struct Enumerator : IDisposable, IEnumerator, IEnumerator<string> { + public struct Enumerator : IDisposable, IEnumerator, IEnumerator<string?> { - public string Current { get; } + public string? Current { get; } - object System.Collections.IEnumerator.Current { get; } + object? System.Collections.IEnumerator.Current { get; } } } }","title":"Microsoft.Extensions.Primitives"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Extensions.Primitives/#microsoftextensionsprimitives","text":"namespace Microsoft.Extensions.Primitives { public class CancellationChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } public static class ChangeToken { - public static IDisposable OnChange(Func<IChangeToken> changeTokenProducer, Action changeTokenConsumer); + public static IDisposable OnChange(Func<IChangeToken?> changeTokenProducer, Action changeTokenConsumer); - public static IDisposable OnChange<TState>(Func<IChangeToken> changeTokenProducer, Action<TState> changeTokenConsumer, TState state); + public static IDisposable OnChange<TState>(Func<IChangeToken?> changeTokenProducer, Action<TState> changeTokenConsumer, TState state); } public class CompositeChangeToken : IChangeToken { - public IDisposable RegisterChangeCallback(Action<object> callback, object state); + public IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } public interface IChangeToken { - IDisposable RegisterChangeCallback(Action<object> callback, object state); + IDisposable RegisterChangeCallback(Action<object?> callback, object? state); } - public readonly struct StringSegment : IEquatable<string>, IEquatable<StringSegment> { + public readonly struct StringSegment : IEquatable<string?>, IEquatable<StringSegment> { - public StringSegment(string buffer); + public StringSegment(string? buffer); - public string Buffer { get; } + public string? Buffer { get; } public bool HasValue { get; } - public string Value { get; } + public string? Value { get; } - public override bool Equals(object obj); + public override bool Equals(object? obj); - public bool Equals(string text); + public bool Equals(string? text); - public bool Equals(string text, StringComparison comparisonType); + public bool Equals(string? text, StringComparison comparisonType); - public static implicit operator StringSegment (string value); + public static implicit operator StringSegment (string? value); } - public readonly struct StringValues : ICollection<string>, IEnumerable, IEnumerable<string>, IEquatable<string>, IEquatable<StringValues>, IEquatable<string[]>, IList<string>, IReadOnlyCollection<string>, IReadOnlyList<string> { + public readonly struct StringValues : ICollection<string?>, IEnumerable, IEnumerable<string?>, IEquatable<string?>, IEquatable<StringValues>, IEquatable<string?[]>, IList<string?>, IReadOnlyCollection<string?>, IReadOnlyList<string?> { - bool System.Collections.Generic.ICollection<System.String>.IsReadOnly { get; } + bool ICollection<string?>.IsReadOnly { get; } - string System.Collections.Generic.IList<System.String>.this[int index] { get; set; } + string IList<string?>.this[int index] { get; set; } - void ICollection<string>.Add(string item); + void ICollection<string?>.Add(string item); - void ICollection<string>.Clear(); + void ICollection<string?>.Clear(); - bool ICollection<string>.Contains(string item); + bool ICollection<string?>.Contains(string item); - void ICollection<string>.CopyTo(string[] array, int arrayIndex); + void ICollection<string?>.CopyTo(string[] array, int arrayIndex); - bool ICollection<string>.Remove(string item); + bool ICollection<string?>.Remove(string item); - IEnumerator<string> IEnumerable<string>.GetEnumerator(); + IEnumerator<string> IEnumerable<string?>.GetEnumerator(); - int IList<string>.IndexOf(string item); + int IList<string?>.IndexOf(string item); - void IList<string>.Insert(int index, string item); + void IList<string?>.Insert(int index, string item); - void IList<string>.RemoveAt(int index); + void IList<string?>.RemoveAt(int index); - public string[] ToArray(); + public string?[] ToArray(); - public struct Enumerator : IDisposable, IEnumerator, IEnumerator<string> { + public struct Enumerator : IDisposable, IEnumerator, IEnumerator<string?> { - public string Current { get; } + public string? Current { get; } - object System.Collections.IEnumerator.Current { get; } + object? System.Collections.IEnumerator.Current { get; } } } }","title":"Microsoft.Extensions.Primitives"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.JSInterop.Infrastructure/","text":"Microsoft.JSInterop.Infrastructure namespace Microsoft.JSInterop.Infrastructure { public static class DotNetDispatcher { public static void BeginInvokeDotNet(JSRuntime jsRuntime, DotNetInvocationInfo invocationInfo, string argsJson); public static string? Invoke(JSRuntime jsRuntime, in DotNetInvocationInfo invocationInfo, string argsJson); } }","title":"Microsoft.JSInterop.Infrastructure"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.JSInterop.Infrastructure/#microsoftjsinteropinfrastructure","text":"namespace Microsoft.JSInterop.Infrastructure { public static class DotNetDispatcher { public static void BeginInvokeDotNet(JSRuntime jsRuntime, DotNetInvocationInfo invocationInfo, string argsJson); public static string? Invoke(JSRuntime jsRuntime, in DotNetInvocationInfo invocationInfo, string argsJson); } }","title":"Microsoft.JSInterop.Infrastructure"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.JSInterop/","text":"Microsoft.JSInterop namespace Microsoft.JSInterop { public interface IJSUnmarshalledObjectReference : IAsyncDisposable, IDisposable, IJSInProcessObjectReference, IJSObjectReference { TResult InvokeUnmarshalled<T0, T1, T2, TResult>(string identifier, T0 arg0, T1 arg1, T2 arg2); TResult InvokeUnmarshalled<T0, T1, TResult>(string identifier, T0 arg0, T1 arg1); TResult InvokeUnmarshalled<T0, TResult>(string identifier, T0 arg0); TResult InvokeUnmarshalled<TResult>(string identifier); } public interface IJSUnmarshalledRuntime { TResult InvokeUnmarshalled<T0, T1, T2, TResult>(string identifier, T0 arg0, T1 arg1, T2 arg2); TResult InvokeUnmarshalled<T0, T1, TResult>(string identifier, T0 arg0, T1 arg1); TResult InvokeUnmarshalled<T0, TResult>(string identifier, T0 arg0); TResult InvokeUnmarshalled<TResult>(string identifier); } }","title":"Microsoft.JSInterop"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.JSInterop/#microsoftjsinterop","text":"namespace Microsoft.JSInterop { public interface IJSUnmarshalledObjectReference : IAsyncDisposable, IDisposable, IJSInProcessObjectReference, IJSObjectReference { TResult InvokeUnmarshalled<T0, T1, T2, TResult>(string identifier, T0 arg0, T1 arg1, T2 arg2); TResult InvokeUnmarshalled<T0, T1, TResult>(string identifier, T0 arg0, T1 arg1); TResult InvokeUnmarshalled<T0, TResult>(string identifier, T0 arg0); TResult InvokeUnmarshalled<TResult>(string identifier); } public interface IJSUnmarshalledRuntime { TResult InvokeUnmarshalled<T0, T1, T2, TResult>(string identifier, T0 arg0, T1 arg1, T2 arg2); TResult InvokeUnmarshalled<T0, T1, TResult>(string identifier, T0 arg0, T1 arg1); TResult InvokeUnmarshalled<T0, TResult>(string identifier, T0 arg0); TResult InvokeUnmarshalled<TResult>(string identifier); } }","title":"Microsoft.JSInterop"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Net.Http.Headers/","text":"Microsoft.Net.Http.Headers namespace Microsoft.Net.Http.Headers { public static class HeaderNames { public static readonly string Authority; public static readonly string Method; public static readonly string Path; public static readonly string Scheme; public static readonly string Status; } public class SetCookieHeaderValue { public IList<StringSegment> Extensions { get; } } }","title":"Microsoft.Net.Http.Headers"},{"location":"Microsoft.AspNetCore.App/7.0_Microsoft.Net.Http.Headers/#microsoftnethttpheaders","text":"namespace Microsoft.Net.Http.Headers { public static class HeaderNames { public static readonly string Authority; public static readonly string Method; public static readonly string Path; public static readonly string Scheme; public static readonly string Status; } public class SetCookieHeaderValue { public IList<StringSegment> Extensions { get; } } }","title":"Microsoft.Net.Http.Headers"},{"location":"Microsoft.AspNetCore.App/7.0_System.Diagnostics.Eventing.Reader/","text":"System.Diagnostics.Eventing.Reader namespace System.Diagnostics.Eventing.Reader { - public class EventBookmark { + public sealed class EventBookmark { + public EventBookmark(string bookmarkXml); + public string BookmarkXml { get; } } }","title":"System.Diagnostics.Eventing.Reader"},{"location":"Microsoft.AspNetCore.App/7.0_System.Diagnostics.Eventing.Reader/#systemdiagnosticseventingreader","text":"namespace System.Diagnostics.Eventing.Reader { - public class EventBookmark { + public sealed class EventBookmark { + public EventBookmark(string bookmarkXml); + public string BookmarkXml { get; } } }","title":"System.Diagnostics.Eventing.Reader"},{"location":"Microsoft.AspNetCore.App/7.0_System.Security.Claims/","text":"System.Security.Claims namespace System.Security.Claims { public static class PrincipalExtensions { - public static string FindFirstValue(this ClaimsPrincipal principal, string claimType); + public static string? FindFirstValue(this ClaimsPrincipal principal, string claimType); } }","title":"System.Security.Claims"},{"location":"Microsoft.AspNetCore.App/7.0_System.Security.Claims/#systemsecurityclaims","text":"namespace System.Security.Claims { public static class PrincipalExtensions { - public static string FindFirstValue(this ClaimsPrincipal principal, string claimType); + public static string? FindFirstValue(this ClaimsPrincipal principal, string claimType); } }","title":"System.Security.Claims"},{"location":"Microsoft.AspNetCore.App/7.0_System.Threading.RateLimiting/","text":"System.Threading.RateLimiting +namespace System.Threading.RateLimiting { + public sealed class ConcurrencyLimiter : RateLimiter { + public ConcurrencyLimiter(ConcurrencyLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int permitCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + } + public sealed class ConcurrencyLimiterOptions { + public ConcurrencyLimiterOptions(); + public int PermitLimit { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + } + public sealed class FixedWindowRateLimiter : ReplenishingRateLimiter { + public FixedWindowRateLimiter(FixedWindowRateLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + public override bool IsAutoReplenishing { get; } + public override TimeSpan ReplenishmentPeriod { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int requestCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int requestCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + public override bool TryReplenish(); + } + public sealed class FixedWindowRateLimiterOptions { + public FixedWindowRateLimiterOptions(); + public bool AutoReplenishment { get; set; } + public int PermitLimit { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + public TimeSpan Window { get; set; } + } + public static class MetadataName { + public static MetadataName<string> ReasonPhrase { get; } + public static MetadataName<TimeSpan> RetryAfter { get; } + public static MetadataName<T> Create<T>(string name); + } + public sealed class MetadataName<T> : IEquatable<MetadataName<T>> { + public MetadataName(string name); + public string Name { get; } + public override bool Equals(object? obj); + public bool Equals(MetadataName<T>? other); + public override int GetHashCode(); + public static bool operator ==(MetadataName<T> left, MetadataName<T> right); + public static bool operator !=(MetadataName<T> left, MetadataName<T> right); + public override string ToString(); + } + public static class PartitionedRateLimiter { + public static PartitionedRateLimiter<TResource> Create<TResource, TPartitionKey>(Func<TResource, RateLimitPartition<TPartitionKey>> partitioner, IEqualityComparer<TPartitionKey>? equalityComparer = null); + public static PartitionedRateLimiter<TResource> CreateChained<TResource>(params PartitionedRateLimiter<TResource>[] limiters); + } + public abstract class PartitionedRateLimiter<TResource> : IAsyncDisposable, IDisposable { + protected PartitionedRateLimiter(); + public ValueTask<RateLimitLease> AcquireAsync(TResource resource, int permitCount = 1, CancellationToken cancellationToken = default(CancellationToken)); + protected abstract ValueTask<RateLimitLease> AcquireAsyncCore(TResource resource, int permitCount, CancellationToken cancellationToken); + public RateLimitLease AttemptAcquire(TResource resource, int permitCount = 1); + protected abstract RateLimitLease AttemptAcquireCore(TResource resource, int permitCount); + public void Dispose(); + protected virtual void Dispose(bool disposing); + public ValueTask DisposeAsync(); + protected virtual ValueTask DisposeAsyncCore(); + public abstract RateLimiterStatistics? GetStatistics(TResource resource); + public PartitionedRateLimiter<TOuter> WithTranslatedKey<TOuter>(Func<TOuter, TResource> keyAdapter, bool leaveOpen); + } + public enum QueueProcessingOrder { + NewestFirst = 1, + OldestFirst = 0, + } + public abstract class RateLimiter : IAsyncDisposable, IDisposable { + protected RateLimiter(); + public abstract TimeSpan? IdleDuration { get; } + public ValueTask<RateLimitLease> AcquireAsync(int permitCount = 1, CancellationToken cancellationToken = default(CancellationToken)); + protected abstract ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken); + public RateLimitLease AttemptAcquire(int permitCount = 1); + protected abstract RateLimitLease AttemptAcquireCore(int permitCount); + public void Dispose(); + protected virtual void Dispose(bool disposing); + public ValueTask DisposeAsync(); + protected virtual ValueTask DisposeAsyncCore(); + public abstract RateLimiterStatistics? GetStatistics(); + } + public class RateLimiterStatistics { + public RateLimiterStatistics(); + public long CurrentAvailablePermits { get; set; } + public long CurrentQueuedCount { get; set; } + public long TotalFailedLeases { get; set; } + public long TotalSuccessfulLeases { get; set; } + } + public abstract class RateLimitLease : IDisposable { + protected RateLimitLease(); + public abstract bool IsAcquired { get; } + public abstract IEnumerable<string> MetadataNames { get; } + public void Dispose(); + protected virtual void Dispose(bool disposing); + public virtual IEnumerable<KeyValuePair<string, object?>> GetAllMetadata(); + public abstract bool TryGetMetadata(string metadataName, out object? metadata); + public bool TryGetMetadata<T>(MetadataName<T> metadataName, out T metadata); + } + public static class RateLimitPartition { + public static RateLimitPartition<TKey> Get<TKey>(TKey partitionKey, Func<TKey, RateLimiter> factory); + public static RateLimitPartition<TKey> GetConcurrencyLimiter<TKey>(TKey partitionKey, Func<TKey, ConcurrencyLimiterOptions> factory); + public static RateLimitPartition<TKey> GetFixedWindowLimiter<TKey>(TKey partitionKey, Func<TKey, FixedWindowRateLimiterOptions> factory); + public static RateLimitPartition<TKey> GetNoLimiter<TKey>(TKey partitionKey); + public static RateLimitPartition<TKey> GetSlidingWindowLimiter<TKey>(TKey partitionKey, Func<TKey, SlidingWindowRateLimiterOptions> factory); + public static RateLimitPartition<TKey> GetTokenBucketLimiter<TKey>(TKey partitionKey, Func<TKey, TokenBucketRateLimiterOptions> factory); + } + public struct RateLimitPartition<TKey> { + public RateLimitPartition(TKey partitionKey, Func<TKey, RateLimiter> factory); + public Func<TKey, RateLimiter> Factory { get; } + public TKey PartitionKey { get; } + } + public abstract class ReplenishingRateLimiter : RateLimiter { + protected ReplenishingRateLimiter(); + public abstract bool IsAutoReplenishing { get; } + public abstract TimeSpan ReplenishmentPeriod { get; } + public abstract bool TryReplenish(); + } + public sealed class SlidingWindowRateLimiter : ReplenishingRateLimiter { + public SlidingWindowRateLimiter(SlidingWindowRateLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + public override bool IsAutoReplenishing { get; } + public override TimeSpan ReplenishmentPeriod { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int requestCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int requestCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + public override bool TryReplenish(); + } + public sealed class SlidingWindowRateLimiterOptions { + public SlidingWindowRateLimiterOptions(); + public bool AutoReplenishment { get; set; } + public int PermitLimit { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + public int SegmentsPerWindow { get; set; } + public TimeSpan Window { get; set; } + } + public sealed class TokenBucketRateLimiter : ReplenishingRateLimiter { + public TokenBucketRateLimiter(TokenBucketRateLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + public override bool IsAutoReplenishing { get; } + public override TimeSpan ReplenishmentPeriod { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int tokenCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int tokenCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + public override bool TryReplenish(); + } + public sealed class TokenBucketRateLimiterOptions { + public TokenBucketRateLimiterOptions(); + public bool AutoReplenishment { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + public TimeSpan ReplenishmentPeriod { get; set; } + public int TokenLimit { get; set; } + public int TokensPerPeriod { get; set; } + } +}","title":"System.Threading.RateLimiting"},{"location":"Microsoft.AspNetCore.App/7.0_System.Threading.RateLimiting/#systemthreadingratelimiting","text":"+namespace System.Threading.RateLimiting { + public sealed class ConcurrencyLimiter : RateLimiter { + public ConcurrencyLimiter(ConcurrencyLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int permitCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + } + public sealed class ConcurrencyLimiterOptions { + public ConcurrencyLimiterOptions(); + public int PermitLimit { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + } + public sealed class FixedWindowRateLimiter : ReplenishingRateLimiter { + public FixedWindowRateLimiter(FixedWindowRateLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + public override bool IsAutoReplenishing { get; } + public override TimeSpan ReplenishmentPeriod { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int requestCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int requestCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + public override bool TryReplenish(); + } + public sealed class FixedWindowRateLimiterOptions { + public FixedWindowRateLimiterOptions(); + public bool AutoReplenishment { get; set; } + public int PermitLimit { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + public TimeSpan Window { get; set; } + } + public static class MetadataName { + public static MetadataName<string> ReasonPhrase { get; } + public static MetadataName<TimeSpan> RetryAfter { get; } + public static MetadataName<T> Create<T>(string name); + } + public sealed class MetadataName<T> : IEquatable<MetadataName<T>> { + public MetadataName(string name); + public string Name { get; } + public override bool Equals(object? obj); + public bool Equals(MetadataName<T>? other); + public override int GetHashCode(); + public static bool operator ==(MetadataName<T> left, MetadataName<T> right); + public static bool operator !=(MetadataName<T> left, MetadataName<T> right); + public override string ToString(); + } + public static class PartitionedRateLimiter { + public static PartitionedRateLimiter<TResource> Create<TResource, TPartitionKey>(Func<TResource, RateLimitPartition<TPartitionKey>> partitioner, IEqualityComparer<TPartitionKey>? equalityComparer = null); + public static PartitionedRateLimiter<TResource> CreateChained<TResource>(params PartitionedRateLimiter<TResource>[] limiters); + } + public abstract class PartitionedRateLimiter<TResource> : IAsyncDisposable, IDisposable { + protected PartitionedRateLimiter(); + public ValueTask<RateLimitLease> AcquireAsync(TResource resource, int permitCount = 1, CancellationToken cancellationToken = default(CancellationToken)); + protected abstract ValueTask<RateLimitLease> AcquireAsyncCore(TResource resource, int permitCount, CancellationToken cancellationToken); + public RateLimitLease AttemptAcquire(TResource resource, int permitCount = 1); + protected abstract RateLimitLease AttemptAcquireCore(TResource resource, int permitCount); + public void Dispose(); + protected virtual void Dispose(bool disposing); + public ValueTask DisposeAsync(); + protected virtual ValueTask DisposeAsyncCore(); + public abstract RateLimiterStatistics? GetStatistics(TResource resource); + public PartitionedRateLimiter<TOuter> WithTranslatedKey<TOuter>(Func<TOuter, TResource> keyAdapter, bool leaveOpen); + } + public enum QueueProcessingOrder { + NewestFirst = 1, + OldestFirst = 0, + } + public abstract class RateLimiter : IAsyncDisposable, IDisposable { + protected RateLimiter(); + public abstract TimeSpan? IdleDuration { get; } + public ValueTask<RateLimitLease> AcquireAsync(int permitCount = 1, CancellationToken cancellationToken = default(CancellationToken)); + protected abstract ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken); + public RateLimitLease AttemptAcquire(int permitCount = 1); + protected abstract RateLimitLease AttemptAcquireCore(int permitCount); + public void Dispose(); + protected virtual void Dispose(bool disposing); + public ValueTask DisposeAsync(); + protected virtual ValueTask DisposeAsyncCore(); + public abstract RateLimiterStatistics? GetStatistics(); + } + public class RateLimiterStatistics { + public RateLimiterStatistics(); + public long CurrentAvailablePermits { get; set; } + public long CurrentQueuedCount { get; set; } + public long TotalFailedLeases { get; set; } + public long TotalSuccessfulLeases { get; set; } + } + public abstract class RateLimitLease : IDisposable { + protected RateLimitLease(); + public abstract bool IsAcquired { get; } + public abstract IEnumerable<string> MetadataNames { get; } + public void Dispose(); + protected virtual void Dispose(bool disposing); + public virtual IEnumerable<KeyValuePair<string, object?>> GetAllMetadata(); + public abstract bool TryGetMetadata(string metadataName, out object? metadata); + public bool TryGetMetadata<T>(MetadataName<T> metadataName, out T metadata); + } + public static class RateLimitPartition { + public static RateLimitPartition<TKey> Get<TKey>(TKey partitionKey, Func<TKey, RateLimiter> factory); + public static RateLimitPartition<TKey> GetConcurrencyLimiter<TKey>(TKey partitionKey, Func<TKey, ConcurrencyLimiterOptions> factory); + public static RateLimitPartition<TKey> GetFixedWindowLimiter<TKey>(TKey partitionKey, Func<TKey, FixedWindowRateLimiterOptions> factory); + public static RateLimitPartition<TKey> GetNoLimiter<TKey>(TKey partitionKey); + public static RateLimitPartition<TKey> GetSlidingWindowLimiter<TKey>(TKey partitionKey, Func<TKey, SlidingWindowRateLimiterOptions> factory); + public static RateLimitPartition<TKey> GetTokenBucketLimiter<TKey>(TKey partitionKey, Func<TKey, TokenBucketRateLimiterOptions> factory); + } + public struct RateLimitPartition<TKey> { + public RateLimitPartition(TKey partitionKey, Func<TKey, RateLimiter> factory); + public Func<TKey, RateLimiter> Factory { get; } + public TKey PartitionKey { get; } + } + public abstract class ReplenishingRateLimiter : RateLimiter { + protected ReplenishingRateLimiter(); + public abstract bool IsAutoReplenishing { get; } + public abstract TimeSpan ReplenishmentPeriod { get; } + public abstract bool TryReplenish(); + } + public sealed class SlidingWindowRateLimiter : ReplenishingRateLimiter { + public SlidingWindowRateLimiter(SlidingWindowRateLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + public override bool IsAutoReplenishing { get; } + public override TimeSpan ReplenishmentPeriod { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int requestCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int requestCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + public override bool TryReplenish(); + } + public sealed class SlidingWindowRateLimiterOptions { + public SlidingWindowRateLimiterOptions(); + public bool AutoReplenishment { get; set; } + public int PermitLimit { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + public int SegmentsPerWindow { get; set; } + public TimeSpan Window { get; set; } + } + public sealed class TokenBucketRateLimiter : ReplenishingRateLimiter { + public TokenBucketRateLimiter(TokenBucketRateLimiterOptions options); + public override TimeSpan? IdleDuration { get; } + public override bool IsAutoReplenishing { get; } + public override TimeSpan ReplenishmentPeriod { get; } + protected override ValueTask<RateLimitLease> AcquireAsyncCore(int tokenCount, CancellationToken cancellationToken = default(CancellationToken)); + protected override RateLimitLease AttemptAcquireCore(int tokenCount); + protected override void Dispose(bool disposing); + protected override ValueTask DisposeAsyncCore(); + public override RateLimiterStatistics? GetStatistics(); + public override bool TryReplenish(); + } + public sealed class TokenBucketRateLimiterOptions { + public TokenBucketRateLimiterOptions(); + public bool AutoReplenishment { get; set; } + public int QueueLimit { get; set; } + public QueueProcessingOrder QueueProcessingOrder { get; set; } + public TimeSpan ReplenishmentPeriod { get; set; } + public int TokenLimit { get; set; } + public int TokensPerPeriod { get; set; } + } +}","title":"System.Threading.RateLimiting"},{"location":"Microsoft.NETCore.App/7.0/","text":"API Difference 6.0 vs 7.0 API listing follows standard diff formatting. Lines preceded by a '+' are additions and a '-' indicates removal. Microsoft.VisualBasic.FileIO Microsoft.Win32 Microsoft.Win32.SafeHandles System System.Buffers System.CodeDom.Compiler System.Collections System.Collections.Generic System.Collections.Immutable System.Collections.Specialized System.ComponentModel System.ComponentModel.DataAnnotations System.ComponentModel.Design.Serialization System.Data System.Data.Common System.Data.SqlTypes System.Diagnostics System.Diagnostics.CodeAnalysis System.Diagnostics.Metrics System.Diagnostics.SymbolStore System.Drawing System.Formats.Asn1 System.Formats.Tar System.IO System.IO.Compression System.IO.Pipes System.Linq System.Net System.Net.Http System.Net.Http.Headers System.Net.Http.Json System.Net.Mail System.Net.NetworkInformation System.Net.Quic System.Net.Security System.Net.Sockets System.Net.WebSockets System.Numerics System.Reflection System.Reflection.Emit System.Reflection.Metadata System.Reflection.Metadata.Ecma335 System.Reflection.PortableExecutable System.Resources System.Runtime System.Runtime.CompilerServices System.Runtime.InteropServices System.Runtime.InteropServices.ComTypes System.Runtime.InteropServices.JavaScript System.Runtime.InteropServices.Marshalling System.Runtime.Intrinsics System.Runtime.Intrinsics.Arm System.Runtime.Intrinsics.X86 System.Runtime.Serialization System.Runtime.Serialization.DataContracts System.Runtime.Serialization.Json System.Runtime.Versioning System.Security System.Security.Authentication System.Security.Authentication.ExtendedProtection System.Security.Cryptography System.Security.Cryptography.X509Certificates System.Security.Policy System.Text System.Text.Json System.Text.Json.Nodes System.Text.Json.Serialization System.Text.Json.Serialization.Metadata System.Text.RegularExpressions System.Text.Unicode System.Threading System.Threading.Tasks System.Threading.Tasks.Dataflow System.Timers System.Transactions System.Web System.Xml System.Xml.Linq System.Xml.Schema System.Xml.Serialization System.Xml.XPath System.Xml.Xsl","title":"API Difference 6.0 vs 7.0"},{"location":"Microsoft.NETCore.App/7.0/#api-difference-60-vs-70","text":"API listing follows standard diff formatting. Lines preceded by a '+' are additions and a '-' indicates removal. Microsoft.VisualBasic.FileIO Microsoft.Win32 Microsoft.Win32.SafeHandles System System.Buffers System.CodeDom.Compiler System.Collections System.Collections.Generic System.Collections.Immutable System.Collections.Specialized System.ComponentModel System.ComponentModel.DataAnnotations System.ComponentModel.Design.Serialization System.Data System.Data.Common System.Data.SqlTypes System.Diagnostics System.Diagnostics.CodeAnalysis System.Diagnostics.Metrics System.Diagnostics.SymbolStore System.Drawing System.Formats.Asn1 System.Formats.Tar System.IO System.IO.Compression System.IO.Pipes System.Linq System.Net System.Net.Http System.Net.Http.Headers System.Net.Http.Json System.Net.Mail System.Net.NetworkInformation System.Net.Quic System.Net.Security System.Net.Sockets System.Net.WebSockets System.Numerics System.Reflection System.Reflection.Emit System.Reflection.Metadata System.Reflection.Metadata.Ecma335 System.Reflection.PortableExecutable System.Resources System.Runtime System.Runtime.CompilerServices System.Runtime.InteropServices System.Runtime.InteropServices.ComTypes System.Runtime.InteropServices.JavaScript System.Runtime.InteropServices.Marshalling System.Runtime.Intrinsics System.Runtime.Intrinsics.Arm System.Runtime.Intrinsics.X86 System.Runtime.Serialization System.Runtime.Serialization.DataContracts System.Runtime.Serialization.Json System.Runtime.Versioning System.Security System.Security.Authentication System.Security.Authentication.ExtendedProtection System.Security.Cryptography System.Security.Cryptography.X509Certificates System.Security.Policy System.Text System.Text.Json System.Text.Json.Nodes System.Text.Json.Serialization System.Text.Json.Serialization.Metadata System.Text.RegularExpressions System.Text.Unicode System.Threading System.Threading.Tasks System.Threading.Tasks.Dataflow System.Timers System.Transactions System.Web System.Xml System.Xml.Linq System.Xml.Schema System.Xml.Serialization System.Xml.XPath System.Xml.Xsl","title":"API Difference 6.0 vs 7.0"},{"location":"Microsoft.NETCore.App/7.0_Microsoft.VisualBasic.FileIO/","text":"Microsoft.VisualBasic.FileIO namespace Microsoft.VisualBasic.FileIO { public class TextFieldParser : IDisposable { public string[]? CommentTokens { get; set; } } }","title":"Microsoft.VisualBasic.FileIO"},{"location":"Microsoft.NETCore.App/7.0_Microsoft.VisualBasic.FileIO/#microsoftvisualbasicfileio","text":"namespace Microsoft.VisualBasic.FileIO { public class TextFieldParser : IDisposable { public string[]? CommentTokens { get; set; } } }","title":"Microsoft.VisualBasic.FileIO"},{"location":"Microsoft.NETCore.App/7.0_Microsoft.Win32.SafeHandles/","text":"Microsoft.Win32.SafeHandles namespace Microsoft.Win32.SafeHandles { public abstract class SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid { protected SafeNCryptHandle(); protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle); - public override bool IsInvalid { get; } } public sealed class SafeNCryptKeyHandle : SafeNCryptHandle { public SafeNCryptKeyHandle(); public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle); } public sealed class SafeNCryptProviderHandle : SafeNCryptHandle { public SafeNCryptProviderHandle(); } public sealed class SafeNCryptSecretHandle : SafeNCryptHandle { public SafeNCryptSecretHandle(); } }","title":"Microsoft.Win32.SafeHandles"},{"location":"Microsoft.NETCore.App/7.0_Microsoft.Win32.SafeHandles/#microsoftwin32safehandles","text":"namespace Microsoft.Win32.SafeHandles { public abstract class SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid { protected SafeNCryptHandle(); protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle); - public override bool IsInvalid { get; } } public sealed class SafeNCryptKeyHandle : SafeNCryptHandle { public SafeNCryptKeyHandle(); public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle); } public sealed class SafeNCryptProviderHandle : SafeNCryptHandle { public SafeNCryptProviderHandle(); } public sealed class SafeNCryptSecretHandle : SafeNCryptHandle { public SafeNCryptSecretHandle(); } }","title":"Microsoft.Win32.SafeHandles"},{"location":"Microsoft.NETCore.App/7.0_Microsoft.Win32/","text":"Microsoft.Win32 namespace Microsoft.Win32 { public sealed class RegistryKey : MarshalByRefObject, IDisposable { public object? GetValue(string? name, object? defaultValue); public object? GetValue(string? name, object? defaultValue, RegistryValueOptions options); } }","title":"Microsoft.Win32"},{"location":"Microsoft.NETCore.App/7.0_Microsoft.Win32/#microsoftwin32","text":"namespace Microsoft.Win32 { public sealed class RegistryKey : MarshalByRefObject, IDisposable { public object? GetValue(string? name, object? defaultValue); public object? GetValue(string? name, object? defaultValue, RegistryValueOptions options); } }","title":"Microsoft.Win32"},{"location":"Microsoft.NETCore.App/7.0_System.Buffers/","text":"System.Buffers namespace System.Buffers { public static class BuffersExtensions { - public static SequencePosition? PositionOf<T>(this in ReadOnlySequence<T> source, T value) where T : IEquatable<T>; + public static SequencePosition? PositionOf<T>(this in ReadOnlySequence<T> source, T value) where T : IEquatable<T>?; } public ref struct SequenceReader<T> where T : struct { + public bool TryReadExact(int count, out ReadOnlySequence<T> sequence); } public readonly struct StandardFormat : IEquatable<StandardFormat> { public static StandardFormat Parse(ReadOnlySpan<char> format); public static StandardFormat Parse(string? format); public static bool TryParse(ReadOnlySpan<char> format, out StandardFormat result); } }","title":"System.Buffers"},{"location":"Microsoft.NETCore.App/7.0_System.Buffers/#systembuffers","text":"namespace System.Buffers { public static class BuffersExtensions { - public static SequencePosition? PositionOf<T>(this in ReadOnlySequence<T> source, T value) where T : IEquatable<T>; + public static SequencePosition? PositionOf<T>(this in ReadOnlySequence<T> source, T value) where T : IEquatable<T>?; } public ref struct SequenceReader<T> where T : struct { + public bool TryReadExact(int count, out ReadOnlySequence<T> sequence); } public readonly struct StandardFormat : IEquatable<StandardFormat> { public static StandardFormat Parse(ReadOnlySpan<char> format); public static StandardFormat Parse(string? format); public static bool TryParse(ReadOnlySpan<char> format, out StandardFormat result); } }","title":"System.Buffers"},{"location":"Microsoft.NETCore.App/7.0_System.CodeDom.Compiler/","text":"System.CodeDom.Compiler namespace System.CodeDom.Compiler { public class IndentedTextWriter : TextWriter { public override void Write(string format, object? arg0); public override void Write(string format, object? arg0, object? arg1); public override void Write(string format, params object?[] arg); public override void WriteLine(string format, object? arg0); public override void WriteLine(string format, object? arg0, object? arg1); public override void WriteLine(string format, params object?[] arg); } }","title":"System.CodeDom.Compiler"},{"location":"Microsoft.NETCore.App/7.0_System.CodeDom.Compiler/#systemcodedomcompiler","text":"namespace System.CodeDom.Compiler { public class IndentedTextWriter : TextWriter { public override void Write(string format, object? arg0); public override void Write(string format, object? arg0, object? arg1); public override void Write(string format, params object?[] arg); public override void WriteLine(string format, object? arg0); public override void WriteLine(string format, object? arg0, object? arg1); public override void WriteLine(string format, params object?[] arg); } }","title":"System.CodeDom.Compiler"},{"location":"Microsoft.NETCore.App/7.0_System.Collections.Generic/","text":"System.Collections.Generic namespace System.Collections.Generic { public static class CollectionExtensions { + public static ReadOnlyCollection<T> AsReadOnly<T>(this IList<T> list); + public static ReadOnlyDictionary<TKey, TValue> AsReadOnly<TKey, TValue>(this IDictionary<TKey, TValue> dictionary); } public class SortedList<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> { + public TKey GetKeyAtIndex(int index); + public TValue GetValueAtIndex(int index); + public void SetValueAtIndex(int index, TValue value); } }","title":"System.Collections.Generic"},{"location":"Microsoft.NETCore.App/7.0_System.Collections.Generic/#systemcollectionsgeneric","text":"namespace System.Collections.Generic { public static class CollectionExtensions { + public static ReadOnlyCollection<T> AsReadOnly<T>(this IList<T> list); + public static ReadOnlyDictionary<TKey, TValue> AsReadOnly<TKey, TValue>(this IDictionary<TKey, TValue> dictionary); } public class SortedList<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> { + public TKey GetKeyAtIndex(int index); + public TValue GetValueAtIndex(int index); + public void SetValueAtIndex(int index, TValue value); } }","title":"System.Collections.Generic"},{"location":"Microsoft.NETCore.App/7.0_System.Collections.Immutable/","text":"System.Collections.Immutable namespace System.Collections.Immutable { public static class ImmutableArray { + public static ImmutableArray<T> Create<T>(ReadOnlySpan<T> items); + public static ImmutableArray<T> Create<T>(Span<T> items); + public static ImmutableArray<T> ToImmutableArray<T>(this ReadOnlySpan<T> items); + public static ImmutableArray<T> ToImmutableArray<T>(this Span<T> items); } public readonly struct ImmutableArray<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IEquatable<ImmutableArray<T>>, IImmutableList<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IStructuralComparable, IStructuralEquatable { + public ImmutableArray<T> AddRange(ImmutableArray<T> items, int length); + public ImmutableArray<T> AddRange(ReadOnlySpan<T> items); + public ImmutableArray<T> AddRange(params T[] items); + public ImmutableArray<T> AddRange(T[] items, int length); + public ImmutableArray<T> AddRange<TDerived>(ImmutableArray<TDerived> items) where TDerived : T; + public ImmutableArray<T> AddRange<TDerived>(TDerived[] items) where TDerived : T; + public ReadOnlySpan<T> AsSpan(int start, int length); + public ReadOnlySpan<T> AsSpan(Range range); + public void CopyTo(Span<T> destination); + public ImmutableArray<T> InsertRange(int index, ReadOnlySpan<T> items); + public ImmutableArray<T> InsertRange(int index, T[] items); + public ImmutableArray<T> RemoveRange(ReadOnlySpan<T> items, IEqualityComparer<T>? equalityComparer = null); + public ImmutableArray<T> RemoveRange(T[] items, IEqualityComparer<T>? equalityComparer = null); + public ImmutableArray<T> Slice(int start, int length); public sealed class Builder : ICollection<T>, IEnumerable, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> { + public void AddRange(ReadOnlySpan<T> items); + public void AddRange<TDerived>(ReadOnlySpan<TDerived> items) where TDerived : T; + public void CopyTo(int sourceIndex, T[] destination, int destinationIndex, int length); + public void CopyTo(Span<T> destination); + public void CopyTo(T[] destination); + public int IndexOf(T item, int startIndex, IEqualityComparer<T>? equalityComparer); + public void InsertRange(int index, IEnumerable<T> items); + public void InsertRange(int index, ImmutableArray<T> items); + public bool Remove(T element, IEqualityComparer<T>? equalityComparer); + public void RemoveAll(Predicate<T> match); + public void RemoveRange(IEnumerable<T> items); + public void RemoveRange(IEnumerable<T> items, IEqualityComparer<T>? equalityComparer); + public void RemoveRange(int index, int length); + public void Replace(T oldValue, T newValue); + public void Replace(T oldValue, T newValue, IEqualityComparer<T>? equalityComparer); } } public sealed class ImmutableList<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableList<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> { public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> { + public bool Remove(T item, IEqualityComparer<T>? equalityComparer); + public void RemoveRange(IEnumerable<T> items); + public void RemoveRange(IEnumerable<T> items, IEqualityComparer<T>? equalityComparer); + public void RemoveRange(int index, int count); + public void Replace(T oldValue, T newValue); + public void Replace(T oldValue, T newValue, IEqualityComparer<T>? equalityComparer); } } public sealed class ImmutableSortedSet<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableSet<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IReadOnlySet<T>, ISet<T> { public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISet<T> { + public int IndexOf(T item); } } }","title":"System.Collections.Immutable"},{"location":"Microsoft.NETCore.App/7.0_System.Collections.Immutable/#systemcollectionsimmutable","text":"namespace System.Collections.Immutable { public static class ImmutableArray { + public static ImmutableArray<T> Create<T>(ReadOnlySpan<T> items); + public static ImmutableArray<T> Create<T>(Span<T> items); + public static ImmutableArray<T> ToImmutableArray<T>(this ReadOnlySpan<T> items); + public static ImmutableArray<T> ToImmutableArray<T>(this Span<T> items); } public readonly struct ImmutableArray<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IEquatable<ImmutableArray<T>>, IImmutableList<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IStructuralComparable, IStructuralEquatable { + public ImmutableArray<T> AddRange(ImmutableArray<T> items, int length); + public ImmutableArray<T> AddRange(ReadOnlySpan<T> items); + public ImmutableArray<T> AddRange(params T[] items); + public ImmutableArray<T> AddRange(T[] items, int length); + public ImmutableArray<T> AddRange<TDerived>(ImmutableArray<TDerived> items) where TDerived : T; + public ImmutableArray<T> AddRange<TDerived>(TDerived[] items) where TDerived : T; + public ReadOnlySpan<T> AsSpan(int start, int length); + public ReadOnlySpan<T> AsSpan(Range range); + public void CopyTo(Span<T> destination); + public ImmutableArray<T> InsertRange(int index, ReadOnlySpan<T> items); + public ImmutableArray<T> InsertRange(int index, T[] items); + public ImmutableArray<T> RemoveRange(ReadOnlySpan<T> items, IEqualityComparer<T>? equalityComparer = null); + public ImmutableArray<T> RemoveRange(T[] items, IEqualityComparer<T>? equalityComparer = null); + public ImmutableArray<T> Slice(int start, int length); public sealed class Builder : ICollection<T>, IEnumerable, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> { + public void AddRange(ReadOnlySpan<T> items); + public void AddRange<TDerived>(ReadOnlySpan<TDerived> items) where TDerived : T; + public void CopyTo(int sourceIndex, T[] destination, int destinationIndex, int length); + public void CopyTo(Span<T> destination); + public void CopyTo(T[] destination); + public int IndexOf(T item, int startIndex, IEqualityComparer<T>? equalityComparer); + public void InsertRange(int index, IEnumerable<T> items); + public void InsertRange(int index, ImmutableArray<T> items); + public bool Remove(T element, IEqualityComparer<T>? equalityComparer); + public void RemoveAll(Predicate<T> match); + public void RemoveRange(IEnumerable<T> items); + public void RemoveRange(IEnumerable<T> items, IEqualityComparer<T>? equalityComparer); + public void RemoveRange(int index, int length); + public void Replace(T oldValue, T newValue); + public void Replace(T oldValue, T newValue, IEqualityComparer<T>? equalityComparer); } } public sealed class ImmutableList<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableList<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> { public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> { + public bool Remove(T item, IEqualityComparer<T>? equalityComparer); + public void RemoveRange(IEnumerable<T> items); + public void RemoveRange(IEnumerable<T> items, IEqualityComparer<T>? equalityComparer); + public void RemoveRange(int index, int count); + public void Replace(T oldValue, T newValue); + public void Replace(T oldValue, T newValue, IEqualityComparer<T>? equalityComparer); } } public sealed class ImmutableSortedSet<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableSet<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IReadOnlySet<T>, ISet<T> { public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISet<T> { + public int IndexOf(T item); } } }","title":"System.Collections.Immutable"},{"location":"Microsoft.NETCore.App/7.0_System.Collections.Specialized/","text":"System.Collections.Specialized namespace System.Collections.Specialized { - public struct BitVector32 { + public struct BitVector32 : IEquatable<BitVector32> { + public bool Equals(BitVector32 other); - public readonly struct Section + public readonly struct Section : IEquatable<BitVector32.Section> } }","title":"System.Collections.Specialized"},{"location":"Microsoft.NETCore.App/7.0_System.Collections.Specialized/#systemcollectionsspecialized","text":"namespace System.Collections.Specialized { - public struct BitVector32 { + public struct BitVector32 : IEquatable<BitVector32> { + public bool Equals(BitVector32 other); - public readonly struct Section + public readonly struct Section : IEquatable<BitVector32.Section> } }","title":"System.Collections.Specialized"},{"location":"Microsoft.NETCore.App/7.0_System.Collections/","text":"System.Collections namespace System.Collections { public class ArrayList : ICloneable, ICollection, IEnumerable, IList { public virtual Array ToArray(Type type); } public class Hashtable : ICloneable, ICollection, IDeserializationCallback, IDictionary, IEnumerable, ISerializable { public Hashtable(IHashCodeProvider? hcp, IComparer? comparer); } }","title":"System.Collections"},{"location":"Microsoft.NETCore.App/7.0_System.Collections/#systemcollections","text":"namespace System.Collections { public class ArrayList : ICloneable, ICollection, IEnumerable, IList { public virtual Array ToArray(Type type); } public class Hashtable : ICloneable, ICollection, IDeserializationCallback, IDictionary, IEnumerable, ISerializable { public Hashtable(IHashCodeProvider? hcp, IComparer? comparer); } }","title":"System.Collections"},{"location":"Microsoft.NETCore.App/7.0_System.ComponentModel.DataAnnotations/","text":"System.ComponentModel.DataAnnotations namespace System.ComponentModel.DataAnnotations { public class RegularExpressionAttribute : ValidationAttribute { public RegularExpressionAttribute(string pattern); + public TimeSpan MatchTimeout { get; } } }","title":"System.ComponentModel.DataAnnotations"},{"location":"Microsoft.NETCore.App/7.0_System.ComponentModel.DataAnnotations/#systemcomponentmodeldataannotations","text":"namespace System.ComponentModel.DataAnnotations { public class RegularExpressionAttribute : ValidationAttribute { public RegularExpressionAttribute(string pattern); + public TimeSpan MatchTimeout { get; } } }","title":"System.ComponentModel.DataAnnotations"},{"location":"Microsoft.NETCore.App/7.0_System.ComponentModel.Design.Serialization/","text":"System.ComponentModel.Design.Serialization namespace System.ComponentModel.Design.Serialization { - public readonly struct MemberRelationship { + public readonly struct MemberRelationship : IEquatable<MemberRelationship> { + public bool Equals(MemberRelationship other); } }","title":"System.ComponentModel.Design.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.ComponentModel.Design.Serialization/#systemcomponentmodeldesignserialization","text":"namespace System.ComponentModel.Design.Serialization { - public readonly struct MemberRelationship { + public readonly struct MemberRelationship : IEquatable<MemberRelationship> { + public bool Equals(MemberRelationship other); } }","title":"System.ComponentModel.Design.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.ComponentModel/","text":"System.ComponentModel namespace System.ComponentModel { public abstract class BaseNumberConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class CultureInfoConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public abstract class CustomTypeDescriptor : ICustomTypeDescriptor { - protected CustomTypeDescriptor(ICustomTypeDescriptor? parent); + protected CustomTypeDescriptor(ICustomTypeDescriptor parent); - public virtual string? GetClassName(); + public virtual string GetClassName(); - public virtual string? GetComponentName(); + public virtual string GetComponentName(); - public virtual EventDescriptor? GetDefaultEvent(); + public virtual EventDescriptor GetDefaultEvent(); - public virtual PropertyDescriptor? GetDefaultProperty(); + public virtual PropertyDescriptor GetDefaultProperty(); - public virtual object? GetPropertyOwner(PropertyDescriptor? pd); + public virtual object GetPropertyOwner(PropertyDescriptor pd); } + public class DateOnlyConverter : TypeConverter { + public DateOnlyConverter(); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); + public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + } public class DateTimeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class DateTimeOffsetConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class DecimalConverter : BaseNumberConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class EnumConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class GuidConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } + public class HalfConverter : BaseNumberConverter { + public HalfConverter(); + } public interface IComNativeDescriptorHandler public interface ICustomTypeDescriptor { - TypeConverter GetConverter(); + TypeConverter? GetConverter(); } + public class Int128Converter : BaseNumberConverter { + public Int128Converter(); + } public abstract class MemberDescriptor { protected static object GetInvokee(Type componentClass, object component); } public class NullableConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class RecommendedAsConfigurableAttribute : Attribute + public class TimeOnlyConverter : TypeConverter { + public TimeOnlyConverter(); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); + public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + } public class TimeSpanConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class TypeConverter { public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); public bool CanConvertTo(Type destinationType); } public sealed class TypeDescriptor { public static Type ComObjectType { get; } public static Type InterfaceType { get; } public static TypeDescriptionProvider AddAttributes(object instance, params Attribute[] attributes); public static TypeDescriptionProvider AddAttributes(Type type, params Attribute[] attributes); public static void AddEditorTable(Type editorBaseType, Hashtable table); public static void AddProvider(TypeDescriptionProvider provider, object instance); public static void AddProvider(TypeDescriptionProvider provider, Type type); public static void AddProviderTransparent(TypeDescriptionProvider provider, object instance); public static void AddProviderTransparent(TypeDescriptionProvider provider, Type type); public static void CreateAssociation(object primary, object secondary); public static object GetAssociation(Type type, object primary); public static AttributeCollection GetAttributes(object component, bool noCustomTypeDesc); public static string? GetClassName(object component, bool noCustomTypeDesc); public static string? GetComponentName(object component, bool noCustomTypeDesc); public static TypeConverter GetConverter(object component, bool noCustomTypeDesc); public static EventDescriptor? GetDefaultEvent(object component, bool noCustomTypeDesc); public static PropertyDescriptor? GetDefaultProperty(object component, bool noCustomTypeDesc); public static object? GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc); public static EventDescriptorCollection GetEvents(object component, Attribute[]? attributes, bool noCustomTypeDesc); public static EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc); public static PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc); public static TypeDescriptionProvider GetProvider(object instance); public static TypeDescriptionProvider GetProvider(Type type); public static Type GetReflectionType(object instance); public static Type GetReflectionType(Type type); public static void RemoveAssociation(object primary, object secondary); public static void RemoveAssociations(object primary); public static void RemoveProvider(TypeDescriptionProvider provider, object instance); public static void RemoveProvider(TypeDescriptionProvider provider, Type type); public static void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance); public static void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type); } public abstract class TypeListConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } + public class UInt128Converter : BaseNumberConverter { + public UInt128Converter(); + } public class VersionConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.ComponentModel"},{"location":"Microsoft.NETCore.App/7.0_System.ComponentModel/#systemcomponentmodel","text":"namespace System.ComponentModel { public abstract class BaseNumberConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class CultureInfoConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public abstract class CustomTypeDescriptor : ICustomTypeDescriptor { - protected CustomTypeDescriptor(ICustomTypeDescriptor? parent); + protected CustomTypeDescriptor(ICustomTypeDescriptor parent); - public virtual string? GetClassName(); + public virtual string GetClassName(); - public virtual string? GetComponentName(); + public virtual string GetComponentName(); - public virtual EventDescriptor? GetDefaultEvent(); + public virtual EventDescriptor GetDefaultEvent(); - public virtual PropertyDescriptor? GetDefaultProperty(); + public virtual PropertyDescriptor GetDefaultProperty(); - public virtual object? GetPropertyOwner(PropertyDescriptor? pd); + public virtual object GetPropertyOwner(PropertyDescriptor pd); } + public class DateOnlyConverter : TypeConverter { + public DateOnlyConverter(); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); + public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + } public class DateTimeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class DateTimeOffsetConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class DecimalConverter : BaseNumberConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class EnumConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class GuidConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } + public class HalfConverter : BaseNumberConverter { + public HalfConverter(); + } public interface IComNativeDescriptorHandler public interface ICustomTypeDescriptor { - TypeConverter GetConverter(); + TypeConverter? GetConverter(); } + public class Int128Converter : BaseNumberConverter { + public Int128Converter(); + } public abstract class MemberDescriptor { protected static object GetInvokee(Type componentClass, object component); } public class NullableConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class RecommendedAsConfigurableAttribute : Attribute + public class TimeOnlyConverter : TypeConverter { + public TimeOnlyConverter(); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); + public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + } public class TimeSpanConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class TypeConverter { public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); public bool CanConvertTo(Type destinationType); } public sealed class TypeDescriptor { public static Type ComObjectType { get; } public static Type InterfaceType { get; } public static TypeDescriptionProvider AddAttributes(object instance, params Attribute[] attributes); public static TypeDescriptionProvider AddAttributes(Type type, params Attribute[] attributes); public static void AddEditorTable(Type editorBaseType, Hashtable table); public static void AddProvider(TypeDescriptionProvider provider, object instance); public static void AddProvider(TypeDescriptionProvider provider, Type type); public static void AddProviderTransparent(TypeDescriptionProvider provider, object instance); public static void AddProviderTransparent(TypeDescriptionProvider provider, Type type); public static void CreateAssociation(object primary, object secondary); public static object GetAssociation(Type type, object primary); public static AttributeCollection GetAttributes(object component, bool noCustomTypeDesc); public static string? GetClassName(object component, bool noCustomTypeDesc); public static string? GetComponentName(object component, bool noCustomTypeDesc); public static TypeConverter GetConverter(object component, bool noCustomTypeDesc); public static EventDescriptor? GetDefaultEvent(object component, bool noCustomTypeDesc); public static PropertyDescriptor? GetDefaultProperty(object component, bool noCustomTypeDesc); public static object? GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc); public static EventDescriptorCollection GetEvents(object component, Attribute[]? attributes, bool noCustomTypeDesc); public static EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc); public static PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc); public static TypeDescriptionProvider GetProvider(object instance); public static TypeDescriptionProvider GetProvider(Type type); public static Type GetReflectionType(object instance); public static Type GetReflectionType(Type type); public static void RemoveAssociation(object primary, object secondary); public static void RemoveAssociations(object primary); public static void RemoveProvider(TypeDescriptionProvider provider, object instance); public static void RemoveProvider(TypeDescriptionProvider provider, Type type); public static void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance); public static void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type); } public abstract class TypeListConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } + public class UInt128Converter : BaseNumberConverter { + public UInt128Converter(); + } public class VersionConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.ComponentModel"},{"location":"Microsoft.NETCore.App/7.0_System.Data.Common/","text":"System.Data.Common namespace System.Data.Common { + public abstract class DbDataSource : IAsyncDisposable, IDisposable { + protected DbDataSource(); + public abstract string ConnectionString { get; } + public DbBatch CreateBatch(); + public DbCommand CreateCommand(string? commandText = null); + public DbConnection CreateConnection(); + protected virtual DbBatch CreateDbBatch(); + protected virtual DbCommand CreateDbCommand(string? commandText = null); + protected abstract DbConnection CreateDbConnection(); + public void Dispose(); + protected virtual void Dispose(bool disposing); + public ValueTask DisposeAsync(); + protected virtual ValueTask DisposeAsyncCore(); + public DbConnection OpenConnection(); + public ValueTask<DbConnection> OpenConnectionAsync(CancellationToken cancellationToken = default(CancellationToken)); + protected virtual DbConnection OpenDbConnection(); + protected virtual ValueTask<DbConnection> OpenDbConnectionAsync(CancellationToken cancellationToken = default(CancellationToken)); + } public abstract class DbProviderFactory { + public virtual DbDataSource CreateDataSource(string connectionString); } }","title":"System.Data.Common"},{"location":"Microsoft.NETCore.App/7.0_System.Data.Common/#systemdatacommon","text":"namespace System.Data.Common { + public abstract class DbDataSource : IAsyncDisposable, IDisposable { + protected DbDataSource(); + public abstract string ConnectionString { get; } + public DbBatch CreateBatch(); + public DbCommand CreateCommand(string? commandText = null); + public DbConnection CreateConnection(); + protected virtual DbBatch CreateDbBatch(); + protected virtual DbCommand CreateDbCommand(string? commandText = null); + protected abstract DbConnection CreateDbConnection(); + public void Dispose(); + protected virtual void Dispose(bool disposing); + public ValueTask DisposeAsync(); + protected virtual ValueTask DisposeAsyncCore(); + public DbConnection OpenConnection(); + public ValueTask<DbConnection> OpenConnectionAsync(CancellationToken cancellationToken = default(CancellationToken)); + protected virtual DbConnection OpenDbConnection(); + protected virtual ValueTask<DbConnection> OpenDbConnectionAsync(CancellationToken cancellationToken = default(CancellationToken)); + } public abstract class DbProviderFactory { + public virtual DbDataSource CreateDataSource(string connectionString); } }","title":"System.Data.Common"},{"location":"Microsoft.NETCore.App/7.0_System.Data.SqlTypes/","text":"System.Data.SqlTypes namespace System.Data.SqlTypes { - public struct SqlBinary : IComparable, INullable, IXmlSerializable { + public struct SqlBinary : IComparable, IEquatable<SqlBinary>, INullable, IXmlSerializable { + public bool Equals(SqlBinary other); + public static SqlBinary WrapBytes(byte[] bytes); } - public struct SqlBoolean : IComparable, INullable, IXmlSerializable { + public struct SqlBoolean : IComparable, IEquatable<SqlBoolean>, INullable, IXmlSerializable { + public bool Equals(SqlBoolean other); } - public struct SqlByte : IComparable, INullable, IXmlSerializable { + public struct SqlByte : IComparable, IEquatable<SqlByte>, INullable, IXmlSerializable { + public bool Equals(SqlByte other); } - public struct SqlDateTime : IComparable, INullable, IXmlSerializable { + public struct SqlDateTime : IComparable, IEquatable<SqlDateTime>, INullable, IXmlSerializable { + public bool Equals(SqlDateTime other); } - public struct SqlDecimal : IComparable, INullable, IXmlSerializable { + public struct SqlDecimal : IComparable, IEquatable<SqlDecimal>, INullable, IXmlSerializable { + public bool Equals(SqlDecimal other); + public int WriteTdsValue(Span<uint> destination); } - public struct SqlDouble : IComparable, INullable, IXmlSerializable { + public struct SqlDouble : IComparable, IEquatable<SqlDouble>, INullable, IXmlSerializable { + public bool Equals(SqlDouble other); } - public struct SqlGuid : IComparable, INullable, IXmlSerializable { + public struct SqlGuid : IComparable, IEquatable<SqlGuid>, INullable, IXmlSerializable { + public bool Equals(SqlGuid other); } - public struct SqlInt16 : IComparable, INullable, IXmlSerializable { + public struct SqlInt16 : IComparable, IEquatable<SqlInt16>, INullable, IXmlSerializable { + public bool Equals(SqlInt16 other); } - public struct SqlInt32 : IComparable, INullable, IXmlSerializable { + public struct SqlInt32 : IComparable, IEquatable<SqlInt32>, INullable, IXmlSerializable { + public bool Equals(SqlInt32 other); } - public struct SqlInt64 : IComparable, INullable, IXmlSerializable { + public struct SqlInt64 : IComparable, IEquatable<SqlInt64>, INullable, IXmlSerializable { + public bool Equals(SqlInt64 other); } - public struct SqlMoney : IComparable, INullable, IXmlSerializable { + public struct SqlMoney : IComparable, IEquatable<SqlMoney>, INullable, IXmlSerializable { + public bool Equals(SqlMoney other); + public static SqlMoney FromTdsValue(long value); + public long GetTdsValue(); } - public struct SqlSingle : IComparable, INullable, IXmlSerializable { + public struct SqlSingle : IComparable, IEquatable<SqlSingle>, INullable, IXmlSerializable { + public bool Equals(SqlSingle other); } - public struct SqlString : IComparable, INullable, IXmlSerializable { + public struct SqlString : IComparable, IEquatable<SqlString>, INullable, IXmlSerializable { + public bool Equals(SqlString other); } }","title":"System.Data.SqlTypes"},{"location":"Microsoft.NETCore.App/7.0_System.Data.SqlTypes/#systemdatasqltypes","text":"namespace System.Data.SqlTypes { - public struct SqlBinary : IComparable, INullable, IXmlSerializable { + public struct SqlBinary : IComparable, IEquatable<SqlBinary>, INullable, IXmlSerializable { + public bool Equals(SqlBinary other); + public static SqlBinary WrapBytes(byte[] bytes); } - public struct SqlBoolean : IComparable, INullable, IXmlSerializable { + public struct SqlBoolean : IComparable, IEquatable<SqlBoolean>, INullable, IXmlSerializable { + public bool Equals(SqlBoolean other); } - public struct SqlByte : IComparable, INullable, IXmlSerializable { + public struct SqlByte : IComparable, IEquatable<SqlByte>, INullable, IXmlSerializable { + public bool Equals(SqlByte other); } - public struct SqlDateTime : IComparable, INullable, IXmlSerializable { + public struct SqlDateTime : IComparable, IEquatable<SqlDateTime>, INullable, IXmlSerializable { + public bool Equals(SqlDateTime other); } - public struct SqlDecimal : IComparable, INullable, IXmlSerializable { + public struct SqlDecimal : IComparable, IEquatable<SqlDecimal>, INullable, IXmlSerializable { + public bool Equals(SqlDecimal other); + public int WriteTdsValue(Span<uint> destination); } - public struct SqlDouble : IComparable, INullable, IXmlSerializable { + public struct SqlDouble : IComparable, IEquatable<SqlDouble>, INullable, IXmlSerializable { + public bool Equals(SqlDouble other); } - public struct SqlGuid : IComparable, INullable, IXmlSerializable { + public struct SqlGuid : IComparable, IEquatable<SqlGuid>, INullable, IXmlSerializable { + public bool Equals(SqlGuid other); } - public struct SqlInt16 : IComparable, INullable, IXmlSerializable { + public struct SqlInt16 : IComparable, IEquatable<SqlInt16>, INullable, IXmlSerializable { + public bool Equals(SqlInt16 other); } - public struct SqlInt32 : IComparable, INullable, IXmlSerializable { + public struct SqlInt32 : IComparable, IEquatable<SqlInt32>, INullable, IXmlSerializable { + public bool Equals(SqlInt32 other); } - public struct SqlInt64 : IComparable, INullable, IXmlSerializable { + public struct SqlInt64 : IComparable, IEquatable<SqlInt64>, INullable, IXmlSerializable { + public bool Equals(SqlInt64 other); } - public struct SqlMoney : IComparable, INullable, IXmlSerializable { + public struct SqlMoney : IComparable, IEquatable<SqlMoney>, INullable, IXmlSerializable { + public bool Equals(SqlMoney other); + public static SqlMoney FromTdsValue(long value); + public long GetTdsValue(); } - public struct SqlSingle : IComparable, INullable, IXmlSerializable { + public struct SqlSingle : IComparable, IEquatable<SqlSingle>, INullable, IXmlSerializable { + public bool Equals(SqlSingle other); } - public struct SqlString : IComparable, INullable, IXmlSerializable { + public struct SqlString : IComparable, IEquatable<SqlString>, INullable, IXmlSerializable { + public bool Equals(SqlString other); } }","title":"System.Data.SqlTypes"},{"location":"Microsoft.NETCore.App/7.0_System.Data/","text":"System.Data namespace System.Data { public class DataColumn : MarshalByValueComponent { public Type DataType { get; set; } } public enum SerializationFormat { Binary = 1, } }","title":"System.Data"},{"location":"Microsoft.NETCore.App/7.0_System.Data/#systemdata","text":"namespace System.Data { public class DataColumn : MarshalByValueComponent { public Type DataType { get; set; } } public enum SerializationFormat { Binary = 1, } }","title":"System.Data"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics.CodeAnalysis/","text":"System.Diagnostics.CodeAnalysis namespace System.Diagnostics.CodeAnalysis { + public sealed class ConstantExpectedAttribute : Attribute { + public ConstantExpectedAttribute(); + public object Max { get; set; } + public object Min { get; set; } + } public sealed class ExcludeFromCodeCoverageAttribute : Attribute { public string Justification { get; set; } } + public sealed class RequiresDynamicCodeAttribute : Attribute { + public RequiresDynamicCodeAttribute(string message); + public string Message { get; } + public string? Url { get; set; } + } + public sealed class SetsRequiredMembersAttribute : Attribute { + public SetsRequiredMembersAttribute(); + } + public sealed class StringSyntaxAttribute : Attribute { + public const string CompositeFormat = \"CompositeFormat\"; + public const string DateOnlyFormat = \"DateOnlyFormat\"; + public const string DateTimeFormat = \"DateTimeFormat\"; + public const string EnumFormat = \"EnumFormat\"; + public const string GuidFormat = \"GuidFormat\"; + public const string Json = \"Json\"; + public const string NumericFormat = \"NumericFormat\"; + public const string Regex = \"Regex\"; + public const string TimeOnlyFormat = \"TimeOnlyFormat\"; + public const string TimeSpanFormat = \"TimeSpanFormat\"; + public const string Uri = \"Uri\"; + public const string Xml = \"Xml\"; + public StringSyntaxAttribute(string syntax); + public StringSyntaxAttribute(string syntax, params object?[] arguments); + public object?[] Arguments { get; } + public string Syntax { get; } + } + public sealed class UnscopedRefAttribute : Attribute { + public UnscopedRefAttribute(); + } }","title":"System.Diagnostics.CodeAnalysis"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics.CodeAnalysis/#systemdiagnosticscodeanalysis","text":"namespace System.Diagnostics.CodeAnalysis { + public sealed class ConstantExpectedAttribute : Attribute { + public ConstantExpectedAttribute(); + public object Max { get; set; } + public object Min { get; set; } + } public sealed class ExcludeFromCodeCoverageAttribute : Attribute { public string Justification { get; set; } } + public sealed class RequiresDynamicCodeAttribute : Attribute { + public RequiresDynamicCodeAttribute(string message); + public string Message { get; } + public string? Url { get; set; } + } + public sealed class SetsRequiredMembersAttribute : Attribute { + public SetsRequiredMembersAttribute(); + } + public sealed class StringSyntaxAttribute : Attribute { + public const string CompositeFormat = \"CompositeFormat\"; + public const string DateOnlyFormat = \"DateOnlyFormat\"; + public const string DateTimeFormat = \"DateTimeFormat\"; + public const string EnumFormat = \"EnumFormat\"; + public const string GuidFormat = \"GuidFormat\"; + public const string Json = \"Json\"; + public const string NumericFormat = \"NumericFormat\"; + public const string Regex = \"Regex\"; + public const string TimeOnlyFormat = \"TimeOnlyFormat\"; + public const string TimeSpanFormat = \"TimeSpanFormat\"; + public const string Uri = \"Uri\"; + public const string Xml = \"Xml\"; + public StringSyntaxAttribute(string syntax); + public StringSyntaxAttribute(string syntax, params object?[] arguments); + public object?[] Arguments { get; } + public string Syntax { get; } + } + public sealed class UnscopedRefAttribute : Attribute { + public UnscopedRefAttribute(); + } }","title":"System.Diagnostics.CodeAnalysis"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics.Metrics/","text":"System.Diagnostics.Metrics namespace System.Diagnostics.Metrics { public class Meter : IDisposable { + public ObservableUpDownCounter<T> CreateObservableUpDownCounter<T>(string name, Func<IEnumerable<Measurement<T>>> observeValues, string unit = null, string description = null) where T : struct; + public ObservableUpDownCounter<T> CreateObservableUpDownCounter<T>(string name, Func<Measurement<T>> observeValue, string unit = null, string description = null) where T : struct; + public ObservableUpDownCounter<T> CreateObservableUpDownCounter<T>(string name, Func<T> observeValue, string unit = null, string description = null) where T : struct; + public UpDownCounter<T> CreateUpDownCounter<T>(string name, string unit = null, string description = null) where T : struct; } + public sealed class ObservableUpDownCounter<T> : ObservableInstrument<T> where T : struct { + protected override IEnumerable<Measurement<T>> Observe(); + } + public sealed class UpDownCounter<T> : Instrument<T> where T : struct { + public void Add(T delta); + public void Add(T delta, KeyValuePair<string, object?> tag); + public void Add(T delta, KeyValuePair<string, object?> tag1, KeyValuePair<string, object?> tag2); + public void Add(T delta, KeyValuePair<string, object?> tag1, KeyValuePair<string, object?> tag2, KeyValuePair<string, object?> tag3); + public void Add(T delta, params KeyValuePair<string, object>[] tags); + public void Add(T delta, in TagList tagList); + public void Add(T delta, ReadOnlySpan<KeyValuePair<string, object?>> tags); + } }","title":"System.Diagnostics.Metrics"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics.Metrics/#systemdiagnosticsmetrics","text":"namespace System.Diagnostics.Metrics { public class Meter : IDisposable { + public ObservableUpDownCounter<T> CreateObservableUpDownCounter<T>(string name, Func<IEnumerable<Measurement<T>>> observeValues, string unit = null, string description = null) where T : struct; + public ObservableUpDownCounter<T> CreateObservableUpDownCounter<T>(string name, Func<Measurement<T>> observeValue, string unit = null, string description = null) where T : struct; + public ObservableUpDownCounter<T> CreateObservableUpDownCounter<T>(string name, Func<T> observeValue, string unit = null, string description = null) where T : struct; + public UpDownCounter<T> CreateUpDownCounter<T>(string name, string unit = null, string description = null) where T : struct; } + public sealed class ObservableUpDownCounter<T> : ObservableInstrument<T> where T : struct { + protected override IEnumerable<Measurement<T>> Observe(); + } + public sealed class UpDownCounter<T> : Instrument<T> where T : struct { + public void Add(T delta); + public void Add(T delta, KeyValuePair<string, object?> tag); + public void Add(T delta, KeyValuePair<string, object?> tag1, KeyValuePair<string, object?> tag2); + public void Add(T delta, KeyValuePair<string, object?> tag1, KeyValuePair<string, object?> tag2, KeyValuePair<string, object?> tag3); + public void Add(T delta, params KeyValuePair<string, object>[] tags); + public void Add(T delta, in TagList tagList); + public void Add(T delta, ReadOnlySpan<KeyValuePair<string, object?>> tags); + } }","title":"System.Diagnostics.Metrics"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics.SymbolStore/","text":"System.Diagnostics.SymbolStore namespace System.Diagnostics.SymbolStore { - public readonly struct SymbolToken + public readonly struct SymbolToken : IEquatable<SymbolToken> }","title":"System.Diagnostics.SymbolStore"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics.SymbolStore/#systemdiagnosticssymbolstore","text":"namespace System.Diagnostics.SymbolStore { - public readonly struct SymbolToken + public readonly struct SymbolToken : IEquatable<SymbolToken> }","title":"System.Diagnostics.SymbolStore"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics/","text":"System.Diagnostics namespace System.Diagnostics { public class Activity : IDisposable { + public bool HasRemoteParent { get; } + public bool IsStopped { get; } + public static event EventHandler<ActivityChangedEventArgs>? CurrentChanged; + public Activity.Enumerator<ActivityEvent> EnumerateEvents(); + public Activity.Enumerator<ActivityLink> EnumerateLinks(); + public Activity.Enumerator<KeyValuePair<string, object?>> EnumerateTagObjects(); + public struct Enumerator<T> { + public ref T Current { get; } + public Activity.Enumerator<T> GetEnumerator(); + public bool MoveNext(); + } } + public readonly struct ActivityChangedEventArgs { + public Activity Current { get; set; } + public Activity Previous { get; set; } + } public readonly struct ActivityContext : IEquatable<ActivityContext> { + public static bool TryParse(string traceParent, string traceState, bool isRemote, out ActivityContext context); } public readonly struct ActivityCreationOptions<T> { + public string? TraceState { get; set; } } public readonly struct ActivityEvent { + public Activity.Enumerator<KeyValuePair<string, object?>> EnumerateTagObjects(); } public readonly struct ActivityLink : IEquatable<ActivityLink> { + public Activity.Enumerator<KeyValuePair<string, object?>> EnumerateTagObjects(); } public sealed class ActivitySource : IDisposable { - public string? Version { get; } + public string Version { get; } - public Activity? CreateActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); + public Activity CreateActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); - public Activity? CreateActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); + public Activity CreateActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); - public Activity? StartActivity(ActivityKind kind, ActivityContext parentContext = default(ActivityContext), IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default(DateTimeOffset), string name = \"\"); + public Activity StartActivity(ActivityKind kind, ActivityContext parentContext = default(ActivityContext), IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset), string name = \"\"); - public Activity? StartActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default(DateTimeOffset)); + public Activity StartActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset)); - public Activity? StartActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default(DateTimeOffset)); + public Activity StartActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset)); } public static class Debug { public static void Assert(bool condition, string? message, string detailMessageFormat, params object?[] args); public static void Print(string format, params object?[] args); public static void WriteLine(string format, params object?[] args); } public class DelimitedListTraceListener : TextWriterTraceListener { public override void TraceEvent(TraceEventCache? eventCache, string source, TraceEventType eventType, int id, string? format, params object?[]? args); } public class DiagnosticListener : DiagnosticSource, IDisposable, IObservable<KeyValuePair<string, object?>> { public override void Write(string name, object? value); } public abstract class DiagnosticSource { public Activity StartActivity(Activity activity, object? args); public void StopActivity(Activity activity, object? args); public abstract void Write(string name, object? value); } public class EventTypeFilter : TraceFilter { public override bool ShouldTrace(TraceEventCache? cache, string source, TraceEventType eventType, int id, string? formatOrMessage, object?[]? args, object? data1, object?[]? data); } + public sealed class InitializingSwitchEventArgs : EventArgs { + public InitializingSwitchEventArgs(Switch @switch); + public Switch Switch { get; } + } + public sealed class InitializingTraceSourceEventArgs : EventArgs { + public InitializingTraceSourceEventArgs(TraceSource traceSource); + public TraceSource TraceSource { get; } + public bool WasInitialized { get; set; } + } public class Process : Component, IDisposable { public TimeSpan PrivilegedProcessorTime { get; } public DateTime StartTime { get; } + public bool WaitForExit(TimeSpan timeout); + public bool WaitForInputIdle(TimeSpan timeout); } public class SourceFilter : TraceFilter { public override bool ShouldTrace(TraceEventCache? cache, string source, TraceEventType eventType, int id, string? formatOrMessage, object?[]? args, object? data1, object?[]? data); } public class StackFrame { public virtual MethodBase GetMethod(); } public class Stopwatch { + public static TimeSpan GetElapsedTime(long startingTimestamp); + public static TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp); } public abstract class Switch { + public string DefaultValue { get; } - protected string Value { get; set; } + public string Value { get; set; } + public static event EventHandler<InitializingSwitchEventArgs>? Initializing; + public void Refresh(); } public sealed class Trace { + public static event EventHandler Refreshing; public static void TraceError(string format, params object?[]? args); public static void TraceInformation(string format, params object?[]? args); public static void TraceWarning(string format, params object?[]? args); } public abstract class TraceFilter { public abstract bool ShouldTrace(TraceEventCache? cache, string source, TraceEventType eventType, int id, string? formatOrMessage, object?[]? args, object? data1, object?[]? data); } public abstract class TraceListener : MarshalByRefObject, IDisposable { public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args); } public class TraceSource { + public SourceLevels DefaultLevel { get; } + public static event EventHandler<InitializingTraceSourceEventArgs>? Initializing; public void TraceEvent(TraceEventType eventType, int id, string? format, params object?[]? args); public void TraceInformation(string? format, params object?[]? args); } + public sealed class UnreachableException : Exception { + public UnreachableException(); + public UnreachableException(string message); + public UnreachableException(string message, Exception innerException); + } public class XmlWriterTraceListener : TextWriterTraceListener { public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args); } }","title":"System.Diagnostics"},{"location":"Microsoft.NETCore.App/7.0_System.Diagnostics/#systemdiagnostics","text":"namespace System.Diagnostics { public class Activity : IDisposable { + public bool HasRemoteParent { get; } + public bool IsStopped { get; } + public static event EventHandler<ActivityChangedEventArgs>? CurrentChanged; + public Activity.Enumerator<ActivityEvent> EnumerateEvents(); + public Activity.Enumerator<ActivityLink> EnumerateLinks(); + public Activity.Enumerator<KeyValuePair<string, object?>> EnumerateTagObjects(); + public struct Enumerator<T> { + public ref T Current { get; } + public Activity.Enumerator<T> GetEnumerator(); + public bool MoveNext(); + } } + public readonly struct ActivityChangedEventArgs { + public Activity Current { get; set; } + public Activity Previous { get; set; } + } public readonly struct ActivityContext : IEquatable<ActivityContext> { + public static bool TryParse(string traceParent, string traceState, bool isRemote, out ActivityContext context); } public readonly struct ActivityCreationOptions<T> { + public string? TraceState { get; set; } } public readonly struct ActivityEvent { + public Activity.Enumerator<KeyValuePair<string, object?>> EnumerateTagObjects(); } public readonly struct ActivityLink : IEquatable<ActivityLink> { + public Activity.Enumerator<KeyValuePair<string, object?>> EnumerateTagObjects(); } public sealed class ActivitySource : IDisposable { - public string? Version { get; } + public string Version { get; } - public Activity? CreateActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); + public Activity CreateActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); - public Activity? CreateActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); + public Activity CreateActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, ActivityIdFormat idFormat = ActivityIdFormat.Unknown); - public Activity? StartActivity(ActivityKind kind, ActivityContext parentContext = default(ActivityContext), IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default(DateTimeOffset), string name = \"\"); + public Activity StartActivity(ActivityKind kind, ActivityContext parentContext = default(ActivityContext), IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset), string name = \"\"); - public Activity? StartActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default(DateTimeOffset)); + public Activity StartActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset)); - public Activity? StartActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default(DateTimeOffset)); + public Activity StartActivity(string name, ActivityKind kind, string parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink> links = null, DateTimeOffset startTime = default(DateTimeOffset)); } public static class Debug { public static void Assert(bool condition, string? message, string detailMessageFormat, params object?[] args); public static void Print(string format, params object?[] args); public static void WriteLine(string format, params object?[] args); } public class DelimitedListTraceListener : TextWriterTraceListener { public override void TraceEvent(TraceEventCache? eventCache, string source, TraceEventType eventType, int id, string? format, params object?[]? args); } public class DiagnosticListener : DiagnosticSource, IDisposable, IObservable<KeyValuePair<string, object?>> { public override void Write(string name, object? value); } public abstract class DiagnosticSource { public Activity StartActivity(Activity activity, object? args); public void StopActivity(Activity activity, object? args); public abstract void Write(string name, object? value); } public class EventTypeFilter : TraceFilter { public override bool ShouldTrace(TraceEventCache? cache, string source, TraceEventType eventType, int id, string? formatOrMessage, object?[]? args, object? data1, object?[]? data); } + public sealed class InitializingSwitchEventArgs : EventArgs { + public InitializingSwitchEventArgs(Switch @switch); + public Switch Switch { get; } + } + public sealed class InitializingTraceSourceEventArgs : EventArgs { + public InitializingTraceSourceEventArgs(TraceSource traceSource); + public TraceSource TraceSource { get; } + public bool WasInitialized { get; set; } + } public class Process : Component, IDisposable { public TimeSpan PrivilegedProcessorTime { get; } public DateTime StartTime { get; } + public bool WaitForExit(TimeSpan timeout); + public bool WaitForInputIdle(TimeSpan timeout); } public class SourceFilter : TraceFilter { public override bool ShouldTrace(TraceEventCache? cache, string source, TraceEventType eventType, int id, string? formatOrMessage, object?[]? args, object? data1, object?[]? data); } public class StackFrame { public virtual MethodBase GetMethod(); } public class Stopwatch { + public static TimeSpan GetElapsedTime(long startingTimestamp); + public static TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp); } public abstract class Switch { + public string DefaultValue { get; } - protected string Value { get; set; } + public string Value { get; set; } + public static event EventHandler<InitializingSwitchEventArgs>? Initializing; + public void Refresh(); } public sealed class Trace { + public static event EventHandler Refreshing; public static void TraceError(string format, params object?[]? args); public static void TraceInformation(string format, params object?[]? args); public static void TraceWarning(string format, params object?[]? args); } public abstract class TraceFilter { public abstract bool ShouldTrace(TraceEventCache? cache, string source, TraceEventType eventType, int id, string? formatOrMessage, object?[]? args, object? data1, object?[]? data); } public abstract class TraceListener : MarshalByRefObject, IDisposable { public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args); } public class TraceSource { + public SourceLevels DefaultLevel { get; } + public static event EventHandler<InitializingTraceSourceEventArgs>? Initializing; public void TraceEvent(TraceEventType eventType, int id, string? format, params object?[]? args); public void TraceInformation(string? format, params object?[]? args); } + public sealed class UnreachableException : Exception { + public UnreachableException(); + public UnreachableException(string message); + public UnreachableException(string message, Exception innerException); + } public class XmlWriterTraceListener : TextWriterTraceListener { public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args); } }","title":"System.Diagnostics"},{"location":"Microsoft.NETCore.App/7.0_System.Drawing/","text":"System.Drawing namespace System.Drawing { public class ColorConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class PointConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class RectangleConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class SizeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class SizeFConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Drawing"},{"location":"Microsoft.NETCore.App/7.0_System.Drawing/#systemdrawing","text":"namespace System.Drawing { public class ColorConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class PointConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class RectangleConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class SizeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class SizeFConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Drawing"},{"location":"Microsoft.NETCore.App/7.0_System.Formats.Asn1/","text":"System.Formats.Asn1 namespace System.Formats.Asn1 { public sealed class AsnWriter { + public AsnWriter(AsnEncodingRules ruleSet, int initialCapacity); } }","title":"System.Formats.Asn1"},{"location":"Microsoft.NETCore.App/7.0_System.Formats.Asn1/#systemformatsasn1","text":"namespace System.Formats.Asn1 { public sealed class AsnWriter { + public AsnWriter(AsnEncodingRules ruleSet, int initialCapacity); } }","title":"System.Formats.Asn1"},{"location":"Microsoft.NETCore.App/7.0_System.Formats.Tar/","text":"System.Formats.Tar +namespace System.Formats.Tar { + public sealed class GnuTarEntry : PosixTarEntry { + public GnuTarEntry(TarEntry other); + public GnuTarEntry(TarEntryType entryType, string entryName); + public DateTimeOffset AccessTime { get; set; } + public DateTimeOffset ChangeTime { get; set; } + } + public sealed class PaxGlobalExtendedAttributesTarEntry : PosixTarEntry { + public PaxGlobalExtendedAttributesTarEntry(IEnumerable<KeyValuePair<string, string>> globalExtendedAttributes); + public IReadOnlyDictionary<string, string> GlobalExtendedAttributes { get; } + } + public sealed class PaxTarEntry : PosixTarEntry { + public PaxTarEntry(TarEntry other); + public PaxTarEntry(TarEntryType entryType, string entryName); + public PaxTarEntry(TarEntryType entryType, string entryName, IEnumerable<KeyValuePair<string, string>> extendedAttributes); + public IReadOnlyDictionary<string, string> ExtendedAttributes { get; } + } + public abstract class PosixTarEntry : TarEntry { + public int DeviceMajor { get; set; } + public int DeviceMinor { get; set; } + public string GroupName { get; set; } + public string UserName { get; set; } + } + public abstract class TarEntry { + public int Checksum { get; } + public Stream? DataStream { get; set; } + public TarEntryType EntryType { get; } + public TarEntryFormat Format { get; } + public int Gid { get; set; } + public long Length { get; } + public string LinkName { get; set; } + public UnixFileMode Mode { get; set; } + public DateTimeOffset ModificationTime { get; set; } + public string Name { get; set; } + public int Uid { get; set; } + public void ExtractToFile(string destinationFileName, bool overwrite); + public Task ExtractToFileAsync(string destinationFileName, bool overwrite, CancellationToken cancellationToken = default(CancellationToken)); + public override string ToString(); + } + public enum TarEntryFormat { + Gnu = 4, + Pax = 3, + Unknown = 0, + Ustar = 2, + V7 = 1, + } + public enum TarEntryType : byte { + BlockDevice = (byte)52, + CharacterDevice = (byte)51, + ContiguousFile = (byte)55, + Directory = (byte)53, + DirectoryList = (byte)68, + ExtendedAttributes = (byte)120, + Fifo = (byte)54, + GlobalExtendedAttributes = (byte)103, + HardLink = (byte)49, + LongLink = (byte)75, + LongPath = (byte)76, + MultiVolume = (byte)77, + RegularFile = (byte)48, + RenamedOrSymlinked = (byte)78, + SparseFile = (byte)83, + SymbolicLink = (byte)50, + TapeVolume = (byte)86, + V7RegularFile = (byte)0, + } + public static class TarFile { + public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, bool includeBaseDirectory); + public static void CreateFromDirectory(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory); + public static Task CreateFromDirectoryAsync(string sourceDirectoryName, Stream destination, bool includeBaseDirectory, CancellationToken cancellationToken = default(CancellationToken)); + public static Task CreateFromDirectoryAsync(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory, CancellationToken cancellationToken = default(CancellationToken)); + public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles); + public static void ExtractToDirectory(string sourceFileName, string destinationDirectoryName, bool overwriteFiles); + public static Task ExtractToDirectoryAsync(Stream source, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken = default(CancellationToken)); + public static Task ExtractToDirectoryAsync(string sourceFileName, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class TarReader : IAsyncDisposable, IDisposable { + public TarReader(Stream archiveStream, bool leaveOpen = false); + public void Dispose(); + public ValueTask DisposeAsync(); + public TarEntry? GetNextEntry(bool copyData = false); + public ValueTask<TarEntry?> GetNextEntryAsync(bool copyData = false, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class TarWriter : IAsyncDisposable, IDisposable { + public TarWriter(Stream archiveStream); + public TarWriter(Stream archiveStream, bool leaveOpen = false); + public TarWriter(Stream archiveStream, TarEntryFormat format = TarEntryFormat.Pax, bool leaveOpen = false); + public TarEntryFormat Format { get; } + public void Dispose(); + public ValueTask DisposeAsync(); + public void WriteEntry(TarEntry entry); + public void WriteEntry(string fileName, string? entryName); + public Task WriteEntryAsync(TarEntry entry, CancellationToken cancellationToken = default(CancellationToken)); + public Task WriteEntryAsync(string fileName, string? entryName, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class UstarTarEntry : PosixTarEntry { + public UstarTarEntry(TarEntry other); + public UstarTarEntry(TarEntryType entryType, string entryName); + } + public sealed class V7TarEntry : TarEntry { + public V7TarEntry(TarEntry other); + public V7TarEntry(TarEntryType entryType, string entryName); + } +}","title":"System.Formats.Tar"},{"location":"Microsoft.NETCore.App/7.0_System.Formats.Tar/#systemformatstar","text":"+namespace System.Formats.Tar { + public sealed class GnuTarEntry : PosixTarEntry { + public GnuTarEntry(TarEntry other); + public GnuTarEntry(TarEntryType entryType, string entryName); + public DateTimeOffset AccessTime { get; set; } + public DateTimeOffset ChangeTime { get; set; } + } + public sealed class PaxGlobalExtendedAttributesTarEntry : PosixTarEntry { + public PaxGlobalExtendedAttributesTarEntry(IEnumerable<KeyValuePair<string, string>> globalExtendedAttributes); + public IReadOnlyDictionary<string, string> GlobalExtendedAttributes { get; } + } + public sealed class PaxTarEntry : PosixTarEntry { + public PaxTarEntry(TarEntry other); + public PaxTarEntry(TarEntryType entryType, string entryName); + public PaxTarEntry(TarEntryType entryType, string entryName, IEnumerable<KeyValuePair<string, string>> extendedAttributes); + public IReadOnlyDictionary<string, string> ExtendedAttributes { get; } + } + public abstract class PosixTarEntry : TarEntry { + public int DeviceMajor { get; set; } + public int DeviceMinor { get; set; } + public string GroupName { get; set; } + public string UserName { get; set; } + } + public abstract class TarEntry { + public int Checksum { get; } + public Stream? DataStream { get; set; } + public TarEntryType EntryType { get; } + public TarEntryFormat Format { get; } + public int Gid { get; set; } + public long Length { get; } + public string LinkName { get; set; } + public UnixFileMode Mode { get; set; } + public DateTimeOffset ModificationTime { get; set; } + public string Name { get; set; } + public int Uid { get; set; } + public void ExtractToFile(string destinationFileName, bool overwrite); + public Task ExtractToFileAsync(string destinationFileName, bool overwrite, CancellationToken cancellationToken = default(CancellationToken)); + public override string ToString(); + } + public enum TarEntryFormat { + Gnu = 4, + Pax = 3, + Unknown = 0, + Ustar = 2, + V7 = 1, + } + public enum TarEntryType : byte { + BlockDevice = (byte)52, + CharacterDevice = (byte)51, + ContiguousFile = (byte)55, + Directory = (byte)53, + DirectoryList = (byte)68, + ExtendedAttributes = (byte)120, + Fifo = (byte)54, + GlobalExtendedAttributes = (byte)103, + HardLink = (byte)49, + LongLink = (byte)75, + LongPath = (byte)76, + MultiVolume = (byte)77, + RegularFile = (byte)48, + RenamedOrSymlinked = (byte)78, + SparseFile = (byte)83, + SymbolicLink = (byte)50, + TapeVolume = (byte)86, + V7RegularFile = (byte)0, + } + public static class TarFile { + public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, bool includeBaseDirectory); + public static void CreateFromDirectory(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory); + public static Task CreateFromDirectoryAsync(string sourceDirectoryName, Stream destination, bool includeBaseDirectory, CancellationToken cancellationToken = default(CancellationToken)); + public static Task CreateFromDirectoryAsync(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory, CancellationToken cancellationToken = default(CancellationToken)); + public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles); + public static void ExtractToDirectory(string sourceFileName, string destinationDirectoryName, bool overwriteFiles); + public static Task ExtractToDirectoryAsync(Stream source, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken = default(CancellationToken)); + public static Task ExtractToDirectoryAsync(string sourceFileName, string destinationDirectoryName, bool overwriteFiles, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class TarReader : IAsyncDisposable, IDisposable { + public TarReader(Stream archiveStream, bool leaveOpen = false); + public void Dispose(); + public ValueTask DisposeAsync(); + public TarEntry? GetNextEntry(bool copyData = false); + public ValueTask<TarEntry?> GetNextEntryAsync(bool copyData = false, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class TarWriter : IAsyncDisposable, IDisposable { + public TarWriter(Stream archiveStream); + public TarWriter(Stream archiveStream, bool leaveOpen = false); + public TarWriter(Stream archiveStream, TarEntryFormat format = TarEntryFormat.Pax, bool leaveOpen = false); + public TarEntryFormat Format { get; } + public void Dispose(); + public ValueTask DisposeAsync(); + public void WriteEntry(TarEntry entry); + public void WriteEntry(string fileName, string? entryName); + public Task WriteEntryAsync(TarEntry entry, CancellationToken cancellationToken = default(CancellationToken)); + public Task WriteEntryAsync(string fileName, string? entryName, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class UstarTarEntry : PosixTarEntry { + public UstarTarEntry(TarEntry other); + public UstarTarEntry(TarEntryType entryType, string entryName); + } + public sealed class V7TarEntry : TarEntry { + public V7TarEntry(TarEntry other); + public V7TarEntry(TarEntryType entryType, string entryName); + } +}","title":"System.Formats.Tar"},{"location":"Microsoft.NETCore.App/7.0_System.IO.Compression/","text":"System.IO.Compression namespace System.IO.Compression { public class DeflateStream : Stream { + public override void WriteByte(byte value); } public class GZipStream : Stream { + public override void WriteByte(byte value); } public class ZipArchive : IDisposable { + public string Comment { get; set; } } public class ZipArchiveEntry { + public string Comment { get; set; } + public bool IsEncrypted { get; } } }","title":"System.IO.Compression"},{"location":"Microsoft.NETCore.App/7.0_System.IO.Compression/#systemiocompression","text":"namespace System.IO.Compression { public class DeflateStream : Stream { + public override void WriteByte(byte value); } public class GZipStream : Stream { + public override void WriteByte(byte value); } public class ZipArchive : IDisposable { + public string Comment { get; set; } } public class ZipArchiveEntry { + public string Comment { get; set; } + public bool IsEncrypted { get; } } }","title":"System.IO.Compression"},{"location":"Microsoft.NETCore.App/7.0_System.IO.Pipes/","text":"System.IO.Pipes namespace System.IO.Pipes { public sealed class NamedPipeClientStream : PipeStream { + public void Connect(TimeSpan timeout); + public Task ConnectAsync(TimeSpan timeout, CancellationToken cancellationToken); } }","title":"System.IO.Pipes"},{"location":"Microsoft.NETCore.App/7.0_System.IO.Pipes/#systemiopipes","text":"namespace System.IO.Pipes { public sealed class NamedPipeClientStream : PipeStream { + public void Connect(TimeSpan timeout); + public Task ConnectAsync(TimeSpan timeout, CancellationToken cancellationToken); } }","title":"System.IO.Pipes"},{"location":"Microsoft.NETCore.App/7.0_System.IO/","text":"System.IO namespace System.IO { public static class Directory { + public static DirectoryInfo CreateDirectory(string path, UnixFileMode unixCreateMode); + public static DirectoryInfo CreateTempSubdirectory(string? prefix = null); } public static class File { + public static FileAttributes GetAttributes(SafeFileHandle fileHandle); + public static DateTime GetCreationTime(SafeFileHandle fileHandle); + public static DateTime GetCreationTimeUtc(SafeFileHandle fileHandle); + public static DateTime GetLastAccessTime(SafeFileHandle fileHandle); + public static DateTime GetLastAccessTimeUtc(SafeFileHandle fileHandle); + public static DateTime GetLastWriteTime(SafeFileHandle fileHandle); + public static DateTime GetLastWriteTimeUtc(SafeFileHandle fileHandle); + public static UnixFileMode GetUnixFileMode(SafeFileHandle fileHandle); + public static UnixFileMode GetUnixFileMode(string path); + public static IAsyncEnumerable<string> ReadLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken = default(CancellationToken)); + public static IAsyncEnumerable<string> ReadLinesAsync(string path, CancellationToken cancellationToken = default(CancellationToken)); + public static void SetAttributes(SafeFileHandle fileHandle, FileAttributes fileAttributes); + public static void SetCreationTime(SafeFileHandle fileHandle, DateTime creationTime); + public static void SetCreationTimeUtc(SafeFileHandle fileHandle, DateTime creationTimeUtc); + public static void SetLastAccessTime(SafeFileHandle fileHandle, DateTime lastAccessTime); + public static void SetLastAccessTimeUtc(SafeFileHandle fileHandle, DateTime lastAccessTimeUtc); + public static void SetLastWriteTime(SafeFileHandle fileHandle, DateTime lastWriteTime); + public static void SetLastWriteTimeUtc(SafeFileHandle fileHandle, DateTime lastWriteTimeUtc); + public static void SetUnixFileMode(SafeFileHandle fileHandle, UnixFileMode mode); + public static void SetUnixFileMode(string path, UnixFileMode mode); } public sealed class FileInfo : FileSystemInfo { - public override string ToString(); } public class FileStream : Stream { public virtual void Lock(long position, long length); public virtual void Unlock(long position, long length); } public sealed class FileStreamOptions { public FileAccess Access { get; set; } public int BufferSize { get; set; } public FileMode Mode { get; set; } public FileOptions Options { get; set; } public long PreallocationSize { get; set; } public FileShare Share { get; set; } + public UnixFileMode? UnixCreateMode { get; set; } } public static class FileSystemAclExtensions { - public static FileStream Create(this FileInfo fileInfo, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity fileSecurity); + public static FileStream Create(this FileInfo fileInfo, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity? fileSecurity); } public abstract class FileSystemInfo : MarshalByRefObject, ISerializable { + public UnixFileMode UnixFileMode { get; set; } } public class FileSystemWatcher : Component, ISupportInitialize { + public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, TimeSpan timeout); } public static class Path { + public static bool Exists(string? path); } public static class RandomAccess { + public static void SetLength(SafeFileHandle handle, long length); } public abstract class Stream : MarshalByRefObject, IAsyncDisposable, IDisposable { protected virtual WaitHandle CreateWaitHandle(); + public int ReadAtLeast(Span<byte> buffer, int minimumBytes, bool throwOnEndOfStream = true); + public ValueTask<int> ReadAtLeastAsync(Memory<byte> buffer, int minimumBytes, bool throwOnEndOfStream = true, CancellationToken cancellationToken = default(CancellationToken)); + public void ReadExactly(byte[] buffer, int offset, int count); + public void ReadExactly(Span<byte> buffer); + public ValueTask ReadExactlyAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask ReadExactlyAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); } public class StreamReader : TextReader { + public override ValueTask<string?> ReadLineAsync(CancellationToken cancellationToken); + public override Task<string> ReadToEndAsync(CancellationToken cancellationToken); } public class StreamWriter : TextWriter { public override void Write(string format, object? arg0); public override void Write(string format, object? arg0, object? arg1); public override void Write(string format, object? arg0, object? arg1, object? arg2); public override void Write(string format, params object?[] arg); public override void WriteLine(string format, object? arg0); public override void WriteLine(string format, object? arg0, object? arg1); public override void WriteLine(string format, object? arg0, object? arg1, object? arg2); public override void WriteLine(string format, params object?[] arg); } public class StringReader : TextReader { + public override ValueTask<string?> ReadLineAsync(CancellationToken cancellationToken); + public override Task<string> ReadToEndAsync(CancellationToken cancellationToken); } public abstract class TextReader : MarshalByRefObject, IDisposable { + public virtual ValueTask<string?> ReadLineAsync(CancellationToken cancellationToken); + public virtual Task<string> ReadToEndAsync(CancellationToken cancellationToken); } public abstract class TextWriter : MarshalByRefObject, IAsyncDisposable, IDisposable { public virtual void Write(string format, object? arg0); public virtual void Write(string format, object? arg0, object? arg1); public virtual void Write(string format, object? arg0, object? arg1, object? arg2); public virtual void Write(string format, params object?[] arg); public virtual void WriteLine(string format, object? arg0); public virtual void WriteLine(string format, object? arg0, object? arg1); public virtual void WriteLine(string format, object? arg0, object? arg1, object? arg2); public virtual void WriteLine(string format, params object?[] arg); } + public enum UnixFileMode { + GroupExecute = 8, + GroupRead = 32, + GroupWrite = 16, + None = 0, + OtherExecute = 1, + OtherRead = 4, + OtherWrite = 2, + SetGroup = 1024, + SetUser = 2048, + StickyBit = 512, + UserExecute = 64, + UserRead = 256, + UserWrite = 128, + } }","title":"System.IO"},{"location":"Microsoft.NETCore.App/7.0_System.IO/#systemio","text":"namespace System.IO { public static class Directory { + public static DirectoryInfo CreateDirectory(string path, UnixFileMode unixCreateMode); + public static DirectoryInfo CreateTempSubdirectory(string? prefix = null); } public static class File { + public static FileAttributes GetAttributes(SafeFileHandle fileHandle); + public static DateTime GetCreationTime(SafeFileHandle fileHandle); + public static DateTime GetCreationTimeUtc(SafeFileHandle fileHandle); + public static DateTime GetLastAccessTime(SafeFileHandle fileHandle); + public static DateTime GetLastAccessTimeUtc(SafeFileHandle fileHandle); + public static DateTime GetLastWriteTime(SafeFileHandle fileHandle); + public static DateTime GetLastWriteTimeUtc(SafeFileHandle fileHandle); + public static UnixFileMode GetUnixFileMode(SafeFileHandle fileHandle); + public static UnixFileMode GetUnixFileMode(string path); + public static IAsyncEnumerable<string> ReadLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken = default(CancellationToken)); + public static IAsyncEnumerable<string> ReadLinesAsync(string path, CancellationToken cancellationToken = default(CancellationToken)); + public static void SetAttributes(SafeFileHandle fileHandle, FileAttributes fileAttributes); + public static void SetCreationTime(SafeFileHandle fileHandle, DateTime creationTime); + public static void SetCreationTimeUtc(SafeFileHandle fileHandle, DateTime creationTimeUtc); + public static void SetLastAccessTime(SafeFileHandle fileHandle, DateTime lastAccessTime); + public static void SetLastAccessTimeUtc(SafeFileHandle fileHandle, DateTime lastAccessTimeUtc); + public static void SetLastWriteTime(SafeFileHandle fileHandle, DateTime lastWriteTime); + public static void SetLastWriteTimeUtc(SafeFileHandle fileHandle, DateTime lastWriteTimeUtc); + public static void SetUnixFileMode(SafeFileHandle fileHandle, UnixFileMode mode); + public static void SetUnixFileMode(string path, UnixFileMode mode); } public sealed class FileInfo : FileSystemInfo { - public override string ToString(); } public class FileStream : Stream { public virtual void Lock(long position, long length); public virtual void Unlock(long position, long length); } public sealed class FileStreamOptions { public FileAccess Access { get; set; } public int BufferSize { get; set; } public FileMode Mode { get; set; } public FileOptions Options { get; set; } public long PreallocationSize { get; set; } public FileShare Share { get; set; } + public UnixFileMode? UnixCreateMode { get; set; } } public static class FileSystemAclExtensions { - public static FileStream Create(this FileInfo fileInfo, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity fileSecurity); + public static FileStream Create(this FileInfo fileInfo, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity? fileSecurity); } public abstract class FileSystemInfo : MarshalByRefObject, ISerializable { + public UnixFileMode UnixFileMode { get; set; } } public class FileSystemWatcher : Component, ISupportInitialize { + public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, TimeSpan timeout); } public static class Path { + public static bool Exists(string? path); } public static class RandomAccess { + public static void SetLength(SafeFileHandle handle, long length); } public abstract class Stream : MarshalByRefObject, IAsyncDisposable, IDisposable { protected virtual WaitHandle CreateWaitHandle(); + public int ReadAtLeast(Span<byte> buffer, int minimumBytes, bool throwOnEndOfStream = true); + public ValueTask<int> ReadAtLeastAsync(Memory<byte> buffer, int minimumBytes, bool throwOnEndOfStream = true, CancellationToken cancellationToken = default(CancellationToken)); + public void ReadExactly(byte[] buffer, int offset, int count); + public void ReadExactly(Span<byte> buffer); + public ValueTask ReadExactlyAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask ReadExactlyAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); } public class StreamReader : TextReader { + public override ValueTask<string?> ReadLineAsync(CancellationToken cancellationToken); + public override Task<string> ReadToEndAsync(CancellationToken cancellationToken); } public class StreamWriter : TextWriter { public override void Write(string format, object? arg0); public override void Write(string format, object? arg0, object? arg1); public override void Write(string format, object? arg0, object? arg1, object? arg2); public override void Write(string format, params object?[] arg); public override void WriteLine(string format, object? arg0); public override void WriteLine(string format, object? arg0, object? arg1); public override void WriteLine(string format, object? arg0, object? arg1, object? arg2); public override void WriteLine(string format, params object?[] arg); } public class StringReader : TextReader { + public override ValueTask<string?> ReadLineAsync(CancellationToken cancellationToken); + public override Task<string> ReadToEndAsync(CancellationToken cancellationToken); } public abstract class TextReader : MarshalByRefObject, IDisposable { + public virtual ValueTask<string?> ReadLineAsync(CancellationToken cancellationToken); + public virtual Task<string> ReadToEndAsync(CancellationToken cancellationToken); } public abstract class TextWriter : MarshalByRefObject, IAsyncDisposable, IDisposable { public virtual void Write(string format, object? arg0); public virtual void Write(string format, object? arg0, object? arg1); public virtual void Write(string format, object? arg0, object? arg1, object? arg2); public virtual void Write(string format, params object?[] arg); public virtual void WriteLine(string format, object? arg0); public virtual void WriteLine(string format, object? arg0, object? arg1); public virtual void WriteLine(string format, object? arg0, object? arg1, object? arg2); public virtual void WriteLine(string format, params object?[] arg); } + public enum UnixFileMode { + GroupExecute = 8, + GroupRead = 32, + GroupWrite = 16, + None = 0, + OtherExecute = 1, + OtherRead = 4, + OtherWrite = 2, + SetGroup = 1024, + SetUser = 2048, + StickyBit = 512, + UserExecute = 64, + UserRead = 256, + UserWrite = 128, + } }","title":"System.IO"},{"location":"Microsoft.NETCore.App/7.0_System.Linq/","text":"System.Linq namespace System.Linq { public static class Enumerable { + public static IOrderedEnumerable<T> Order<T>(this IEnumerable<T> source); + public static IOrderedEnumerable<T> Order<T>(this IEnumerable<T> source, IComparer<T>? comparer); + public static IOrderedEnumerable<T> OrderDescending<T>(this IEnumerable<T> source); + public static IOrderedEnumerable<T> OrderDescending<T>(this IEnumerable<T> source, IComparer<T>? comparer); } public class EnumerableQuery<T> : EnumerableQuery, IEnumerable, IEnumerable<T>, IOrderedQueryable, IOrderedQueryable<T>, IQueryable, IQueryable<T>, IQueryProvider { public EnumerableQuery(IEnumerable<T> enumerable); public EnumerableQuery(Expression expression); } public static class Queryable { public static TResult Aggregate<TSource, TAccumulate, TResult>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func, Expression<Func<TAccumulate, TResult>> selector); public static TAccumulate Aggregate<TSource, TAccumulate>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func); public static TSource Aggregate<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, TSource, TSource>> func); public static bool All<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static bool Any<TSource>(this IQueryable<TSource> source); public static bool Any<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> Append<TSource>(this IQueryable<TSource> source, TSource element); public static IQueryable AsQueryable(this IEnumerable source); public static IQueryable<TElement> AsQueryable<TElement>(this IEnumerable<TElement> source); public static decimal Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector); public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector); public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector); public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector); public static decimal? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector); public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector); public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector); public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector); public static float? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector); public static float Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector); public static IQueryable<TResult> Cast<TResult>(this IQueryable source); public static IQueryable<TSource[]> Chunk<TSource>(this IQueryable<TSource> source, int size); public static IQueryable<TSource> Concat<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item); public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item, IEqualityComparer<TSource>? comparer); public static int Count<TSource>(this IQueryable<TSource> source); public static int Count<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); - public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source); + public static IQueryable<TSource?> DefaultIfEmpty<TSource>(this IQueryable<TSource> source); public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source); public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> DistinctBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> DistinctBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static TSource ElementAt<TSource>(this IQueryable<TSource> source, Index index); public static TSource ElementAt<TSource>(this IQueryable<TSource> source, int index); public static TSource? ElementAtOrDefault<TSource>(this IQueryable<TSource> source, Index index); public static TSource? ElementAtOrDefault<TSource>(this IQueryable<TSource> source, int index); public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> ExceptBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> ExceptBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static TSource First<TSource>(this IQueryable<TSource> source); public static TSource First<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource? FirstOrDefault<TSource>(this IQueryable<TSource> source); public static TSource? FirstOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, TSource defaultValue); public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector); public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector); public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector); public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector); public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> IntersectBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> IntersectBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector); public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static TSource Last<TSource>(this IQueryable<TSource> source); public static TSource Last<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource? LastOrDefault<TSource>(this IQueryable<TSource> source); public static TSource? LastOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, TSource defaultValue); public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static long LongCount<TSource>(this IQueryable<TSource> source); public static long LongCount<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TResult? Max<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector); public static TSource? Max<TSource>(this IQueryable<TSource> source); public static TSource? Max<TSource>(this IQueryable<TSource> source, IComparer<TSource>? comparer); public static TSource? MaxBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static TSource? MaxBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TSource>? comparer); public static TResult? Min<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector); public static TSource? Min<TSource>(this IQueryable<TSource> source); public static TSource? Min<TSource>(this IQueryable<TSource> source, IComparer<TSource>? comparer); public static TSource? MinBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static TSource? MinBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TSource>? comparer); public static IQueryable<TResult> OfType<TResult>(this IQueryable source); + public static IOrderedQueryable<T> Order<T>(this IQueryable<T> source); + public static IOrderedQueryable<T> Order<T>(this IQueryable<T> source, IComparer<T> comparer); public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); + public static IOrderedQueryable<T> OrderDescending<T>(this IQueryable<T> source); + public static IOrderedQueryable<T> OrderDescending<T>(this IQueryable<T> source, IComparer<T> comparer); public static IQueryable<TSource> Prepend<TSource>(this IQueryable<TSource> source, TSource element); public static IQueryable<TSource> Reverse<TSource>(this IQueryable<TSource> source); public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, TResult>> selector); public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector); public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector); public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector); public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector); public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TResult>>> selector); public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static TSource Single<TSource>(this IQueryable<TSource> source); public static TSource Single<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource? SingleOrDefault<TSource>(this IQueryable<TSource> source); public static TSource? SingleOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, TSource defaultValue); public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static IQueryable<TSource> Skip<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> SkipLast<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate); public static decimal Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector); public static double Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector); public static int Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector); public static long Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector); public static decimal? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector); public static double? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector); public static int? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector); public static long? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector); public static float? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector); public static float Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector); public static IQueryable<TSource> Take<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> Take<TSource>(this IQueryable<TSource> source, Range range); public static IQueryable<TSource> TakeLast<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate); public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> UnionBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> UnionBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate); public static IQueryable<TResult> Zip<TFirst, TSecond, TResult>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2, Expression<Func<TFirst, TSecond, TResult>> resultSelector); public static IQueryable<(TFirst First, TSecond Second, TThird Third)> Zip<TFirst, TSecond, TThird>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2, IEnumerable<TThird> source3); public static IQueryable<(TFirst First, TSecond Second)> Zip<TFirst, TSecond>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2); } }","title":"System.Linq"},{"location":"Microsoft.NETCore.App/7.0_System.Linq/#systemlinq","text":"namespace System.Linq { public static class Enumerable { + public static IOrderedEnumerable<T> Order<T>(this IEnumerable<T> source); + public static IOrderedEnumerable<T> Order<T>(this IEnumerable<T> source, IComparer<T>? comparer); + public static IOrderedEnumerable<T> OrderDescending<T>(this IEnumerable<T> source); + public static IOrderedEnumerable<T> OrderDescending<T>(this IEnumerable<T> source, IComparer<T>? comparer); } public class EnumerableQuery<T> : EnumerableQuery, IEnumerable, IEnumerable<T>, IOrderedQueryable, IOrderedQueryable<T>, IQueryable, IQueryable<T>, IQueryProvider { public EnumerableQuery(IEnumerable<T> enumerable); public EnumerableQuery(Expression expression); } public static class Queryable { public static TResult Aggregate<TSource, TAccumulate, TResult>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func, Expression<Func<TAccumulate, TResult>> selector); public static TAccumulate Aggregate<TSource, TAccumulate>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func); public static TSource Aggregate<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, TSource, TSource>> func); public static bool All<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static bool Any<TSource>(this IQueryable<TSource> source); public static bool Any<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> Append<TSource>(this IQueryable<TSource> source, TSource element); public static IQueryable AsQueryable(this IEnumerable source); public static IQueryable<TElement> AsQueryable<TElement>(this IEnumerable<TElement> source); public static decimal Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector); public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector); public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector); public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector); public static decimal? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector); public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector); public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector); public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector); public static float? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector); public static float Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector); public static IQueryable<TResult> Cast<TResult>(this IQueryable source); public static IQueryable<TSource[]> Chunk<TSource>(this IQueryable<TSource> source, int size); public static IQueryable<TSource> Concat<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item); public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item, IEqualityComparer<TSource>? comparer); public static int Count<TSource>(this IQueryable<TSource> source); public static int Count<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); - public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source); + public static IQueryable<TSource?> DefaultIfEmpty<TSource>(this IQueryable<TSource> source); public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source); public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> DistinctBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> DistinctBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static TSource ElementAt<TSource>(this IQueryable<TSource> source, Index index); public static TSource ElementAt<TSource>(this IQueryable<TSource> source, int index); public static TSource? ElementAtOrDefault<TSource>(this IQueryable<TSource> source, Index index); public static TSource? ElementAtOrDefault<TSource>(this IQueryable<TSource> source, int index); public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> ExceptBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> ExceptBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static TSource First<TSource>(this IQueryable<TSource> source); public static TSource First<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource? FirstOrDefault<TSource>(this IQueryable<TSource> source); public static TSource? FirstOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, TSource defaultValue); public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector); public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector); public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector); public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector); public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> IntersectBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> IntersectBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TKey> source2, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector); public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector, IEqualityComparer<TKey>? comparer); public static TSource Last<TSource>(this IQueryable<TSource> source); public static TSource Last<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource? LastOrDefault<TSource>(this IQueryable<TSource> source); public static TSource? LastOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, TSource defaultValue); public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static long LongCount<TSource>(this IQueryable<TSource> source); public static long LongCount<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TResult? Max<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector); public static TSource? Max<TSource>(this IQueryable<TSource> source); public static TSource? Max<TSource>(this IQueryable<TSource> source, IComparer<TSource>? comparer); public static TSource? MaxBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static TSource? MaxBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TSource>? comparer); public static TResult? Min<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector); public static TSource? Min<TSource>(this IQueryable<TSource> source); public static TSource? Min<TSource>(this IQueryable<TSource> source, IComparer<TSource>? comparer); public static TSource? MinBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static TSource? MinBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TSource>? comparer); public static IQueryable<TResult> OfType<TResult>(this IQueryable source); + public static IOrderedQueryable<T> Order<T>(this IQueryable<T> source); + public static IOrderedQueryable<T> Order<T>(this IQueryable<T> source, IComparer<T> comparer); public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); + public static IOrderedQueryable<T> OrderDescending<T>(this IQueryable<T> source); + public static IOrderedQueryable<T> OrderDescending<T>(this IQueryable<T> source, IComparer<T> comparer); public static IQueryable<TSource> Prepend<TSource>(this IQueryable<TSource> source, TSource element); public static IQueryable<TSource> Reverse<TSource>(this IQueryable<TSource> source); public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, TResult>> selector); public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector); public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector); public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector); public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector); public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TResult>>> selector); public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static TSource Single<TSource>(this IQueryable<TSource> source); public static TSource Single<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource? SingleOrDefault<TSource>(this IQueryable<TSource> source); public static TSource? SingleOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate, TSource defaultValue); public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source, TSource defaultValue); public static IQueryable<TSource> Skip<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> SkipLast<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate); public static decimal Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector); public static double Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector); public static int Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector); public static long Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector); public static decimal? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector); public static double? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector); public static int? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector); public static long? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector); public static float? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector); public static float Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector); public static IQueryable<TSource> Take<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> Take<TSource>(this IQueryable<TSource> source, Range range); public static IQueryable<TSource> TakeLast<TSource>(this IQueryable<TSource> source, int count); public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate); public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector); public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey>? comparer); public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2); public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource>? comparer); public static IQueryable<TSource> UnionBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, Expression<Func<TSource, TKey>> keySelector); public static IQueryable<TSource> UnionBy<TSource, TKey>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey>? comparer); public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate); public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate); public static IQueryable<TResult> Zip<TFirst, TSecond, TResult>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2, Expression<Func<TFirst, TSecond, TResult>> resultSelector); public static IQueryable<(TFirst First, TSecond Second, TThird Third)> Zip<TFirst, TSecond, TThird>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2, IEnumerable<TThird> source3); public static IQueryable<(TFirst First, TSecond Second)> Zip<TFirst, TSecond>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2); } }","title":"System.Linq"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Http.Headers/","text":"System.Net.Http.Headers namespace System.Net.Http.Headers { public sealed class HttpRequestHeaders : HttpHeaders { + public string? Protocol { get; set; } } public class MediaTypeHeaderValue : ICloneable { + public MediaTypeHeaderValue(string mediaType, string? charSet); } }","title":"System.Net.Http.Headers"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Http.Headers/#systemnethttpheaders","text":"namespace System.Net.Http.Headers { public sealed class HttpRequestHeaders : HttpHeaders { + public string? Protocol { get; set; } } public class MediaTypeHeaderValue : ICloneable { + public MediaTypeHeaderValue(string mediaType, string? charSet); } }","title":"System.Net.Http.Headers"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Http.Json/","text":"System.Net.Http.Json namespace System.Net.Http.Json { public static class HttpClientJsonExtensions { + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, string? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, string? requestUri, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, string? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, string? requestUri, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, CancellationToken cancellationToken); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, CancellationToken cancellationToken); } public static class HttpContentJsonExtensions { public static Task<object?> ReadFromJsonAsync(this HttpContent content, Type type, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<T?> ReadFromJsonAsync<T>(this HttpContent content, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); } public sealed class JsonContent : HttpContent { public static JsonContent Create(object? inputValue, Type inputType, MediaTypeHeaderValue? mediaType = null, JsonSerializerOptions? options = null); public static JsonContent Create<T>(T inputValue, MediaTypeHeaderValue? mediaType = null, JsonSerializerOptions? options = null); } }","title":"System.Net.Http.Json"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Http.Json/#systemnethttpjson","text":"namespace System.Net.Http.Json { public static class HttpClientJsonExtensions { + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, string? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<object?> DeleteFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, string? requestUri, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<TValue?> DeleteFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, string? requestUri, Type type, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, string? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<object?> GetFromJsonAsync(this HttpClient client, Uri? requestUri, Type type, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, string? requestUri, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, string? requestUri, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, JsonSerializerOptions? options, CancellationToken cancellationToken = default(CancellationToken)); public static Task<TValue?> GetFromJsonAsync<TValue>(this HttpClient client, Uri? requestUri, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, CancellationToken cancellationToken); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); + public static Task<HttpResponseMessage> PatchAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PostAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, string? requestUri, TValue value, CancellationToken cancellationToken); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<HttpResponseMessage> PutAsJsonAsync<TValue>(this HttpClient client, Uri? requestUri, TValue value, CancellationToken cancellationToken); } public static class HttpContentJsonExtensions { public static Task<object?> ReadFromJsonAsync(this HttpContent content, Type type, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task<T?> ReadFromJsonAsync<T>(this HttpContent content, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); } public sealed class JsonContent : HttpContent { public static JsonContent Create(object? inputValue, Type inputType, MediaTypeHeaderValue? mediaType = null, JsonSerializerOptions? options = null); public static JsonContent Create<T>(T inputValue, MediaTypeHeaderValue? mediaType = null, JsonSerializerOptions? options = null); } }","title":"System.Net.Http.Json"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Http/","text":"System.Net.Http namespace System.Net.Http { public class HttpClient : HttpMessageInvoker { public Task<HttpResponseMessage> DeleteAsync(string? requestUri); public Task<HttpResponseMessage> DeleteAsync(string? requestUri, CancellationToken cancellationToken); public Task<HttpResponseMessage> GetAsync(string? requestUri); public Task<HttpResponseMessage> GetAsync(string? requestUri, HttpCompletionOption completionOption); public Task<HttpResponseMessage> GetAsync(string? requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken); public Task<HttpResponseMessage> GetAsync(string? requestUri, CancellationToken cancellationToken); public Task<byte[]> GetByteArrayAsync(string? requestUri); public Task<byte[]> GetByteArrayAsync(string? requestUri, CancellationToken cancellationToken); public Task<Stream> GetStreamAsync(string? requestUri); public Task<Stream> GetStreamAsync(string? requestUri, CancellationToken cancellationToken); public Task<string> GetStringAsync(string? requestUri); public Task<string> GetStringAsync(string? requestUri, CancellationToken cancellationToken); public Task<HttpResponseMessage> PatchAsync(string? requestUri, HttpContent? content); public Task<HttpResponseMessage> PatchAsync(string? requestUri, HttpContent? content, CancellationToken cancellationToken); public Task<HttpResponseMessage> PostAsync(string? requestUri, HttpContent? content); public Task<HttpResponseMessage> PostAsync(string? requestUri, HttpContent? content, CancellationToken cancellationToken); public Task<HttpResponseMessage> PutAsync(string? requestUri, HttpContent? content); public Task<HttpResponseMessage> PutAsync(string? requestUri, HttpContent? content, CancellationToken cancellationToken); } public class HttpClientHandler : HttpMessageHandler { public IWebProxy Proxy { get; set; } } public class HttpMethod : IEquatable<HttpMethod> { + public static HttpMethod Connect { get; } } + public sealed class HttpProtocolException : IOException { + public HttpProtocolException(long errorCode, string? message, Exception? innerException); + public long ErrorCode { get; } + } public class HttpRequestMessage : IDisposable { public HttpRequestMessage(HttpMethod method, string? requestUri); } public class StringContent : ByteArrayContent { + public StringContent(string content, MediaTypeHeaderValue mediaType); + public StringContent(string content, Encoding? encoding, MediaTypeHeaderValue mediaType); - public StringContent(string content, Encoding? encoding, string? mediaType); + public StringContent(string content, Encoding? encoding, string mediaType); } }","title":"System.Net.Http"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Http/#systemnethttp","text":"namespace System.Net.Http { public class HttpClient : HttpMessageInvoker { public Task<HttpResponseMessage> DeleteAsync(string? requestUri); public Task<HttpResponseMessage> DeleteAsync(string? requestUri, CancellationToken cancellationToken); public Task<HttpResponseMessage> GetAsync(string? requestUri); public Task<HttpResponseMessage> GetAsync(string? requestUri, HttpCompletionOption completionOption); public Task<HttpResponseMessage> GetAsync(string? requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken); public Task<HttpResponseMessage> GetAsync(string? requestUri, CancellationToken cancellationToken); public Task<byte[]> GetByteArrayAsync(string? requestUri); public Task<byte[]> GetByteArrayAsync(string? requestUri, CancellationToken cancellationToken); public Task<Stream> GetStreamAsync(string? requestUri); public Task<Stream> GetStreamAsync(string? requestUri, CancellationToken cancellationToken); public Task<string> GetStringAsync(string? requestUri); public Task<string> GetStringAsync(string? requestUri, CancellationToken cancellationToken); public Task<HttpResponseMessage> PatchAsync(string? requestUri, HttpContent? content); public Task<HttpResponseMessage> PatchAsync(string? requestUri, HttpContent? content, CancellationToken cancellationToken); public Task<HttpResponseMessage> PostAsync(string? requestUri, HttpContent? content); public Task<HttpResponseMessage> PostAsync(string? requestUri, HttpContent? content, CancellationToken cancellationToken); public Task<HttpResponseMessage> PutAsync(string? requestUri, HttpContent? content); public Task<HttpResponseMessage> PutAsync(string? requestUri, HttpContent? content, CancellationToken cancellationToken); } public class HttpClientHandler : HttpMessageHandler { public IWebProxy Proxy { get; set; } } public class HttpMethod : IEquatable<HttpMethod> { + public static HttpMethod Connect { get; } } + public sealed class HttpProtocolException : IOException { + public HttpProtocolException(long errorCode, string? message, Exception? innerException); + public long ErrorCode { get; } + } public class HttpRequestMessage : IDisposable { public HttpRequestMessage(HttpMethod method, string? requestUri); } public class StringContent : ByteArrayContent { + public StringContent(string content, MediaTypeHeaderValue mediaType); + public StringContent(string content, Encoding? encoding, MediaTypeHeaderValue mediaType); - public StringContent(string content, Encoding? encoding, string? mediaType); + public StringContent(string content, Encoding? encoding, string mediaType); } }","title":"System.Net.Http"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Mail/","text":"System.Net.Mail namespace System.Net.Mail { public class MailAddress { - public static bool TryCreate(string address, out MailAddress? result); + public static bool TryCreate(string? address, out MailAddress? result); - public static bool TryCreate(string address, string? displayName, out MailAddress? result); + public static bool TryCreate(string? address, string? displayName, out MailAddress? result); - public static bool TryCreate(string address, string? displayName, Encoding? displayNameEncoding, out MailAddress? result); + public static bool TryCreate(string? address, string? displayName, Encoding? displayNameEncoding, out MailAddress? result); } }","title":"System.Net.Mail"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Mail/#systemnetmail","text":"namespace System.Net.Mail { public class MailAddress { - public static bool TryCreate(string address, out MailAddress? result); + public static bool TryCreate(string? address, out MailAddress? result); - public static bool TryCreate(string address, string? displayName, out MailAddress? result); + public static bool TryCreate(string? address, string? displayName, out MailAddress? result); - public static bool TryCreate(string address, string? displayName, Encoding? displayNameEncoding, out MailAddress? result); + public static bool TryCreate(string? address, string? displayName, Encoding? displayNameEncoding, out MailAddress? result); } }","title":"System.Net.Mail"},{"location":"Microsoft.NETCore.App/7.0_System.Net.NetworkInformation/","text":"System.Net.NetworkInformation namespace System.Net.NetworkInformation { public abstract class IcmpV4Statistics { public abstract long ErrorsReceived { get; } public abstract long ErrorsSent { get; } public abstract long MessagesReceived { get; } public abstract long MessagesSent { get; } } public abstract class IcmpV6Statistics { public abstract long ErrorsReceived { get; } public abstract long ErrorsSent { get; } public abstract long MessagesReceived { get; } public abstract long MessagesSent { get; } } public abstract class IPAddressInformation { public abstract bool IsDnsEligible { get; } public abstract bool IsTransient { get; } } public abstract class IPGlobalProperties { public abstract IPGlobalStatistics GetIPv6GlobalStatistics(); } public abstract class IPInterfaceProperties { public abstract IPAddressInformationCollection AnycastAddresses { get; } public abstract IPAddressCollection DhcpServerAddresses { get; } public abstract bool IsDnsEnabled { get; } public abstract bool IsDynamicDnsEnabled { get; } public abstract IPAddressCollection WinsServersAddresses { get; } } public abstract class IPInterfaceStatistics { public abstract long IncomingUnknownProtocolPackets { get; } public abstract long NonUnicastPacketsSent { get; } public abstract long OutgoingPacketsDiscarded { get; } } public abstract class IPv4InterfaceProperties { public abstract bool IsAutomaticPrivateAddressingActive { get; } public abstract bool IsAutomaticPrivateAddressingEnabled { get; } public abstract bool IsDhcpEnabled { get; } public abstract bool IsForwardingEnabled { get; } public abstract bool UsesWins { get; } } public abstract class IPv4InterfaceStatistics { public abstract long OutgoingPacketsDiscarded { get; } } public abstract class IPv6InterfaceProperties { public virtual long GetScopeId(ScopeLevel scopeLevel); } public abstract class MulticastIPAddressInformation : IPAddressInformation { public abstract long AddressPreferredLifetime { get; } public abstract long AddressValidLifetime { get; } public abstract long DhcpLeaseLifetime { get; } public abstract DuplicateAddressDetectionState DuplicateAddressDetectionState { get; } public abstract PrefixOrigin PrefixOrigin { get; } public abstract SuffixOrigin SuffixOrigin { get; } } public class NetworkChange { public static event NetworkAddressChangedEventHandler NetworkAddressChanged; public static event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged; } public abstract class NetworkInterface { public static int IPv6LoopbackInterfaceIndex { get; } public static int LoopbackInterfaceIndex { get; } } public class Ping : Component { + public PingReply Send(IPAddress address, TimeSpan timeout, byte[]? buffer, PingOptions? options); + public PingReply Send(string hostNameOrAddress, TimeSpan timeout, byte[]? buffer, PingOptions? options); } public abstract class UnicastIPAddressInformation : IPAddressInformation { public abstract long AddressPreferredLifetime { get; } public abstract long AddressValidLifetime { get; } public abstract long DhcpLeaseLifetime { get; } public abstract DuplicateAddressDetectionState DuplicateAddressDetectionState { get; } public abstract PrefixOrigin PrefixOrigin { get; } public abstract SuffixOrigin SuffixOrigin { get; } } }","title":"System.Net.NetworkInformation"},{"location":"Microsoft.NETCore.App/7.0_System.Net.NetworkInformation/#systemnetnetworkinformation","text":"namespace System.Net.NetworkInformation { public abstract class IcmpV4Statistics { public abstract long ErrorsReceived { get; } public abstract long ErrorsSent { get; } public abstract long MessagesReceived { get; } public abstract long MessagesSent { get; } } public abstract class IcmpV6Statistics { public abstract long ErrorsReceived { get; } public abstract long ErrorsSent { get; } public abstract long MessagesReceived { get; } public abstract long MessagesSent { get; } } public abstract class IPAddressInformation { public abstract bool IsDnsEligible { get; } public abstract bool IsTransient { get; } } public abstract class IPGlobalProperties { public abstract IPGlobalStatistics GetIPv6GlobalStatistics(); } public abstract class IPInterfaceProperties { public abstract IPAddressInformationCollection AnycastAddresses { get; } public abstract IPAddressCollection DhcpServerAddresses { get; } public abstract bool IsDnsEnabled { get; } public abstract bool IsDynamicDnsEnabled { get; } public abstract IPAddressCollection WinsServersAddresses { get; } } public abstract class IPInterfaceStatistics { public abstract long IncomingUnknownProtocolPackets { get; } public abstract long NonUnicastPacketsSent { get; } public abstract long OutgoingPacketsDiscarded { get; } } public abstract class IPv4InterfaceProperties { public abstract bool IsAutomaticPrivateAddressingActive { get; } public abstract bool IsAutomaticPrivateAddressingEnabled { get; } public abstract bool IsDhcpEnabled { get; } public abstract bool IsForwardingEnabled { get; } public abstract bool UsesWins { get; } } public abstract class IPv4InterfaceStatistics { public abstract long OutgoingPacketsDiscarded { get; } } public abstract class IPv6InterfaceProperties { public virtual long GetScopeId(ScopeLevel scopeLevel); } public abstract class MulticastIPAddressInformation : IPAddressInformation { public abstract long AddressPreferredLifetime { get; } public abstract long AddressValidLifetime { get; } public abstract long DhcpLeaseLifetime { get; } public abstract DuplicateAddressDetectionState DuplicateAddressDetectionState { get; } public abstract PrefixOrigin PrefixOrigin { get; } public abstract SuffixOrigin SuffixOrigin { get; } } public class NetworkChange { public static event NetworkAddressChangedEventHandler NetworkAddressChanged; public static event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged; } public abstract class NetworkInterface { public static int IPv6LoopbackInterfaceIndex { get; } public static int LoopbackInterfaceIndex { get; } } public class Ping : Component { + public PingReply Send(IPAddress address, TimeSpan timeout, byte[]? buffer, PingOptions? options); + public PingReply Send(string hostNameOrAddress, TimeSpan timeout, byte[]? buffer, PingOptions? options); } public abstract class UnicastIPAddressInformation : IPAddressInformation { public abstract long AddressPreferredLifetime { get; } public abstract long AddressValidLifetime { get; } public abstract long DhcpLeaseLifetime { get; } public abstract DuplicateAddressDetectionState DuplicateAddressDetectionState { get; } public abstract PrefixOrigin PrefixOrigin { get; } public abstract SuffixOrigin SuffixOrigin { get; } } }","title":"System.Net.NetworkInformation"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Quic/","text":"System.Net.Quic +namespace System.Net.Quic { + public enum QuicAbortDirection { + Both = 3, + Read = 1, + Write = 2, + } + public sealed class QuicClientConnectionOptions : QuicConnectionOptions { + public QuicClientConnectionOptions(); + public SslClientAuthenticationOptions ClientAuthenticationOptions { get; set; } + public IPEndPoint? LocalEndPoint { get; set; } + public EndPoint RemoteEndPoint { get; set; } + } + public sealed class QuicConnection : IAsyncDisposable { + public static bool IsSupported { get; } + public IPEndPoint LocalEndPoint { get; } + public SslApplicationProtocol NegotiatedApplicationProtocol { get; } + public X509Certificate? RemoteCertificate { get; } + public IPEndPoint RemoteEndPoint { get; } + public ValueTask<QuicStream> AcceptInboundStreamAsync(CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask CloseAsync(long errorCode, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<QuicConnection> ConnectAsync(QuicClientConnectionOptions options, CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask DisposeAsync(); + public ValueTask<QuicStream> OpenOutboundStreamAsync(QuicStreamType type, CancellationToken cancellationToken = default(CancellationToken)); + public override string ToString(); + } + public abstract class QuicConnectionOptions { + public long DefaultCloseErrorCode { get; set; } + public long DefaultStreamErrorCode { get; set; } + public TimeSpan IdleTimeout { get; set; } + public int MaxInboundBidirectionalStreams { get; set; } + public int MaxInboundUnidirectionalStreams { get; set; } + } + public enum QuicError { + AddressInUse = 4, + ConnectionAborted = 2, + ConnectionIdle = 10, + ConnectionRefused = 8, + ConnectionTimeout = 6, + HostUnreachable = 7, + InternalError = 1, + InvalidAddress = 5, + OperationAborted = 12, + ProtocolError = 11, + StreamAborted = 3, + Success = 0, + VersionNegotiationError = 9, + } + public sealed class QuicException : IOException { + public QuicException(QuicError error, long? applicationErrorCode, string message); + public long? ApplicationErrorCode { get; } + public QuicError QuicError { get; } + } + public sealed class QuicListener : IAsyncDisposable { + public static bool IsSupported { get; } + public IPEndPoint LocalEndPoint { get; } + public ValueTask<QuicConnection> AcceptConnectionAsync(CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask DisposeAsync(); + public static ValueTask<QuicListener> ListenAsync(QuicListenerOptions options, CancellationToken cancellationToken = default(CancellationToken)); + public override string ToString(); + } + public sealed class QuicListenerOptions { + public QuicListenerOptions(); + public List<SslApplicationProtocol> ApplicationProtocols { get; set; } + public Func<QuicConnection, SslClientHelloInfo, CancellationToken, ValueTask<QuicServerConnectionOptions>> ConnectionOptionsCallback { get; set; } + public int ListenBacklog { get; set; } + public IPEndPoint ListenEndPoint { get; set; } + } + public sealed class QuicServerConnectionOptions : QuicConnectionOptions { + public QuicServerConnectionOptions(); + public SslServerAuthenticationOptions ServerAuthenticationOptions { get; set; } + } + public sealed class QuicStream : Stream { + public override bool CanRead { get; } + public override bool CanSeek { get; } + public override bool CanTimeout { get; } + public override bool CanWrite { get; } + public long Id { get; } + public override long Length { get; } + public override long Position { get; set; } + public Task ReadsClosed { get; } + public override int ReadTimeout { get; set; } + public QuicStreamType Type { get; } + public Task WritesClosed { get; } + public override int WriteTimeout { get; set; } + public void Abort(QuicAbortDirection abortDirection, long errorCode); + public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback? callback, object? state); + public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback? callback, object? state); + public void CompleteWrites(); + protected override void Dispose(bool disposing); + public override ValueTask DisposeAsync(); + public override int EndRead(IAsyncResult asyncResult); + public override void EndWrite(IAsyncResult asyncResult); + public override void Flush(); + public override Task FlushAsync(CancellationToken cancellationToken = default(CancellationToken)); + public override int Read(byte[] buffer, int offset, int count); + public override int Read(Span<byte> buffer); + public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default(CancellationToken)); + public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public override int ReadByte(); + public override long Seek(long offset, SeekOrigin origin); + public override void SetLength(long value); + public override void Write(byte[] buffer, int offset, int count); + public override void Write(ReadOnlySpan<byte> buffer); + public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, bool completeWrites, CancellationToken cancellationToken = default(CancellationToken)); + public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public override void WriteByte(byte value); + } + public enum QuicStreamType { + Bidirectional = 1, + Unidirectional = 0, + } +}","title":"System.Net.Quic"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Quic/#systemnetquic","text":"+namespace System.Net.Quic { + public enum QuicAbortDirection { + Both = 3, + Read = 1, + Write = 2, + } + public sealed class QuicClientConnectionOptions : QuicConnectionOptions { + public QuicClientConnectionOptions(); + public SslClientAuthenticationOptions ClientAuthenticationOptions { get; set; } + public IPEndPoint? LocalEndPoint { get; set; } + public EndPoint RemoteEndPoint { get; set; } + } + public sealed class QuicConnection : IAsyncDisposable { + public static bool IsSupported { get; } + public IPEndPoint LocalEndPoint { get; } + public SslApplicationProtocol NegotiatedApplicationProtocol { get; } + public X509Certificate? RemoteCertificate { get; } + public IPEndPoint RemoteEndPoint { get; } + public ValueTask<QuicStream> AcceptInboundStreamAsync(CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask CloseAsync(long errorCode, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<QuicConnection> ConnectAsync(QuicClientConnectionOptions options, CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask DisposeAsync(); + public ValueTask<QuicStream> OpenOutboundStreamAsync(QuicStreamType type, CancellationToken cancellationToken = default(CancellationToken)); + public override string ToString(); + } + public abstract class QuicConnectionOptions { + public long DefaultCloseErrorCode { get; set; } + public long DefaultStreamErrorCode { get; set; } + public TimeSpan IdleTimeout { get; set; } + public int MaxInboundBidirectionalStreams { get; set; } + public int MaxInboundUnidirectionalStreams { get; set; } + } + public enum QuicError { + AddressInUse = 4, + ConnectionAborted = 2, + ConnectionIdle = 10, + ConnectionRefused = 8, + ConnectionTimeout = 6, + HostUnreachable = 7, + InternalError = 1, + InvalidAddress = 5, + OperationAborted = 12, + ProtocolError = 11, + StreamAborted = 3, + Success = 0, + VersionNegotiationError = 9, + } + public sealed class QuicException : IOException { + public QuicException(QuicError error, long? applicationErrorCode, string message); + public long? ApplicationErrorCode { get; } + public QuicError QuicError { get; } + } + public sealed class QuicListener : IAsyncDisposable { + public static bool IsSupported { get; } + public IPEndPoint LocalEndPoint { get; } + public ValueTask<QuicConnection> AcceptConnectionAsync(CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask DisposeAsync(); + public static ValueTask<QuicListener> ListenAsync(QuicListenerOptions options, CancellationToken cancellationToken = default(CancellationToken)); + public override string ToString(); + } + public sealed class QuicListenerOptions { + public QuicListenerOptions(); + public List<SslApplicationProtocol> ApplicationProtocols { get; set; } + public Func<QuicConnection, SslClientHelloInfo, CancellationToken, ValueTask<QuicServerConnectionOptions>> ConnectionOptionsCallback { get; set; } + public int ListenBacklog { get; set; } + public IPEndPoint ListenEndPoint { get; set; } + } + public sealed class QuicServerConnectionOptions : QuicConnectionOptions { + public QuicServerConnectionOptions(); + public SslServerAuthenticationOptions ServerAuthenticationOptions { get; set; } + } + public sealed class QuicStream : Stream { + public override bool CanRead { get; } + public override bool CanSeek { get; } + public override bool CanTimeout { get; } + public override bool CanWrite { get; } + public long Id { get; } + public override long Length { get; } + public override long Position { get; set; } + public Task ReadsClosed { get; } + public override int ReadTimeout { get; set; } + public QuicStreamType Type { get; } + public Task WritesClosed { get; } + public override int WriteTimeout { get; set; } + public void Abort(QuicAbortDirection abortDirection, long errorCode); + public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback? callback, object? state); + public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback? callback, object? state); + public void CompleteWrites(); + protected override void Dispose(bool disposing); + public override ValueTask DisposeAsync(); + public override int EndRead(IAsyncResult asyncResult); + public override void EndWrite(IAsyncResult asyncResult); + public override void Flush(); + public override Task FlushAsync(CancellationToken cancellationToken = default(CancellationToken)); + public override int Read(byte[] buffer, int offset, int count); + public override int Read(Span<byte> buffer); + public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default(CancellationToken)); + public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public override int ReadByte(); + public override long Seek(long offset, SeekOrigin origin); + public override void SetLength(long value); + public override void Write(byte[] buffer, int offset, int count); + public override void Write(ReadOnlySpan<byte> buffer); + public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default(CancellationToken)); + public ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, bool completeWrites, CancellationToken cancellationToken = default(CancellationToken)); + public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public override void WriteByte(byte value); + } + public enum QuicStreamType { + Bidirectional = 1, + Unidirectional = 0, + } +}","title":"System.Net.Quic"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Security/","text":"System.Net.Security namespace System.Net.Security { public enum EncryptionPolicy { AllowNoEncryption = 1, NoEncryption = 2, } + public sealed class NegotiateAuthentication : IDisposable { + public NegotiateAuthentication(NegotiateAuthenticationClientOptions clientOptions); + public NegotiateAuthentication(NegotiateAuthenticationServerOptions serverOptions); + public TokenImpersonationLevel ImpersonationLevel { get; } + public bool IsAuthenticated { get; } + public bool IsEncrypted { get; } + public bool IsMutuallyAuthenticated { get; } + public bool IsServer { get; } + public bool IsSigned { get; } + public string Package { get; } + public ProtectionLevel ProtectionLevel { get; } + public IIdentity RemoteIdentity { get; } + public string? TargetName { get; } + public void Dispose(); + public byte[]? GetOutgoingBlob(ReadOnlySpan<byte> incomingBlob, out NegotiateAuthenticationStatusCode statusCode); + public string? GetOutgoingBlob(string? incomingBlob, out NegotiateAuthenticationStatusCode statusCode); + public NegotiateAuthenticationStatusCode Unwrap(ReadOnlySpan<byte> input, IBufferWriter<byte> outputWriter, out bool wasEncrypted); + public NegotiateAuthenticationStatusCode UnwrapInPlace(Span<byte> input, out int unwrappedOffset, out int unwrappedLength, out bool wasEncrypted); + public NegotiateAuthenticationStatusCode Wrap(ReadOnlySpan<byte> input, IBufferWriter<byte> outputWriter, bool requestEncryption, out bool isEncrypted); + } + public class NegotiateAuthenticationClientOptions { + public NegotiateAuthenticationClientOptions(); + public TokenImpersonationLevel AllowedImpersonationLevel { get; set; } + public ChannelBinding? Binding { get; set; } + public NetworkCredential Credential { get; set; } + public string Package { get; set; } + public ProtectionLevel RequiredProtectionLevel { get; set; } + public bool RequireMutualAuthentication { get; set; } + public string? TargetName { get; set; } + } + public class NegotiateAuthenticationServerOptions { + public NegotiateAuthenticationServerOptions(); + public ChannelBinding? Binding { get; set; } + public NetworkCredential Credential { get; set; } + public string Package { get; set; } + public ExtendedProtectionPolicy? Policy { get; set; } + public TokenImpersonationLevel RequiredImpersonationLevel { get; set; } + public ProtectionLevel RequiredProtectionLevel { get; set; } + } + public enum NegotiateAuthenticationStatusCode { + BadBinding = 3, + Completed = 0, + ContextExpired = 6, + ContinueNeeded = 1, + CredentialsExpired = 7, + GenericFailure = 2, + ImpersonationValidationFailed = 15, + InvalidCredentials = 8, + InvalidToken = 9, + MessageAltered = 5, + OutOfSequence = 12, + QopNotSupported = 11, + SecurityQosFailed = 13, + TargetUnknown = 14, + UnknownCredentials = 10, + Unsupported = 4, + } public sealed class SslCertificateTrust { public static SslCertificateTrust CreateForX509Collection(X509Certificate2Collection trustList, bool sendTrustInHandshake = false); } public class SslClientAuthenticationOptions { + public X509ChainPolicy CertificateChainPolicy { get; set; } } public readonly struct SslClientHelloInfo { public string ServerName { get; } public SslProtocols SslProtocols { get; } } public class SslServerAuthenticationOptions { + public X509ChainPolicy CertificateChainPolicy { get; set; } } - public sealed class SslStreamCertificateContext + public class SslStreamCertificateContext }","title":"System.Net.Security"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Security/#systemnetsecurity","text":"namespace System.Net.Security { public enum EncryptionPolicy { AllowNoEncryption = 1, NoEncryption = 2, } + public sealed class NegotiateAuthentication : IDisposable { + public NegotiateAuthentication(NegotiateAuthenticationClientOptions clientOptions); + public NegotiateAuthentication(NegotiateAuthenticationServerOptions serverOptions); + public TokenImpersonationLevel ImpersonationLevel { get; } + public bool IsAuthenticated { get; } + public bool IsEncrypted { get; } + public bool IsMutuallyAuthenticated { get; } + public bool IsServer { get; } + public bool IsSigned { get; } + public string Package { get; } + public ProtectionLevel ProtectionLevel { get; } + public IIdentity RemoteIdentity { get; } + public string? TargetName { get; } + public void Dispose(); + public byte[]? GetOutgoingBlob(ReadOnlySpan<byte> incomingBlob, out NegotiateAuthenticationStatusCode statusCode); + public string? GetOutgoingBlob(string? incomingBlob, out NegotiateAuthenticationStatusCode statusCode); + public NegotiateAuthenticationStatusCode Unwrap(ReadOnlySpan<byte> input, IBufferWriter<byte> outputWriter, out bool wasEncrypted); + public NegotiateAuthenticationStatusCode UnwrapInPlace(Span<byte> input, out int unwrappedOffset, out int unwrappedLength, out bool wasEncrypted); + public NegotiateAuthenticationStatusCode Wrap(ReadOnlySpan<byte> input, IBufferWriter<byte> outputWriter, bool requestEncryption, out bool isEncrypted); + } + public class NegotiateAuthenticationClientOptions { + public NegotiateAuthenticationClientOptions(); + public TokenImpersonationLevel AllowedImpersonationLevel { get; set; } + public ChannelBinding? Binding { get; set; } + public NetworkCredential Credential { get; set; } + public string Package { get; set; } + public ProtectionLevel RequiredProtectionLevel { get; set; } + public bool RequireMutualAuthentication { get; set; } + public string? TargetName { get; set; } + } + public class NegotiateAuthenticationServerOptions { + public NegotiateAuthenticationServerOptions(); + public ChannelBinding? Binding { get; set; } + public NetworkCredential Credential { get; set; } + public string Package { get; set; } + public ExtendedProtectionPolicy? Policy { get; set; } + public TokenImpersonationLevel RequiredImpersonationLevel { get; set; } + public ProtectionLevel RequiredProtectionLevel { get; set; } + } + public enum NegotiateAuthenticationStatusCode { + BadBinding = 3, + Completed = 0, + ContextExpired = 6, + ContinueNeeded = 1, + CredentialsExpired = 7, + GenericFailure = 2, + ImpersonationValidationFailed = 15, + InvalidCredentials = 8, + InvalidToken = 9, + MessageAltered = 5, + OutOfSequence = 12, + QopNotSupported = 11, + SecurityQosFailed = 13, + TargetUnknown = 14, + UnknownCredentials = 10, + Unsupported = 4, + } public sealed class SslCertificateTrust { public static SslCertificateTrust CreateForX509Collection(X509Certificate2Collection trustList, bool sendTrustInHandshake = false); } public class SslClientAuthenticationOptions { + public X509ChainPolicy CertificateChainPolicy { get; set; } } public readonly struct SslClientHelloInfo { public string ServerName { get; } public SslProtocols SslProtocols { get; } } public class SslServerAuthenticationOptions { + public X509ChainPolicy CertificateChainPolicy { get; set; } } - public sealed class SslStreamCertificateContext + public class SslStreamCertificateContext }","title":"System.Net.Security"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Sockets/","text":"System.Net.Sockets namespace System.Net.Sockets { - public struct IPPacketInformation { + public struct IPPacketInformation : IEquatable<IPPacketInformation> { + public bool Equals(IPPacketInformation other); } public class NetworkStream : Stream { + public void Close(TimeSpan timeout); } public sealed class SafeSocketHandle : SafeHandleMinusOneIsInvalid { + public override bool IsInvalid { get; } } public class Socket : IDisposable { + public bool Poll(TimeSpan timeout, SelectMode mode); + public Task<int> ReceiveAsync(ArraySegment<byte> buffer); + public Task<int> ReceiveAsync(IList<ArraySegment<byte>> buffers); + public ValueTask<int> ReceiveAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public Task<SocketReceiveFromResult> ReceiveFromAsync(ArraySegment<byte> buffer, EndPoint remoteEndPoint); + public ValueTask<SocketReceiveFromResult> ReceiveFromAsync(Memory<byte> buffer, EndPoint remoteEndPoint, CancellationToken cancellationToken = default(CancellationToken)); + public Task<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(ArraySegment<byte> buffer, EndPoint remoteEndPoint); + public ValueTask<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Memory<byte> buffer, EndPoint remoteEndPoint, CancellationToken cancellationToken = default(CancellationToken)); + public static void Select(IList? checkRead, IList? checkWrite, IList? checkError, TimeSpan timeout); + public Task<int> SendAsync(ArraySegment<byte> buffer); + public Task<int> SendAsync(IList<ArraySegment<byte>> buffers); + public ValueTask<int> SendAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public Task<int> SendToAsync(ArraySegment<byte> buffer, EndPoint remoteEP); + public ValueTask<int> SendToAsync(ReadOnlyMemory<byte> buffer, EndPoint remoteEP, CancellationToken cancellationToken = default(CancellationToken)); } public static class SocketTaskExtensions public sealed class UnixDomainSocketEndPoint : EndPoint { + public override AddressFamily AddressFamily { get; } + public override EndPoint Create(SocketAddress socketAddress); + public override SocketAddress Serialize(); + public override string ToString(); } }","title":"System.Net.Sockets"},{"location":"Microsoft.NETCore.App/7.0_System.Net.Sockets/#systemnetsockets","text":"namespace System.Net.Sockets { - public struct IPPacketInformation { + public struct IPPacketInformation : IEquatable<IPPacketInformation> { + public bool Equals(IPPacketInformation other); } public class NetworkStream : Stream { + public void Close(TimeSpan timeout); } public sealed class SafeSocketHandle : SafeHandleMinusOneIsInvalid { + public override bool IsInvalid { get; } } public class Socket : IDisposable { + public bool Poll(TimeSpan timeout, SelectMode mode); + public Task<int> ReceiveAsync(ArraySegment<byte> buffer); + public Task<int> ReceiveAsync(IList<ArraySegment<byte>> buffers); + public ValueTask<int> ReceiveAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public Task<SocketReceiveFromResult> ReceiveFromAsync(ArraySegment<byte> buffer, EndPoint remoteEndPoint); + public ValueTask<SocketReceiveFromResult> ReceiveFromAsync(Memory<byte> buffer, EndPoint remoteEndPoint, CancellationToken cancellationToken = default(CancellationToken)); + public Task<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(ArraySegment<byte> buffer, EndPoint remoteEndPoint); + public ValueTask<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Memory<byte> buffer, EndPoint remoteEndPoint, CancellationToken cancellationToken = default(CancellationToken)); + public static void Select(IList? checkRead, IList? checkWrite, IList? checkError, TimeSpan timeout); + public Task<int> SendAsync(ArraySegment<byte> buffer); + public Task<int> SendAsync(IList<ArraySegment<byte>> buffers); + public ValueTask<int> SendAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken)); + public Task<int> SendToAsync(ArraySegment<byte> buffer, EndPoint remoteEP); + public ValueTask<int> SendToAsync(ReadOnlyMemory<byte> buffer, EndPoint remoteEP, CancellationToken cancellationToken = default(CancellationToken)); } public static class SocketTaskExtensions public sealed class UnixDomainSocketEndPoint : EndPoint { + public override AddressFamily AddressFamily { get; } + public override EndPoint Create(SocketAddress socketAddress); + public override SocketAddress Serialize(); + public override string ToString(); } }","title":"System.Net.Sockets"},{"location":"Microsoft.NETCore.App/7.0_System.Net.WebSockets/","text":"System.Net.WebSockets namespace System.Net.WebSockets { public sealed class ClientWebSocket : WebSocket { + public IReadOnlyDictionary<string, IEnumerable<string>>? HttpResponseHeaders { get; set; } + public HttpStatusCode HttpStatusCode { get; } + public Task ConnectAsync(Uri uri, HttpMessageInvoker? invoker, CancellationToken cancellationToken); } public sealed class ClientWebSocketOptions { + public bool CollectHttpResponseDetails { get; set; } + public Version HttpVersion { get; set; } + public HttpVersionPolicy HttpVersionPolicy { get; set; } } }","title":"System.Net.WebSockets"},{"location":"Microsoft.NETCore.App/7.0_System.Net.WebSockets/#systemnetwebsockets","text":"namespace System.Net.WebSockets { public sealed class ClientWebSocket : WebSocket { + public IReadOnlyDictionary<string, IEnumerable<string>>? HttpResponseHeaders { get; set; } + public HttpStatusCode HttpStatusCode { get; } + public Task ConnectAsync(Uri uri, HttpMessageInvoker? invoker, CancellationToken cancellationToken); } public sealed class ClientWebSocketOptions { + public bool CollectHttpResponseDetails { get; set; } + public Version HttpVersion { get; set; } + public HttpVersionPolicy HttpVersionPolicy { get; set; } } }","title":"System.Net.WebSockets"},{"location":"Microsoft.NETCore.App/7.0_System.Net/","text":"System.Net namespace System.Net { public class FileWebRequest : WebRequest, ISerializable { protected override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } public class FileWebResponse : WebResponse, ISerializable { protected override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } public sealed class HttpListenerResponse : IDisposable { public void Redirect(string url); } public class HttpWebRequest : WebRequest, ISerializable { protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext); } public class IPAddress { public long Address { get; set; } } public class WebProxy : ISerializable, IWebProxy { public WebProxy(string Address, bool BypassOnLocal, string[]? BypassList); public WebProxy(string Address, bool BypassOnLocal, string[]? BypassList, ICredentials Credentials); public WebProxy(Uri Address, bool BypassOnLocal, string[]? BypassList); public WebProxy(Uri Address, bool BypassOnLocal, string[]? BypassList, ICredentials Credentials); } public abstract class WebRequest : MarshalByRefObject, ISerializable { protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } public abstract class WebResponse : MarshalByRefObject, IDisposable, ISerializable { protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext); protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } }","title":"System.Net"},{"location":"Microsoft.NETCore.App/7.0_System.Net/#systemnet","text":"namespace System.Net { public class FileWebRequest : WebRequest, ISerializable { protected override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } public class FileWebResponse : WebResponse, ISerializable { protected override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } public sealed class HttpListenerResponse : IDisposable { public void Redirect(string url); } public class HttpWebRequest : WebRequest, ISerializable { protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext); } public class IPAddress { public long Address { get; set; } } public class WebProxy : ISerializable, IWebProxy { public WebProxy(string Address, bool BypassOnLocal, string[]? BypassList); public WebProxy(string Address, bool BypassOnLocal, string[]? BypassList, ICredentials Credentials); public WebProxy(Uri Address, bool BypassOnLocal, string[]? BypassList); public WebProxy(Uri Address, bool BypassOnLocal, string[]? BypassList, ICredentials Credentials); } public abstract class WebRequest : MarshalByRefObject, ISerializable { protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } public abstract class WebResponse : MarshalByRefObject, IDisposable, ISerializable { protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext); protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext); } }","title":"System.Net"},{"location":"Microsoft.NETCore.App/7.0_System.Numerics/","text":"System.Numerics namespace System.Numerics { - public readonly struct BigInteger : IComparable, IComparable<BigInteger>, IEquatable<BigInteger>, IFormattable, ISpanFormattable { + public readonly struct BigInteger : IAdditionOperators<BigInteger, BigInteger, BigInteger>, IAdditiveIdentity<BigInteger, BigInteger>, IBinaryInteger<BigInteger>, IBinaryNumber<BigInteger>, IBitwiseOperators<BigInteger, BigInteger, BigInteger>, IComparable, IComparable<BigInteger>, IComparisonOperators<BigInteger, BigInteger, bool>, IDecrementOperators<BigInteger>, IDivisionOperators<BigInteger, BigInteger, BigInteger>, IEqualityOperators<BigInteger, BigInteger, bool>, IEquatable<BigInteger>, IFormattable, IIncrementOperators<BigInteger>, IModulusOperators<BigInteger, BigInteger, BigInteger>, IMultiplicativeIdentity<BigInteger, BigInteger>, IMultiplyOperators<BigInteger, BigInteger, BigInteger>, INumber<BigInteger>, INumberBase<BigInteger>, IParsable<BigInteger>, IShiftOperators<BigInteger, int, BigInteger>, ISignedNumber<BigInteger>, ISpanFormattable, ISpanParsable<BigInteger>, ISubtractionOperators<BigInteger, BigInteger, BigInteger>, IUnaryNegationOperators<BigInteger, BigInteger>, IUnaryPlusOperators<BigInteger, BigInteger> { + static BigInteger System.Numerics.IAdditiveIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.AdditiveIdentity { get; } + static BigInteger System.Numerics.IBinaryNumber<System.Numerics.BigInteger>.AllBitsSet { get; } + static BigInteger System.Numerics.IMultiplicativeIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.Numerics.BigInteger>.Radix { get; } + static BigInteger System.Numerics.ISignedNumber<System.Numerics.BigInteger>.NegativeOne { get; } + public static BigInteger Clamp(BigInteger value, BigInteger min, BigInteger max); + public static BigInteger CopySign(BigInteger value, BigInteger sign); + public static BigInteger CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static BigInteger CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static BigInteger CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (BigInteger Quotient, BigInteger Remainder) DivRem(BigInteger left, BigInteger right); + public static bool IsEvenInteger(BigInteger value); + public static bool IsNegative(BigInteger value); + public static bool IsOddInteger(BigInteger value); + public static bool IsPositive(BigInteger value); + public static bool IsPow2(BigInteger value); + public static BigInteger LeadingZeroCount(BigInteger value); + public static BigInteger Log2(BigInteger value); + public static BigInteger MaxMagnitude(BigInteger x, BigInteger y); + public static BigInteger MinMagnitude(BigInteger x, BigInteger y); + public static explicit operator BigInteger (Half value); + public static explicit operator char (BigInteger value); + public static explicit operator Half (BigInteger value); + public static explicit operator Int128 (BigInteger value); + public static explicit operator IntPtr (BigInteger value); + public static explicit operator UInt128 (BigInteger value); + public static explicit operator UIntPtr (BigInteger value); + public static explicit operator BigInteger (Complex value); + public static implicit operator BigInteger (char value); + public static implicit operator BigInteger (Int128 value); + public static implicit operator BigInteger (IntPtr value); + public static implicit operator BigInteger (UInt128 value); + public static implicit operator BigInteger (UIntPtr value); + public static BigInteger operator >>>(BigInteger value, int shiftAmount); + public static BigInteger Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static BigInteger PopCount(BigInteger value); + public static BigInteger RotateLeft(BigInteger value, int rotateAmount); + public static BigInteger RotateRight(BigInteger value, int rotateAmount); + int IBinaryInteger<BigInteger>.GetByteCount(); + int IBinaryInteger<BigInteger>.GetShortestBitLength(); + static bool IBinaryInteger<BigInteger>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out BigInteger value); + static bool IBinaryInteger<BigInteger>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out BigInteger value); + bool IBinaryInteger<BigInteger>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<BigInteger>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static BigInteger INumber<BigInteger>.MaxNumber(BigInteger x, BigInteger y); + static BigInteger INumber<BigInteger>.MinNumber(BigInteger x, BigInteger y); + static int INumber<BigInteger>.Sign(BigInteger value); + static bool INumberBase<BigInteger>.IsCanonical(BigInteger value); + static bool INumberBase<BigInteger>.IsComplexNumber(BigInteger value); + static bool INumberBase<BigInteger>.IsFinite(BigInteger value); + static bool INumberBase<BigInteger>.IsImaginaryNumber(BigInteger value); + static bool INumberBase<BigInteger>.IsInfinity(BigInteger value); + static bool INumberBase<BigInteger>.IsInteger(BigInteger value); + static bool INumberBase<BigInteger>.IsNaN(BigInteger value); + static bool INumberBase<BigInteger>.IsNegativeInfinity(BigInteger value); + static bool INumberBase<BigInteger>.IsNormal(BigInteger value); + static bool INumberBase<BigInteger>.IsPositiveInfinity(BigInteger value); + static bool INumberBase<BigInteger>.IsRealNumber(BigInteger value); + static bool INumberBase<BigInteger>.IsSubnormal(BigInteger value); + static bool INumberBase<BigInteger>.IsZero(BigInteger value); + static BigInteger INumberBase<BigInteger>.MaxMagnitudeNumber(BigInteger x, BigInteger y); + static BigInteger INumberBase<BigInteger>.MinMagnitudeNumber(BigInteger x, BigInteger y); + static bool INumberBase<BigInteger>.TryConvertFromChecked<TOther>(TOther value, out BigInteger result); + static bool INumberBase<BigInteger>.TryConvertFromSaturating<TOther>(TOther value, out BigInteger result); + static bool INumberBase<BigInteger>.TryConvertFromTruncating<TOther>(TOther value, out BigInteger result); + static bool INumberBase<BigInteger>.TryConvertToChecked<TOther>(BigInteger value, out TOther result); + static bool INumberBase<BigInteger>.TryConvertToSaturating<TOther>(BigInteger value, out TOther result); + static bool INumberBase<BigInteger>.TryConvertToTruncating<TOther>(BigInteger value, out TOther result); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static BigInteger TrailingZeroCount(BigInteger value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out BigInteger result); + public static bool TryParse(string? s, IFormatProvider? provider, out BigInteger result); } public static class BitOperations { + public static bool IsPow2(IntPtr value); + public static bool IsPow2(UIntPtr value); + public static int LeadingZeroCount(UIntPtr value); + public static int Log2(UIntPtr value); + public static int PopCount(UIntPtr value); + public static UIntPtr RotateLeft(UIntPtr value, int offset); + public static UIntPtr RotateRight(UIntPtr value, int offset); + public static UIntPtr RoundUpToPowerOf2(UIntPtr value); + public static int TrailingZeroCount(IntPtr value); + public static int TrailingZeroCount(UIntPtr value); } - public readonly struct Complex : IEquatable<Complex>, IFormattable { + public readonly struct Complex : IAdditionOperators<Complex, Complex, Complex>, IAdditiveIdentity<Complex, Complex>, IDecrementOperators<Complex>, IDivisionOperators<Complex, Complex, Complex>, IEqualityOperators<Complex, Complex, bool>, IEquatable<Complex>, IFormattable, IIncrementOperators<Complex>, IMultiplicativeIdentity<Complex, Complex>, IMultiplyOperators<Complex, Complex, Complex>, INumberBase<Complex>, IParsable<Complex>, ISignedNumber<Complex>, ISpanFormattable, ISpanParsable<Complex>, ISubtractionOperators<Complex, Complex, Complex>, IUnaryNegationOperators<Complex, Complex>, IUnaryPlusOperators<Complex, Complex> { + static Complex System.Numerics.IAdditiveIdentity<System.Numerics.Complex,System.Numerics.Complex>.AdditiveIdentity { get; } + static Complex System.Numerics.IMultiplicativeIdentity<System.Numerics.Complex,System.Numerics.Complex>.MultiplicativeIdentity { get; } + static Complex System.Numerics.INumberBase<System.Numerics.Complex>.One { get; } + static int System.Numerics.INumberBase<System.Numerics.Complex>.Radix { get; } + static Complex System.Numerics.INumberBase<System.Numerics.Complex>.Zero { get; } + static Complex System.Numerics.ISignedNumber<System.Numerics.Complex>.NegativeOne { get; } + public static Complex CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Complex CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Complex CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static bool IsComplexNumber(Complex value); + public static bool IsEvenInteger(Complex value); + public static bool IsImaginaryNumber(Complex value); + public static bool IsInteger(Complex value); + public static bool IsNegative(Complex value); + public static bool IsNegativeInfinity(Complex value); + public static bool IsNormal(Complex value); + public static bool IsOddInteger(Complex value); + public static bool IsPositive(Complex value); + public static bool IsPositiveInfinity(Complex value); + public static bool IsRealNumber(Complex value); + public static bool IsSubnormal(Complex value); + public static Complex MaxMagnitude(Complex x, Complex y); + public static Complex MinMagnitude(Complex x, Complex y); + public static Complex operator --(Complex value); + public static explicit operator Complex (Int128 value); + public static explicit operator Complex (UInt128 value); + public static implicit operator Complex (char value); + public static implicit operator Complex (Half value); + public static implicit operator Complex (IntPtr value); + public static implicit operator Complex (UIntPtr value); + public static Complex operator ++(Complex value); + public static Complex operator +(Complex value); + public static Complex Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider); + public static Complex Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Complex Parse(string s, NumberStyles style, IFormatProvider? provider); + public static Complex Parse(string s, IFormatProvider? provider); + static Complex INumberBase<Complex>.Abs(Complex value); + static bool INumberBase<Complex>.IsCanonical(Complex value); + static bool INumberBase<Complex>.IsZero(Complex value); + static Complex INumberBase<Complex>.MaxMagnitudeNumber(Complex x, Complex y); + static Complex INumberBase<Complex>.MinMagnitudeNumber(Complex x, Complex y); + static bool INumberBase<Complex>.TryConvertFromChecked<TOther>(TOther value, out Complex result); + static bool INumberBase<Complex>.TryConvertFromSaturating<TOther>(TOther value, out Complex result); + static bool INumberBase<Complex>.TryConvertFromTruncating<TOther>(TOther value, out Complex result); + static bool INumberBase<Complex>.TryConvertToChecked<TOther>(Complex value, out TOther result); + static bool INumberBase<Complex>.TryConvertToSaturating<TOther>(Complex value, out TOther result); + static bool INumberBase<Complex>.TryConvertToTruncating<TOther>(Complex value, out TOther result); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out Complex result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Complex result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out Complex result); + public static bool TryParse(string? s, IFormatProvider? provider, out Complex result); } + public interface IAdditionOperators<TSelf, TOther, TResult> where TSelf : IAdditionOperators<TSelf, TOther, TResult>? { + static abstract TResult operator +(TSelf left, TOther right); + static TResult operator checked +(TSelf left, TOther right); + } + public interface IAdditiveIdentity<TSelf, TResult> where TSelf : IAdditiveIdentity<TSelf, TResult>? { + static abstract TResult AdditiveIdentity { get; } + } + public interface IBinaryFloatingPointIeee754<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IExponentialFunctions<TSelf>, IFloatingPoint<TSelf>, IFloatingPointConstants<TSelf>, IFloatingPointIeee754<TSelf>, IFormattable, IHyperbolicFunctions<TSelf>, IIncrementOperators<TSelf>, ILogarithmicFunctions<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, IPowerFunctions<TSelf>, IRootFunctions<TSelf>, ISignedNumber<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, ITrigonometricFunctions<TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IBinaryFloatingPointIeee754<TSelf>? + public interface IBinaryInteger<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, IShiftOperators<TSelf, int, TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IBinaryInteger<TSelf>? { + static (TSelf Quotient, TSelf Remainder) DivRem(TSelf left, TSelf right); + int GetByteCount(); + int GetShortestBitLength(); + static TSelf LeadingZeroCount(TSelf value); + static abstract TSelf PopCount(TSelf value); + static TSelf ReadBigEndian(byte[] source, bool isUnsigned); + static TSelf ReadBigEndian(byte[] source, int startIndex, bool isUnsigned); + static TSelf ReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned); + static TSelf ReadLittleEndian(byte[] source, bool isUnsigned); + static TSelf ReadLittleEndian(byte[] source, int startIndex, bool isUnsigned); + static TSelf ReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned); + static TSelf RotateLeft(TSelf value, int rotateAmount); + static TSelf RotateRight(TSelf value, int rotateAmount); + static abstract TSelf TrailingZeroCount(TSelf value); + static abstract bool TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out TSelf value); + static abstract bool TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out TSelf value); + bool TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + int WriteBigEndian(byte[] destination); + int WriteBigEndian(byte[] destination, int startIndex); + int WriteBigEndian(Span<byte> destination); + int WriteLittleEndian(byte[] destination); + int WriteLittleEndian(byte[] destination, int startIndex); + int WriteLittleEndian(Span<byte> destination); + } + public interface IBinaryNumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IBinaryNumber<TSelf>? { + static TSelf AllBitsSet { get; } + static abstract bool IsPow2(TSelf value); + static abstract TSelf Log2(TSelf value); + } + public interface IBitwiseOperators<TSelf, TOther, TResult> where TSelf : IBitwiseOperators<TSelf, TOther, TResult>? { + static abstract TResult operator &(TSelf left, TOther right); + static abstract TResult operator |(TSelf left, TOther right); + static abstract TResult operator ^(TSelf left, TOther right); + static abstract TResult operator ~(TSelf value); + } + public interface IComparisonOperators<TSelf, TOther, TResult> : IEqualityOperators<TSelf, TOther, TResult> where TSelf : IComparisonOperators<TSelf, TOther, TResult>? { + static abstract TResult operator >(TSelf left, TOther right); + static abstract TResult operator >=(TSelf left, TOther right); + static abstract TResult operator <(TSelf left, TOther right); + static abstract TResult operator <=(TSelf left, TOther right); + } + public interface IDecrementOperators<TSelf> where TSelf : IDecrementOperators<TSelf>? { + static TSelf operator checked --(TSelf value); + static abstract TSelf operator --(TSelf value); + } + public interface IDivisionOperators<TSelf, TOther, TResult> where TSelf : IDivisionOperators<TSelf, TOther, TResult>? { + static TResult operator checked /(TSelf left, TOther right); + static abstract TResult operator /(TSelf left, TOther right); + } + public interface IEqualityOperators<TSelf, TOther, TResult> where TSelf : IEqualityOperators<TSelf, TOther, TResult>? { + static abstract TResult operator ==(TSelf left, TOther right); + static abstract TResult operator !=(TSelf left, TOther right); + } + public interface IExponentialFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IExponentialFunctions<TSelf>? { + static abstract TSelf Exp(TSelf x); + static abstract TSelf Exp10(TSelf x); + static TSelf Exp10M1(TSelf x); + static abstract TSelf Exp2(TSelf x); + static TSelf Exp2M1(TSelf x); + static TSelf ExpM1(TSelf x); + } + public interface IFloatingPoint<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISignedNumber<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IFloatingPoint<TSelf>? { + static TSelf Ceiling(TSelf x); + static TSelf Floor(TSelf x); + int GetExponentByteCount(); + int GetExponentShortestBitLength(); + int GetSignificandBitLength(); + int GetSignificandByteCount(); + static TSelf Round(TSelf x); + static TSelf Round(TSelf x, int digits); + static abstract TSelf Round(TSelf x, int digits, MidpointRounding mode); + static TSelf Round(TSelf x, MidpointRounding mode); + static TSelf Truncate(TSelf x); + bool TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + int WriteExponentBigEndian(byte[] destination); + int WriteExponentBigEndian(byte[] destination, int startIndex); + int WriteExponentBigEndian(Span<byte> destination); + int WriteExponentLittleEndian(byte[] destination); + int WriteExponentLittleEndian(byte[] destination, int startIndex); + int WriteExponentLittleEndian(Span<byte> destination); + int WriteSignificandBigEndian(byte[] destination); + int WriteSignificandBigEndian(byte[] destination, int startIndex); + int WriteSignificandBigEndian(Span<byte> destination); + int WriteSignificandLittleEndian(byte[] destination); + int WriteSignificandLittleEndian(byte[] destination, int startIndex); + int WriteSignificandLittleEndian(Span<byte> destination); + } + public interface IFloatingPointConstants<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IFloatingPointConstants<TSelf>? { + static abstract TSelf E { get; } + static abstract TSelf Pi { get; } + static abstract TSelf Tau { get; } + } + public interface IFloatingPointIeee754<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IExponentialFunctions<TSelf>, IFloatingPoint<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IHyperbolicFunctions<TSelf>, IIncrementOperators<TSelf>, ILogarithmicFunctions<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, IPowerFunctions<TSelf>, IRootFunctions<TSelf>, ISignedNumber<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, ITrigonometricFunctions<TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IFloatingPointIeee754<TSelf>? { + static abstract TSelf Epsilon { get; } + static abstract TSelf NaN { get; } + static abstract TSelf NegativeInfinity { get; } + static abstract TSelf NegativeZero { get; } + static abstract TSelf PositiveInfinity { get; } + static abstract TSelf Atan2(TSelf y, TSelf x); + static abstract TSelf Atan2Pi(TSelf y, TSelf x); + static abstract TSelf BitDecrement(TSelf x); + static abstract TSelf BitIncrement(TSelf x); + static abstract TSelf FusedMultiplyAdd(TSelf left, TSelf right, TSelf addend); + static abstract TSelf Ieee754Remainder(TSelf left, TSelf right); + static abstract int ILogB(TSelf x); + static TSelf ReciprocalEstimate(TSelf x); + static TSelf ReciprocalSqrtEstimate(TSelf x); + static abstract TSelf ScaleB(TSelf x, int n); + } + public interface IHyperbolicFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IHyperbolicFunctions<TSelf>? { + static abstract TSelf Acosh(TSelf x); + static abstract TSelf Asinh(TSelf x); + static abstract TSelf Atanh(TSelf x); + static abstract TSelf Cosh(TSelf x); + static abstract TSelf Sinh(TSelf x); + static abstract TSelf Tanh(TSelf x); + } + public interface IIncrementOperators<TSelf> where TSelf : IIncrementOperators<TSelf>? { + static TSelf operator checked ++(TSelf value); + static abstract TSelf operator ++(TSelf value); + } + public interface ILogarithmicFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : ILogarithmicFunctions<TSelf>? { + static abstract TSelf Log(TSelf x); + static abstract TSelf Log(TSelf x, TSelf newBase); + static abstract TSelf Log10(TSelf x); + static TSelf Log10P1(TSelf x); + static abstract TSelf Log2(TSelf x); + static TSelf Log2P1(TSelf x); + static TSelf LogP1(TSelf x); + } + public interface IMinMaxValue<TSelf> where TSelf : IMinMaxValue<TSelf>? { + static abstract TSelf MaxValue { get; } + static abstract TSelf MinValue { get; } + } + public interface IModulusOperators<TSelf, TOther, TResult> where TSelf : IModulusOperators<TSelf, TOther, TResult>? { + static abstract TResult operator %(TSelf left, TOther right); + } + public interface IMultiplicativeIdentity<TSelf, TResult> where TSelf : IMultiplicativeIdentity<TSelf, TResult>? { + static abstract TResult MultiplicativeIdentity { get; } + } + public interface IMultiplyOperators<TSelf, TOther, TResult> where TSelf : IMultiplyOperators<TSelf, TOther, TResult>? { + static TResult operator checked *(TSelf left, TOther right); + static abstract TResult operator *(TSelf left, TOther right); + } + public interface INumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : INumber<TSelf>? { + static TSelf Clamp(TSelf value, TSelf min, TSelf max); + static TSelf CopySign(TSelf value, TSelf sign); + static TSelf Max(TSelf x, TSelf y); + static TSelf MaxNumber(TSelf x, TSelf y); + static TSelf Min(TSelf x, TSelf y); + static TSelf MinNumber(TSelf x, TSelf y); + static int Sign(TSelf value); + } + public interface INumberBase<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : INumberBase<TSelf>? { + static abstract TSelf One { get; } + static abstract int Radix { get; } + static abstract TSelf Zero { get; } + static abstract TSelf Abs(TSelf value); + static TSelf CreateChecked<TOther>(TOther value); + static TSelf CreateSaturating<TOther>(TOther value); + static TSelf CreateTruncating<TOther>(TOther value); + static abstract bool IsCanonical(TSelf value); + static abstract bool IsComplexNumber(TSelf value); + static abstract bool IsEvenInteger(TSelf value); + static abstract bool IsFinite(TSelf value); + static abstract bool IsImaginaryNumber(TSelf value); + static abstract bool IsInfinity(TSelf value); + static abstract bool IsInteger(TSelf value); + static abstract bool IsNaN(TSelf value); + static abstract bool IsNegative(TSelf value); + static abstract bool IsNegativeInfinity(TSelf value); + static abstract bool IsNormal(TSelf value); + static abstract bool IsOddInteger(TSelf value); + static abstract bool IsPositive(TSelf value); + static abstract bool IsPositiveInfinity(TSelf value); + static abstract bool IsRealNumber(TSelf value); + static abstract bool IsSubnormal(TSelf value); + static abstract bool IsZero(TSelf value); + static abstract TSelf MaxMagnitude(TSelf x, TSelf y); + static abstract TSelf MaxMagnitudeNumber(TSelf x, TSelf y); + static abstract TSelf MinMagnitude(TSelf x, TSelf y); + static abstract TSelf MinMagnitudeNumber(TSelf x, TSelf y); + static abstract TSelf Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider); + static abstract TSelf Parse(string s, NumberStyles style, IFormatProvider? provider); + static abstract bool TryConvertFromChecked<TOther>(TOther value, out TSelf result); + static abstract bool TryConvertFromSaturating<TOther>(TOther value, out TSelf result); + static abstract bool TryConvertFromTruncating<TOther>(TOther value, out TSelf result); + static abstract bool TryConvertToChecked<TOther>(TSelf value, out TOther result); + static abstract bool TryConvertToSaturating<TOther>(TSelf value, out TOther result); + static abstract bool TryConvertToTruncating<TOther>(TSelf value, out TOther result); + static abstract bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out TSelf result); + static abstract bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out TSelf result); + } + public interface IPowerFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IPowerFunctions<TSelf>? { + static abstract TSelf Pow(TSelf x, TSelf y); + } + public interface IRootFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IRootFunctions<TSelf>? { + static abstract TSelf Cbrt(TSelf x); + static abstract TSelf Hypot(TSelf x, TSelf y); + static abstract TSelf RootN(TSelf x, int n); + static abstract TSelf Sqrt(TSelf x); + } + public interface IShiftOperators<TSelf, TOther, TResult> where TSelf : IShiftOperators<TSelf, TOther, TResult>? { + static abstract TResult operator <<(TSelf value, TOther shiftAmount); + static abstract TResult operator >>(TSelf value, TOther shiftAmount); + static abstract TResult operator >>>(TSelf value, TOther shiftAmount); + } + public interface ISignedNumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : ISignedNumber<TSelf>? { + static abstract TSelf NegativeOne { get; } + } + public interface ISubtractionOperators<TSelf, TOther, TResult> where TSelf : ISubtractionOperators<TSelf, TOther, TResult>? { + static TResult operator checked -(TSelf left, TOther right); + static abstract TResult operator -(TSelf left, TOther right); + } + public interface ITrigonometricFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : ITrigonometricFunctions<TSelf>? { + static abstract TSelf Acos(TSelf x); + static abstract TSelf AcosPi(TSelf x); + static abstract TSelf Asin(TSelf x); + static abstract TSelf AsinPi(TSelf x); + static abstract TSelf Atan(TSelf x); + static abstract TSelf AtanPi(TSelf x); + static abstract TSelf Cos(TSelf x); + static abstract TSelf CosPi(TSelf x); + static abstract TSelf Sin(TSelf x); + static abstract (TSelf Sin, TSelf Cos) SinCos(TSelf x); + static abstract (TSelf SinPi, TSelf CosPi) SinCosPi(TSelf x); + static abstract TSelf SinPi(TSelf x); + static abstract TSelf Tan(TSelf x); + static abstract TSelf TanPi(TSelf x); + } + public interface IUnaryNegationOperators<TSelf, TResult> where TSelf : IUnaryNegationOperators<TSelf, TResult>? { + static TResult operator checked -(TSelf value); + static abstract TResult operator -(TSelf value); + } + public interface IUnaryPlusOperators<TSelf, TResult> where TSelf : IUnaryPlusOperators<TSelf, TResult>? { + static abstract TResult operator +(TSelf value); + } + public interface IUnsignedNumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IUnsignedNumber<TSelf>? public struct Matrix3x2 : IEquatable<Matrix3x2> { + public float this[int row, int column] { get; set; } } public struct Matrix4x4 : IEquatable<Matrix4x4> { + public float this[int row, int column] { get; set; } } public struct Quaternion : IEquatable<Quaternion> { + public float this[int index] { get; set; } + public static Quaternion Zero { get; } } public static class Vector { + public static Vector<byte> ShiftLeft(Vector<byte> value, int shiftCount); + public static Vector<short> ShiftLeft(Vector<short> value, int shiftCount); + public static Vector<int> ShiftLeft(Vector<int> value, int shiftCount); + public static Vector<long> ShiftLeft(Vector<long> value, int shiftCount); + public static Vector<IntPtr> ShiftLeft(Vector<IntPtr> value, int shiftCount); + public static Vector<sbyte> ShiftLeft(Vector<sbyte> value, int shiftCount); + public static Vector<ushort> ShiftLeft(Vector<ushort> value, int shiftCount); + public static Vector<uint> ShiftLeft(Vector<uint> value, int shiftCount); + public static Vector<ulong> ShiftLeft(Vector<ulong> value, int shiftCount); + public static Vector<UIntPtr> ShiftLeft(Vector<UIntPtr> value, int shiftCount); + public static Vector<short> ShiftRightArithmetic(Vector<short> value, int shiftCount); + public static Vector<int> ShiftRightArithmetic(Vector<int> value, int shiftCount); + public static Vector<long> ShiftRightArithmetic(Vector<long> value, int shiftCount); + public static Vector<IntPtr> ShiftRightArithmetic(Vector<IntPtr> value, int shiftCount); + public static Vector<sbyte> ShiftRightArithmetic(Vector<sbyte> value, int shiftCount); + public static Vector<byte> ShiftRightLogical(Vector<byte> value, int shiftCount); + public static Vector<short> ShiftRightLogical(Vector<short> value, int shiftCount); + public static Vector<int> ShiftRightLogical(Vector<int> value, int shiftCount); + public static Vector<long> ShiftRightLogical(Vector<long> value, int shiftCount); + public static Vector<IntPtr> ShiftRightLogical(Vector<IntPtr> value, int shiftCount); + public static Vector<sbyte> ShiftRightLogical(Vector<sbyte> value, int shiftCount); + public static Vector<ushort> ShiftRightLogical(Vector<ushort> value, int shiftCount); + public static Vector<uint> ShiftRightLogical(Vector<uint> value, int shiftCount); + public static Vector<ulong> ShiftRightLogical(Vector<ulong> value, int shiftCount); + public static Vector<UIntPtr> ShiftRightLogical(Vector<UIntPtr> value, int shiftCount); } - public struct Vector<T> : IEquatable<Vector<T>>, IFormattable where T : struct { + public readonly struct Vector<T> : IEquatable<Vector<T>>, IFormattable where T : struct { + public static bool IsSupported { get; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } public struct Vector2 : IEquatable<Vector2>, IFormattable { + public float this[int index] { get; set; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } public struct Vector3 : IEquatable<Vector3>, IFormattable { + public float this[int index] { get; set; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } public struct Vector4 : IEquatable<Vector4>, IFormattable { + public float this[int index] { get; set; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } }","title":"System.Numerics"},{"location":"Microsoft.NETCore.App/7.0_System.Numerics/#systemnumerics","text":"namespace System.Numerics { - public readonly struct BigInteger : IComparable, IComparable<BigInteger>, IEquatable<BigInteger>, IFormattable, ISpanFormattable { + public readonly struct BigInteger : IAdditionOperators<BigInteger, BigInteger, BigInteger>, IAdditiveIdentity<BigInteger, BigInteger>, IBinaryInteger<BigInteger>, IBinaryNumber<BigInteger>, IBitwiseOperators<BigInteger, BigInteger, BigInteger>, IComparable, IComparable<BigInteger>, IComparisonOperators<BigInteger, BigInteger, bool>, IDecrementOperators<BigInteger>, IDivisionOperators<BigInteger, BigInteger, BigInteger>, IEqualityOperators<BigInteger, BigInteger, bool>, IEquatable<BigInteger>, IFormattable, IIncrementOperators<BigInteger>, IModulusOperators<BigInteger, BigInteger, BigInteger>, IMultiplicativeIdentity<BigInteger, BigInteger>, IMultiplyOperators<BigInteger, BigInteger, BigInteger>, INumber<BigInteger>, INumberBase<BigInteger>, IParsable<BigInteger>, IShiftOperators<BigInteger, int, BigInteger>, ISignedNumber<BigInteger>, ISpanFormattable, ISpanParsable<BigInteger>, ISubtractionOperators<BigInteger, BigInteger, BigInteger>, IUnaryNegationOperators<BigInteger, BigInteger>, IUnaryPlusOperators<BigInteger, BigInteger> { + static BigInteger System.Numerics.IAdditiveIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.AdditiveIdentity { get; } + static BigInteger System.Numerics.IBinaryNumber<System.Numerics.BigInteger>.AllBitsSet { get; } + static BigInteger System.Numerics.IMultiplicativeIdentity<System.Numerics.BigInteger,System.Numerics.BigInteger>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.Numerics.BigInteger>.Radix { get; } + static BigInteger System.Numerics.ISignedNumber<System.Numerics.BigInteger>.NegativeOne { get; } + public static BigInteger Clamp(BigInteger value, BigInteger min, BigInteger max); + public static BigInteger CopySign(BigInteger value, BigInteger sign); + public static BigInteger CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static BigInteger CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static BigInteger CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (BigInteger Quotient, BigInteger Remainder) DivRem(BigInteger left, BigInteger right); + public static bool IsEvenInteger(BigInteger value); + public static bool IsNegative(BigInteger value); + public static bool IsOddInteger(BigInteger value); + public static bool IsPositive(BigInteger value); + public static bool IsPow2(BigInteger value); + public static BigInteger LeadingZeroCount(BigInteger value); + public static BigInteger Log2(BigInteger value); + public static BigInteger MaxMagnitude(BigInteger x, BigInteger y); + public static BigInteger MinMagnitude(BigInteger x, BigInteger y); + public static explicit operator BigInteger (Half value); + public static explicit operator char (BigInteger value); + public static explicit operator Half (BigInteger value); + public static explicit operator Int128 (BigInteger value); + public static explicit operator IntPtr (BigInteger value); + public static explicit operator UInt128 (BigInteger value); + public static explicit operator UIntPtr (BigInteger value); + public static explicit operator BigInteger (Complex value); + public static implicit operator BigInteger (char value); + public static implicit operator BigInteger (Int128 value); + public static implicit operator BigInteger (IntPtr value); + public static implicit operator BigInteger (UInt128 value); + public static implicit operator BigInteger (UIntPtr value); + public static BigInteger operator >>>(BigInteger value, int shiftAmount); + public static BigInteger Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static BigInteger PopCount(BigInteger value); + public static BigInteger RotateLeft(BigInteger value, int rotateAmount); + public static BigInteger RotateRight(BigInteger value, int rotateAmount); + int IBinaryInteger<BigInteger>.GetByteCount(); + int IBinaryInteger<BigInteger>.GetShortestBitLength(); + static bool IBinaryInteger<BigInteger>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out BigInteger value); + static bool IBinaryInteger<BigInteger>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out BigInteger value); + bool IBinaryInteger<BigInteger>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<BigInteger>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static BigInteger INumber<BigInteger>.MaxNumber(BigInteger x, BigInteger y); + static BigInteger INumber<BigInteger>.MinNumber(BigInteger x, BigInteger y); + static int INumber<BigInteger>.Sign(BigInteger value); + static bool INumberBase<BigInteger>.IsCanonical(BigInteger value); + static bool INumberBase<BigInteger>.IsComplexNumber(BigInteger value); + static bool INumberBase<BigInteger>.IsFinite(BigInteger value); + static bool INumberBase<BigInteger>.IsImaginaryNumber(BigInteger value); + static bool INumberBase<BigInteger>.IsInfinity(BigInteger value); + static bool INumberBase<BigInteger>.IsInteger(BigInteger value); + static bool INumberBase<BigInteger>.IsNaN(BigInteger value); + static bool INumberBase<BigInteger>.IsNegativeInfinity(BigInteger value); + static bool INumberBase<BigInteger>.IsNormal(BigInteger value); + static bool INumberBase<BigInteger>.IsPositiveInfinity(BigInteger value); + static bool INumberBase<BigInteger>.IsRealNumber(BigInteger value); + static bool INumberBase<BigInteger>.IsSubnormal(BigInteger value); + static bool INumberBase<BigInteger>.IsZero(BigInteger value); + static BigInteger INumberBase<BigInteger>.MaxMagnitudeNumber(BigInteger x, BigInteger y); + static BigInteger INumberBase<BigInteger>.MinMagnitudeNumber(BigInteger x, BigInteger y); + static bool INumberBase<BigInteger>.TryConvertFromChecked<TOther>(TOther value, out BigInteger result); + static bool INumberBase<BigInteger>.TryConvertFromSaturating<TOther>(TOther value, out BigInteger result); + static bool INumberBase<BigInteger>.TryConvertFromTruncating<TOther>(TOther value, out BigInteger result); + static bool INumberBase<BigInteger>.TryConvertToChecked<TOther>(BigInteger value, out TOther result); + static bool INumberBase<BigInteger>.TryConvertToSaturating<TOther>(BigInteger value, out TOther result); + static bool INumberBase<BigInteger>.TryConvertToTruncating<TOther>(BigInteger value, out TOther result); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static BigInteger TrailingZeroCount(BigInteger value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out BigInteger result); + public static bool TryParse(string? s, IFormatProvider? provider, out BigInteger result); } public static class BitOperations { + public static bool IsPow2(IntPtr value); + public static bool IsPow2(UIntPtr value); + public static int LeadingZeroCount(UIntPtr value); + public static int Log2(UIntPtr value); + public static int PopCount(UIntPtr value); + public static UIntPtr RotateLeft(UIntPtr value, int offset); + public static UIntPtr RotateRight(UIntPtr value, int offset); + public static UIntPtr RoundUpToPowerOf2(UIntPtr value); + public static int TrailingZeroCount(IntPtr value); + public static int TrailingZeroCount(UIntPtr value); } - public readonly struct Complex : IEquatable<Complex>, IFormattable { + public readonly struct Complex : IAdditionOperators<Complex, Complex, Complex>, IAdditiveIdentity<Complex, Complex>, IDecrementOperators<Complex>, IDivisionOperators<Complex, Complex, Complex>, IEqualityOperators<Complex, Complex, bool>, IEquatable<Complex>, IFormattable, IIncrementOperators<Complex>, IMultiplicativeIdentity<Complex, Complex>, IMultiplyOperators<Complex, Complex, Complex>, INumberBase<Complex>, IParsable<Complex>, ISignedNumber<Complex>, ISpanFormattable, ISpanParsable<Complex>, ISubtractionOperators<Complex, Complex, Complex>, IUnaryNegationOperators<Complex, Complex>, IUnaryPlusOperators<Complex, Complex> { + static Complex System.Numerics.IAdditiveIdentity<System.Numerics.Complex,System.Numerics.Complex>.AdditiveIdentity { get; } + static Complex System.Numerics.IMultiplicativeIdentity<System.Numerics.Complex,System.Numerics.Complex>.MultiplicativeIdentity { get; } + static Complex System.Numerics.INumberBase<System.Numerics.Complex>.One { get; } + static int System.Numerics.INumberBase<System.Numerics.Complex>.Radix { get; } + static Complex System.Numerics.INumberBase<System.Numerics.Complex>.Zero { get; } + static Complex System.Numerics.ISignedNumber<System.Numerics.Complex>.NegativeOne { get; } + public static Complex CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Complex CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Complex CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static bool IsComplexNumber(Complex value); + public static bool IsEvenInteger(Complex value); + public static bool IsImaginaryNumber(Complex value); + public static bool IsInteger(Complex value); + public static bool IsNegative(Complex value); + public static bool IsNegativeInfinity(Complex value); + public static bool IsNormal(Complex value); + public static bool IsOddInteger(Complex value); + public static bool IsPositive(Complex value); + public static bool IsPositiveInfinity(Complex value); + public static bool IsRealNumber(Complex value); + public static bool IsSubnormal(Complex value); + public static Complex MaxMagnitude(Complex x, Complex y); + public static Complex MinMagnitude(Complex x, Complex y); + public static Complex operator --(Complex value); + public static explicit operator Complex (Int128 value); + public static explicit operator Complex (UInt128 value); + public static implicit operator Complex (char value); + public static implicit operator Complex (Half value); + public static implicit operator Complex (IntPtr value); + public static implicit operator Complex (UIntPtr value); + public static Complex operator ++(Complex value); + public static Complex operator +(Complex value); + public static Complex Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider); + public static Complex Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Complex Parse(string s, NumberStyles style, IFormatProvider? provider); + public static Complex Parse(string s, IFormatProvider? provider); + static Complex INumberBase<Complex>.Abs(Complex value); + static bool INumberBase<Complex>.IsCanonical(Complex value); + static bool INumberBase<Complex>.IsZero(Complex value); + static Complex INumberBase<Complex>.MaxMagnitudeNumber(Complex x, Complex y); + static Complex INumberBase<Complex>.MinMagnitudeNumber(Complex x, Complex y); + static bool INumberBase<Complex>.TryConvertFromChecked<TOther>(TOther value, out Complex result); + static bool INumberBase<Complex>.TryConvertFromSaturating<TOther>(TOther value, out Complex result); + static bool INumberBase<Complex>.TryConvertFromTruncating<TOther>(TOther value, out Complex result); + static bool INumberBase<Complex>.TryConvertToChecked<TOther>(Complex value, out TOther result); + static bool INumberBase<Complex>.TryConvertToSaturating<TOther>(Complex value, out TOther result); + static bool INumberBase<Complex>.TryConvertToTruncating<TOther>(Complex value, out TOther result); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out Complex result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Complex result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out Complex result); + public static bool TryParse(string? s, IFormatProvider? provider, out Complex result); } + public interface IAdditionOperators<TSelf, TOther, TResult> where TSelf : IAdditionOperators<TSelf, TOther, TResult>? { + static abstract TResult operator +(TSelf left, TOther right); + static TResult operator checked +(TSelf left, TOther right); + } + public interface IAdditiveIdentity<TSelf, TResult> where TSelf : IAdditiveIdentity<TSelf, TResult>? { + static abstract TResult AdditiveIdentity { get; } + } + public interface IBinaryFloatingPointIeee754<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IExponentialFunctions<TSelf>, IFloatingPoint<TSelf>, IFloatingPointConstants<TSelf>, IFloatingPointIeee754<TSelf>, IFormattable, IHyperbolicFunctions<TSelf>, IIncrementOperators<TSelf>, ILogarithmicFunctions<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, IPowerFunctions<TSelf>, IRootFunctions<TSelf>, ISignedNumber<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, ITrigonometricFunctions<TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IBinaryFloatingPointIeee754<TSelf>? + public interface IBinaryInteger<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, IShiftOperators<TSelf, int, TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IBinaryInteger<TSelf>? { + static (TSelf Quotient, TSelf Remainder) DivRem(TSelf left, TSelf right); + int GetByteCount(); + int GetShortestBitLength(); + static TSelf LeadingZeroCount(TSelf value); + static abstract TSelf PopCount(TSelf value); + static TSelf ReadBigEndian(byte[] source, bool isUnsigned); + static TSelf ReadBigEndian(byte[] source, int startIndex, bool isUnsigned); + static TSelf ReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned); + static TSelf ReadLittleEndian(byte[] source, bool isUnsigned); + static TSelf ReadLittleEndian(byte[] source, int startIndex, bool isUnsigned); + static TSelf ReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned); + static TSelf RotateLeft(TSelf value, int rotateAmount); + static TSelf RotateRight(TSelf value, int rotateAmount); + static abstract TSelf TrailingZeroCount(TSelf value); + static abstract bool TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out TSelf value); + static abstract bool TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out TSelf value); + bool TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + int WriteBigEndian(byte[] destination); + int WriteBigEndian(byte[] destination, int startIndex); + int WriteBigEndian(Span<byte> destination); + int WriteLittleEndian(byte[] destination); + int WriteLittleEndian(byte[] destination, int startIndex); + int WriteLittleEndian(Span<byte> destination); + } + public interface IBinaryNumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IBinaryNumber<TSelf>? { + static TSelf AllBitsSet { get; } + static abstract bool IsPow2(TSelf value); + static abstract TSelf Log2(TSelf value); + } + public interface IBitwiseOperators<TSelf, TOther, TResult> where TSelf : IBitwiseOperators<TSelf, TOther, TResult>? { + static abstract TResult operator &(TSelf left, TOther right); + static abstract TResult operator |(TSelf left, TOther right); + static abstract TResult operator ^(TSelf left, TOther right); + static abstract TResult operator ~(TSelf value); + } + public interface IComparisonOperators<TSelf, TOther, TResult> : IEqualityOperators<TSelf, TOther, TResult> where TSelf : IComparisonOperators<TSelf, TOther, TResult>? { + static abstract TResult operator >(TSelf left, TOther right); + static abstract TResult operator >=(TSelf left, TOther right); + static abstract TResult operator <(TSelf left, TOther right); + static abstract TResult operator <=(TSelf left, TOther right); + } + public interface IDecrementOperators<TSelf> where TSelf : IDecrementOperators<TSelf>? { + static TSelf operator checked --(TSelf value); + static abstract TSelf operator --(TSelf value); + } + public interface IDivisionOperators<TSelf, TOther, TResult> where TSelf : IDivisionOperators<TSelf, TOther, TResult>? { + static TResult operator checked /(TSelf left, TOther right); + static abstract TResult operator /(TSelf left, TOther right); + } + public interface IEqualityOperators<TSelf, TOther, TResult> where TSelf : IEqualityOperators<TSelf, TOther, TResult>? { + static abstract TResult operator ==(TSelf left, TOther right); + static abstract TResult operator !=(TSelf left, TOther right); + } + public interface IExponentialFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IExponentialFunctions<TSelf>? { + static abstract TSelf Exp(TSelf x); + static abstract TSelf Exp10(TSelf x); + static TSelf Exp10M1(TSelf x); + static abstract TSelf Exp2(TSelf x); + static TSelf Exp2M1(TSelf x); + static TSelf ExpM1(TSelf x); + } + public interface IFloatingPoint<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISignedNumber<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IFloatingPoint<TSelf>? { + static TSelf Ceiling(TSelf x); + static TSelf Floor(TSelf x); + int GetExponentByteCount(); + int GetExponentShortestBitLength(); + int GetSignificandBitLength(); + int GetSignificandByteCount(); + static TSelf Round(TSelf x); + static TSelf Round(TSelf x, int digits); + static abstract TSelf Round(TSelf x, int digits, MidpointRounding mode); + static TSelf Round(TSelf x, MidpointRounding mode); + static TSelf Truncate(TSelf x); + bool TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + int WriteExponentBigEndian(byte[] destination); + int WriteExponentBigEndian(byte[] destination, int startIndex); + int WriteExponentBigEndian(Span<byte> destination); + int WriteExponentLittleEndian(byte[] destination); + int WriteExponentLittleEndian(byte[] destination, int startIndex); + int WriteExponentLittleEndian(Span<byte> destination); + int WriteSignificandBigEndian(byte[] destination); + int WriteSignificandBigEndian(byte[] destination, int startIndex); + int WriteSignificandBigEndian(Span<byte> destination); + int WriteSignificandLittleEndian(byte[] destination); + int WriteSignificandLittleEndian(byte[] destination, int startIndex); + int WriteSignificandLittleEndian(Span<byte> destination); + } + public interface IFloatingPointConstants<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IFloatingPointConstants<TSelf>? { + static abstract TSelf E { get; } + static abstract TSelf Pi { get; } + static abstract TSelf Tau { get; } + } + public interface IFloatingPointIeee754<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IExponentialFunctions<TSelf>, IFloatingPoint<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IHyperbolicFunctions<TSelf>, IIncrementOperators<TSelf>, ILogarithmicFunctions<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, INumberBase<TSelf>, IParsable<TSelf>, IPowerFunctions<TSelf>, IRootFunctions<TSelf>, ISignedNumber<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, ITrigonometricFunctions<TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IFloatingPointIeee754<TSelf>? { + static abstract TSelf Epsilon { get; } + static abstract TSelf NaN { get; } + static abstract TSelf NegativeInfinity { get; } + static abstract TSelf NegativeZero { get; } + static abstract TSelf PositiveInfinity { get; } + static abstract TSelf Atan2(TSelf y, TSelf x); + static abstract TSelf Atan2Pi(TSelf y, TSelf x); + static abstract TSelf BitDecrement(TSelf x); + static abstract TSelf BitIncrement(TSelf x); + static abstract TSelf FusedMultiplyAdd(TSelf left, TSelf right, TSelf addend); + static abstract TSelf Ieee754Remainder(TSelf left, TSelf right); + static abstract int ILogB(TSelf x); + static TSelf ReciprocalEstimate(TSelf x); + static TSelf ReciprocalSqrtEstimate(TSelf x); + static abstract TSelf ScaleB(TSelf x, int n); + } + public interface IHyperbolicFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IHyperbolicFunctions<TSelf>? { + static abstract TSelf Acosh(TSelf x); + static abstract TSelf Asinh(TSelf x); + static abstract TSelf Atanh(TSelf x); + static abstract TSelf Cosh(TSelf x); + static abstract TSelf Sinh(TSelf x); + static abstract TSelf Tanh(TSelf x); + } + public interface IIncrementOperators<TSelf> where TSelf : IIncrementOperators<TSelf>? { + static TSelf operator checked ++(TSelf value); + static abstract TSelf operator ++(TSelf value); + } + public interface ILogarithmicFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : ILogarithmicFunctions<TSelf>? { + static abstract TSelf Log(TSelf x); + static abstract TSelf Log(TSelf x, TSelf newBase); + static abstract TSelf Log10(TSelf x); + static TSelf Log10P1(TSelf x); + static abstract TSelf Log2(TSelf x); + static TSelf Log2P1(TSelf x); + static TSelf LogP1(TSelf x); + } + public interface IMinMaxValue<TSelf> where TSelf : IMinMaxValue<TSelf>? { + static abstract TSelf MaxValue { get; } + static abstract TSelf MinValue { get; } + } + public interface IModulusOperators<TSelf, TOther, TResult> where TSelf : IModulusOperators<TSelf, TOther, TResult>? { + static abstract TResult operator %(TSelf left, TOther right); + } + public interface IMultiplicativeIdentity<TSelf, TResult> where TSelf : IMultiplicativeIdentity<TSelf, TResult>? { + static abstract TResult MultiplicativeIdentity { get; } + } + public interface IMultiplyOperators<TSelf, TOther, TResult> where TSelf : IMultiplyOperators<TSelf, TOther, TResult>? { + static TResult operator checked *(TSelf left, TOther right); + static abstract TResult operator *(TSelf left, TOther right); + } + public interface INumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, bool>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IModulusOperators<TSelf, TSelf, TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : INumber<TSelf>? { + static TSelf Clamp(TSelf value, TSelf min, TSelf max); + static TSelf CopySign(TSelf value, TSelf sign); + static TSelf Max(TSelf x, TSelf y); + static TSelf MaxNumber(TSelf x, TSelf y); + static TSelf Min(TSelf x, TSelf y); + static TSelf MinNumber(TSelf x, TSelf y); + static int Sign(TSelf value); + } + public interface INumberBase<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : INumberBase<TSelf>? { + static abstract TSelf One { get; } + static abstract int Radix { get; } + static abstract TSelf Zero { get; } + static abstract TSelf Abs(TSelf value); + static TSelf CreateChecked<TOther>(TOther value); + static TSelf CreateSaturating<TOther>(TOther value); + static TSelf CreateTruncating<TOther>(TOther value); + static abstract bool IsCanonical(TSelf value); + static abstract bool IsComplexNumber(TSelf value); + static abstract bool IsEvenInteger(TSelf value); + static abstract bool IsFinite(TSelf value); + static abstract bool IsImaginaryNumber(TSelf value); + static abstract bool IsInfinity(TSelf value); + static abstract bool IsInteger(TSelf value); + static abstract bool IsNaN(TSelf value); + static abstract bool IsNegative(TSelf value); + static abstract bool IsNegativeInfinity(TSelf value); + static abstract bool IsNormal(TSelf value); + static abstract bool IsOddInteger(TSelf value); + static abstract bool IsPositive(TSelf value); + static abstract bool IsPositiveInfinity(TSelf value); + static abstract bool IsRealNumber(TSelf value); + static abstract bool IsSubnormal(TSelf value); + static abstract bool IsZero(TSelf value); + static abstract TSelf MaxMagnitude(TSelf x, TSelf y); + static abstract TSelf MaxMagnitudeNumber(TSelf x, TSelf y); + static abstract TSelf MinMagnitude(TSelf x, TSelf y); + static abstract TSelf MinMagnitudeNumber(TSelf x, TSelf y); + static abstract TSelf Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider); + static abstract TSelf Parse(string s, NumberStyles style, IFormatProvider? provider); + static abstract bool TryConvertFromChecked<TOther>(TOther value, out TSelf result); + static abstract bool TryConvertFromSaturating<TOther>(TOther value, out TSelf result); + static abstract bool TryConvertFromTruncating<TOther>(TOther value, out TSelf result); + static abstract bool TryConvertToChecked<TOther>(TSelf value, out TOther result); + static abstract bool TryConvertToSaturating<TOther>(TSelf value, out TOther result); + static abstract bool TryConvertToTruncating<TOther>(TSelf value, out TOther result); + static abstract bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out TSelf result); + static abstract bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out TSelf result); + } + public interface IPowerFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IPowerFunctions<TSelf>? { + static abstract TSelf Pow(TSelf x, TSelf y); + } + public interface IRootFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IRootFunctions<TSelf>? { + static abstract TSelf Cbrt(TSelf x); + static abstract TSelf Hypot(TSelf x, TSelf y); + static abstract TSelf RootN(TSelf x, int n); + static abstract TSelf Sqrt(TSelf x); + } + public interface IShiftOperators<TSelf, TOther, TResult> where TSelf : IShiftOperators<TSelf, TOther, TResult>? { + static abstract TResult operator <<(TSelf value, TOther shiftAmount); + static abstract TResult operator >>(TSelf value, TOther shiftAmount); + static abstract TResult operator >>>(TSelf value, TOther shiftAmount); + } + public interface ISignedNumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : ISignedNumber<TSelf>? { + static abstract TSelf NegativeOne { get; } + } + public interface ISubtractionOperators<TSelf, TOther, TResult> where TSelf : ISubtractionOperators<TSelf, TOther, TResult>? { + static TResult operator checked -(TSelf left, TOther right); + static abstract TResult operator -(TSelf left, TOther right); + } + public interface ITrigonometricFunctions<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFloatingPointConstants<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : ITrigonometricFunctions<TSelf>? { + static abstract TSelf Acos(TSelf x); + static abstract TSelf AcosPi(TSelf x); + static abstract TSelf Asin(TSelf x); + static abstract TSelf AsinPi(TSelf x); + static abstract TSelf Atan(TSelf x); + static abstract TSelf AtanPi(TSelf x); + static abstract TSelf Cos(TSelf x); + static abstract TSelf CosPi(TSelf x); + static abstract TSelf Sin(TSelf x); + static abstract (TSelf Sin, TSelf Cos) SinCos(TSelf x); + static abstract (TSelf SinPi, TSelf CosPi) SinCosPi(TSelf x); + static abstract TSelf SinPi(TSelf x); + static abstract TSelf Tan(TSelf x); + static abstract TSelf TanPi(TSelf x); + } + public interface IUnaryNegationOperators<TSelf, TResult> where TSelf : IUnaryNegationOperators<TSelf, TResult>? { + static TResult operator checked -(TSelf value); + static abstract TResult operator -(TSelf value); + } + public interface IUnaryPlusOperators<TSelf, TResult> where TSelf : IUnaryPlusOperators<TSelf, TResult>? { + static abstract TResult operator +(TSelf value); + } + public interface IUnsignedNumber<TSelf> : IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEqualityOperators<TSelf, TSelf, bool>, IEquatable<TSelf>, IFormattable, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IParsable<TSelf>, ISpanFormattable, ISpanParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf> where TSelf : IUnsignedNumber<TSelf>? public struct Matrix3x2 : IEquatable<Matrix3x2> { + public float this[int row, int column] { get; set; } } public struct Matrix4x4 : IEquatable<Matrix4x4> { + public float this[int row, int column] { get; set; } } public struct Quaternion : IEquatable<Quaternion> { + public float this[int index] { get; set; } + public static Quaternion Zero { get; } } public static class Vector { + public static Vector<byte> ShiftLeft(Vector<byte> value, int shiftCount); + public static Vector<short> ShiftLeft(Vector<short> value, int shiftCount); + public static Vector<int> ShiftLeft(Vector<int> value, int shiftCount); + public static Vector<long> ShiftLeft(Vector<long> value, int shiftCount); + public static Vector<IntPtr> ShiftLeft(Vector<IntPtr> value, int shiftCount); + public static Vector<sbyte> ShiftLeft(Vector<sbyte> value, int shiftCount); + public static Vector<ushort> ShiftLeft(Vector<ushort> value, int shiftCount); + public static Vector<uint> ShiftLeft(Vector<uint> value, int shiftCount); + public static Vector<ulong> ShiftLeft(Vector<ulong> value, int shiftCount); + public static Vector<UIntPtr> ShiftLeft(Vector<UIntPtr> value, int shiftCount); + public static Vector<short> ShiftRightArithmetic(Vector<short> value, int shiftCount); + public static Vector<int> ShiftRightArithmetic(Vector<int> value, int shiftCount); + public static Vector<long> ShiftRightArithmetic(Vector<long> value, int shiftCount); + public static Vector<IntPtr> ShiftRightArithmetic(Vector<IntPtr> value, int shiftCount); + public static Vector<sbyte> ShiftRightArithmetic(Vector<sbyte> value, int shiftCount); + public static Vector<byte> ShiftRightLogical(Vector<byte> value, int shiftCount); + public static Vector<short> ShiftRightLogical(Vector<short> value, int shiftCount); + public static Vector<int> ShiftRightLogical(Vector<int> value, int shiftCount); + public static Vector<long> ShiftRightLogical(Vector<long> value, int shiftCount); + public static Vector<IntPtr> ShiftRightLogical(Vector<IntPtr> value, int shiftCount); + public static Vector<sbyte> ShiftRightLogical(Vector<sbyte> value, int shiftCount); + public static Vector<ushort> ShiftRightLogical(Vector<ushort> value, int shiftCount); + public static Vector<uint> ShiftRightLogical(Vector<uint> value, int shiftCount); + public static Vector<ulong> ShiftRightLogical(Vector<ulong> value, int shiftCount); + public static Vector<UIntPtr> ShiftRightLogical(Vector<UIntPtr> value, int shiftCount); } - public struct Vector<T> : IEquatable<Vector<T>>, IFormattable where T : struct { + public readonly struct Vector<T> : IEquatable<Vector<T>>, IFormattable where T : struct { + public static bool IsSupported { get; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } public struct Vector2 : IEquatable<Vector2>, IFormattable { + public float this[int index] { get; set; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } public struct Vector3 : IEquatable<Vector3>, IFormattable { + public float this[int index] { get; set; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } public struct Vector4 : IEquatable<Vector4>, IFormattable { + public float this[int index] { get; set; } public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); } }","title":"System.Numerics"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.Emit/","text":"System.Reflection.Emit namespace System.Reflection.Emit { public sealed class AssemblyBuilder : Assembly { public override string? CodeBase { get; } public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access); public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder>? assemblyAttributes); } public sealed class DynamicMethod : MethodInfo { public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type? returnType, Type[]? parameterTypes, Module m, bool skipVisibility); public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type? returnType, Type[]? parameterTypes, Type owner, bool skipVisibility); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, bool restrictedSkipVisibility); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Module m); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Module m, bool skipVisibility); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Type owner); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Type owner, bool skipVisibility); } public sealed class EnumBuilder : TypeInfo { - public Type? CreateType(); + public Type CreateType(); - public TypeInfo? CreateTypeInfo(); + public TypeInfo CreateTypeInfo(); public override Type MakeArrayType(); public override Type MakeArrayType(int rank); } public sealed class GenericTypeParameterBuilder : TypeInfo { public override Type MakeArrayType(); public override Type MakeArrayType(int rank); public override Type MakeGenericType(params Type[] typeArguments); } public class ILGenerator { - public virtual void BeginCatchBlock(Type exceptionType); + public virtual void BeginCatchBlock(Type? exceptionType); } public sealed class MethodBuilder : MethodInfo { public override MethodInfo MakeGenericMethod(params Type[] typeArguments); } public class ModuleBuilder : Module { public override string FullyQualifiedName { get; } public override string Name { get; } } public sealed class TypeBuilder : TypeInfo { - public Type? CreateType(); + public Type CreateType(); - public TypeInfo? CreateTypeInfo(); + public TypeInfo CreateTypeInfo(); public override Type MakeArrayType(); public override Type MakeArrayType(int rank); public override Type MakeGenericType(params Type[] typeArguments); } }","title":"System.Reflection.Emit"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.Emit/#systemreflectionemit","text":"namespace System.Reflection.Emit { public sealed class AssemblyBuilder : Assembly { public override string? CodeBase { get; } public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access); public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder>? assemblyAttributes); } public sealed class DynamicMethod : MethodInfo { public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type? returnType, Type[]? parameterTypes, Module m, bool skipVisibility); public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type? returnType, Type[]? parameterTypes, Type owner, bool skipVisibility); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, bool restrictedSkipVisibility); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Module m); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Module m, bool skipVisibility); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Type owner); public DynamicMethod(string name, Type? returnType, Type[]? parameterTypes, Type owner, bool skipVisibility); } public sealed class EnumBuilder : TypeInfo { - public Type? CreateType(); + public Type CreateType(); - public TypeInfo? CreateTypeInfo(); + public TypeInfo CreateTypeInfo(); public override Type MakeArrayType(); public override Type MakeArrayType(int rank); } public sealed class GenericTypeParameterBuilder : TypeInfo { public override Type MakeArrayType(); public override Type MakeArrayType(int rank); public override Type MakeGenericType(params Type[] typeArguments); } public class ILGenerator { - public virtual void BeginCatchBlock(Type exceptionType); + public virtual void BeginCatchBlock(Type? exceptionType); } public sealed class MethodBuilder : MethodInfo { public override MethodInfo MakeGenericMethod(params Type[] typeArguments); } public class ModuleBuilder : Module { public override string FullyQualifiedName { get; } public override string Name { get; } } public sealed class TypeBuilder : TypeInfo { - public Type? CreateType(); + public Type CreateType(); - public TypeInfo? CreateTypeInfo(); + public TypeInfo CreateTypeInfo(); public override Type MakeArrayType(); public override Type MakeArrayType(int rank); public override Type MakeGenericType(params Type[] typeArguments); } }","title":"System.Reflection.Emit"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.Metadata.Ecma335/","text":"System.Reflection.Metadata.Ecma335 namespace System.Reflection.Metadata.Ecma335 { public readonly struct BlobEncoder { + public FieldTypeEncoder Field(); } public sealed class ControlFlowBuilder { + public void Clear(); } + public readonly struct FieldTypeEncoder { + public FieldTypeEncoder(BlobBuilder builder); + public BlobBuilder Builder { get; } + public CustomModifiersEncoder CustomModifiers(); + public SignatureTypeEncoder Type(bool isByRef = false); + public void TypedReference(); + } }","title":"System.Reflection.Metadata.Ecma335"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.Metadata.Ecma335/#systemreflectionmetadataecma335","text":"namespace System.Reflection.Metadata.Ecma335 { public readonly struct BlobEncoder { + public FieldTypeEncoder Field(); } public sealed class ControlFlowBuilder { + public void Clear(); } + public readonly struct FieldTypeEncoder { + public FieldTypeEncoder(BlobBuilder builder); + public BlobBuilder Builder { get; } + public CustomModifiersEncoder CustomModifiers(); + public SignatureTypeEncoder Type(bool isByRef = false); + public void TypedReference(); + } }","title":"System.Reflection.Metadata.Ecma335"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.Metadata/","text":"System.Reflection.Metadata namespace System.Reflection.Metadata { public sealed class MetadataReader { + public static AssemblyName GetAssemblyName(string assemblyFile); } }","title":"System.Reflection.Metadata"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.Metadata/#systemreflectionmetadata","text":"namespace System.Reflection.Metadata { public sealed class MetadataReader { + public static AssemblyName GetAssemblyName(string assemblyFile); } }","title":"System.Reflection.Metadata"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.PortableExecutable/","text":"System.Reflection.PortableExecutable namespace System.Reflection.PortableExecutable { public enum Machine : ushort { + LoongArch32 = (ushort)25138, + LoongArch64 = (ushort)25188, } }","title":"System.Reflection.PortableExecutable"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection.PortableExecutable/#systemreflectionportableexecutable","text":"namespace System.Reflection.PortableExecutable { public enum Machine : ushort { + LoongArch32 = (ushort)25138, + LoongArch64 = (ushort)25188, } }","title":"System.Reflection.PortableExecutable"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection/","text":"System.Reflection namespace System.Reflection { public sealed class AssemblyName : ICloneable, IDeserializationCallback, ISerializable { public string CodeBase { get; set; } public string EscapedCodeBase { get; } public AssemblyHashAlgorithm HashAlgorithm { get; set; } public ProcessorArchitecture ProcessorArchitecture { get; set; } public AssemblyVersionCompatibility VersionCompatibility { get; set; } } - public readonly struct CustomAttributeNamedArgument { + public readonly struct CustomAttributeNamedArgument : IEquatable<CustomAttributeNamedArgument> { public override bool Equals(object? obj); + public bool Equals(CustomAttributeNamedArgument other); } - public readonly struct CustomAttributeTypedArgument { + public readonly struct CustomAttributeTypedArgument : IEquatable<CustomAttributeTypedArgument> { public override bool Equals(object? obj); + public bool Equals(CustomAttributeTypedArgument other); } public abstract class DispatchProxy { public static T Create<T, TProxy>() where TProxy : DispatchProxy; } public abstract class MethodBase : MemberInfo { public static MethodBase GetCurrentMethod(); } public abstract class MethodInfo : MethodBase { public virtual MethodInfo MakeGenericMethod(params Type[] typeArguments); } public sealed class NullabilityInfo { public NullabilityInfo? ElementType { get; } public NullabilityInfo[] GenericTypeArguments { get; } public NullabilityState ReadState { get; } public Type Type { get; } public NullabilityState WriteState { get; } } public class TypeDelegator : TypeInfo { + public override MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member); } }","title":"System.Reflection"},{"location":"Microsoft.NETCore.App/7.0_System.Reflection/#systemreflection","text":"namespace System.Reflection { public sealed class AssemblyName : ICloneable, IDeserializationCallback, ISerializable { public string CodeBase { get; set; } public string EscapedCodeBase { get; } public AssemblyHashAlgorithm HashAlgorithm { get; set; } public ProcessorArchitecture ProcessorArchitecture { get; set; } public AssemblyVersionCompatibility VersionCompatibility { get; set; } } - public readonly struct CustomAttributeNamedArgument { + public readonly struct CustomAttributeNamedArgument : IEquatable<CustomAttributeNamedArgument> { public override bool Equals(object? obj); + public bool Equals(CustomAttributeNamedArgument other); } - public readonly struct CustomAttributeTypedArgument { + public readonly struct CustomAttributeTypedArgument : IEquatable<CustomAttributeTypedArgument> { public override bool Equals(object? obj); + public bool Equals(CustomAttributeTypedArgument other); } public abstract class DispatchProxy { public static T Create<T, TProxy>() where TProxy : DispatchProxy; } public abstract class MethodBase : MemberInfo { public static MethodBase GetCurrentMethod(); } public abstract class MethodInfo : MethodBase { public virtual MethodInfo MakeGenericMethod(params Type[] typeArguments); } public sealed class NullabilityInfo { public NullabilityInfo? ElementType { get; } public NullabilityInfo[] GenericTypeArguments { get; } public NullabilityState ReadState { get; } public Type Type { get; } public NullabilityState WriteState { get; } } public class TypeDelegator : TypeInfo { + public override MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member); } }","title":"System.Reflection"},{"location":"Microsoft.NETCore.App/7.0_System.Resources/","text":"System.Resources namespace System.Resources { public class ResourceManager }","title":"System.Resources"},{"location":"Microsoft.NETCore.App/7.0_System.Resources/#systemresources","text":"namespace System.Resources { public class ResourceManager }","title":"System.Resources"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.CompilerServices/","text":"System.Runtime.CompilerServices namespace System.Runtime.CompilerServices { + public sealed class CompilerFeatureRequiredAttribute : Attribute { + public const string RefStructs = \"RefStructs\"; + public const string RequiredMembers = \"RequiredMembers\"; + public CompilerFeatureRequiredAttribute(string featureName); + public string FeatureName { get; } + public bool IsOptional { get; set; } + } public sealed class ConditionalWeakTable<TKey, TValue> : IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>> where TKey : class where TValue : class? { + public bool TryAdd(TKey key, TValue value); } + public sealed class DisableRuntimeMarshallingAttribute : Attribute { + public DisableRuntimeMarshallingAttribute(); + } public static class FormattableStringFactory { public static FormattableString Create(string format, params object?[] arguments); } + public class MetadataUpdateOriginalTypeAttribute : Attribute { + public MetadataUpdateOriginalTypeAttribute(Type originalType); + public Type OriginalType { get; } + } + public sealed class RequiredMemberAttribute : Attribute { + public RequiredMemberAttribute(); + } public class RuleCache<T> where T : class public static class RuntimeFeature { + public const string ByRefFields = \"ByRefFields\"; + public const string NumericIntPtr = \"NumericIntPtr\"; public const string VirtualStaticsInInterfaces = \"VirtualStaticsInInterfaces\"; } public static class RuntimeHelpers { + public static ReadOnlySpan<T> CreateSpan<T>(RuntimeFieldHandle fldHandle); } public static class Unsafe { public unsafe static void* Add<T>(void* source, int elementOffset); public static ref T Add<T>(ref T source, UIntPtr elementOffset); public static ref T AddByteOffset<T>(ref T source, UIntPtr byteOffset); public unsafe static void* AsPointer<T>(ref T value); public unsafe static ref T AsRef<T>(void* source); public unsafe static void Copy<T>(void* destination, ref T source); public unsafe static void Copy<T>(ref T destination, void* source); public static void CopyBlock(ref byte destination, ref byte source, uint byteCount); public unsafe static void CopyBlock(void* destination, void* source, uint byteCount); public static void CopyBlockUnaligned(ref byte destination, ref byte source, uint byteCount); public unsafe static void CopyBlockUnaligned(void* destination, void* source, uint byteCount); public static void InitBlock(ref byte startAddress, byte value, uint byteCount); public unsafe static void InitBlock(void* startAddress, byte value, uint byteCount); public static void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount); public unsafe static void InitBlockUnaligned(void* startAddress, byte value, uint byteCount); public unsafe static T Read<T>(void* source); public unsafe static T ReadUnaligned<T>(void* source); public unsafe static void* Subtract<T>(void* source, int elementOffset); public static ref T Subtract<T>(ref T source, UIntPtr elementOffset); public static ref T SubtractByteOffset<T>(ref T source, UIntPtr byteOffset); public unsafe static void Write<T>(void* destination, T value); public unsafe static void WriteUnaligned<T>(void* destination, T value); } }","title":"System.Runtime.CompilerServices"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.CompilerServices/#systemruntimecompilerservices","text":"namespace System.Runtime.CompilerServices { + public sealed class CompilerFeatureRequiredAttribute : Attribute { + public const string RefStructs = \"RefStructs\"; + public const string RequiredMembers = \"RequiredMembers\"; + public CompilerFeatureRequiredAttribute(string featureName); + public string FeatureName { get; } + public bool IsOptional { get; set; } + } public sealed class ConditionalWeakTable<TKey, TValue> : IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>> where TKey : class where TValue : class? { + public bool TryAdd(TKey key, TValue value); } + public sealed class DisableRuntimeMarshallingAttribute : Attribute { + public DisableRuntimeMarshallingAttribute(); + } public static class FormattableStringFactory { public static FormattableString Create(string format, params object?[] arguments); } + public class MetadataUpdateOriginalTypeAttribute : Attribute { + public MetadataUpdateOriginalTypeAttribute(Type originalType); + public Type OriginalType { get; } + } + public sealed class RequiredMemberAttribute : Attribute { + public RequiredMemberAttribute(); + } public class RuleCache<T> where T : class public static class RuntimeFeature { + public const string ByRefFields = \"ByRefFields\"; + public const string NumericIntPtr = \"NumericIntPtr\"; public const string VirtualStaticsInInterfaces = \"VirtualStaticsInInterfaces\"; } public static class RuntimeHelpers { + public static ReadOnlySpan<T> CreateSpan<T>(RuntimeFieldHandle fldHandle); } public static class Unsafe { public unsafe static void* Add<T>(void* source, int elementOffset); public static ref T Add<T>(ref T source, UIntPtr elementOffset); public static ref T AddByteOffset<T>(ref T source, UIntPtr byteOffset); public unsafe static void* AsPointer<T>(ref T value); public unsafe static ref T AsRef<T>(void* source); public unsafe static void Copy<T>(void* destination, ref T source); public unsafe static void Copy<T>(ref T destination, void* source); public static void CopyBlock(ref byte destination, ref byte source, uint byteCount); public unsafe static void CopyBlock(void* destination, void* source, uint byteCount); public static void CopyBlockUnaligned(ref byte destination, ref byte source, uint byteCount); public unsafe static void CopyBlockUnaligned(void* destination, void* source, uint byteCount); public static void InitBlock(ref byte startAddress, byte value, uint byteCount); public unsafe static void InitBlock(void* startAddress, byte value, uint byteCount); public static void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount); public unsafe static void InitBlockUnaligned(void* startAddress, byte value, uint byteCount); public unsafe static T Read<T>(void* source); public unsafe static T ReadUnaligned<T>(void* source); public unsafe static void* Subtract<T>(void* source, int elementOffset); public static ref T Subtract<T>(ref T source, UIntPtr elementOffset); public static ref T SubtractByteOffset<T>(ref T source, UIntPtr byteOffset); public unsafe static void Write<T>(void* destination, T value); public unsafe static void WriteUnaligned<T>(void* destination, T value); } }","title":"System.Runtime.CompilerServices"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices.ComTypes/","text":"System.Runtime.InteropServices.ComTypes namespace System.Runtime.InteropServices.ComTypes { public interface IDataObject }","title":"System.Runtime.InteropServices.ComTypes"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices.ComTypes/#systemruntimeinteropservicescomtypes","text":"namespace System.Runtime.InteropServices.ComTypes { public interface IDataObject }","title":"System.Runtime.InteropServices.ComTypes"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices.JavaScript/","text":"System.Runtime.InteropServices.JavaScript +namespace System.Runtime.InteropServices.JavaScript { + public sealed class JSException : Exception { + public JSException(string msg); + } + public sealed class JSExportAttribute : Attribute { + public JSExportAttribute(); + } + public sealed class JSFunctionBinding { + public JSFunctionBinding(); + public static JSFunctionBinding BindJSFunction(string functionName, string moduleName, ReadOnlySpan<JSMarshalerType> signatures); + public static JSFunctionBinding BindManagedFunction(string fullyQualifiedName, int signatureHash, ReadOnlySpan<JSMarshalerType> signatures); + public static void InvokeJS(JSFunctionBinding signature, Span<JSMarshalerArgument> arguments); + } + public static class JSHost { + public static JSObject DotnetInstance { get; } + public static JSObject GlobalThis { get; } + public static Task<JSObject> ImportAsync(string moduleName, string moduleUrl, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class JSImportAttribute : Attribute { + public JSImportAttribute(string functionName); + public JSImportAttribute(string functionName, string moduleName); + public string FunctionName { get; } + public string? ModuleName { get; } + } + public sealed class JSMarshalAsAttribute<T> : Attribute where T : JSType { + public JSMarshalAsAttribute(); + } + public struct JSMarshalerArgument { + public void Initialize(); + public void ToJS(Action value); + public void ToJS(ArraySegment<byte> value); + public void ToJS(ArraySegment<double> value); + public void ToJS(ArraySegment<int> value); + public void ToJS(bool value); + public void ToJS(byte value); + public void ToJS(byte[] value); + public void ToJS(char value); + public void ToJS(DateTime value); + public void ToJS(DateTimeOffset value); + public void ToJS(double value); + public void ToJS(double[] value); + public void ToJS(Exception value); + public void ToJS(short value); + public void ToJS(int value); + public void ToJS(int[] value); + public void ToJS(long value); + public void ToJS(IntPtr value); + public void ToJS(bool? value); + public void ToJS(byte? value); + public void ToJS(char? value); + public void ToJS(DateTime? value); + public void ToJS(DateTimeOffset? value); + public void ToJS(double? value); + public void ToJS(short? value); + public void ToJS(int? value); + public void ToJS(long? value); + public void ToJS(IntPtr? value); + public void ToJS(float? value); + public void ToJS(object value); + public void ToJS(object[] value); + public void ToJS(JSObject value); + public void ToJS(JSObject[] value); + public void ToJS(float value); + public void ToJS(Span<byte> value); + public void ToJS(Span<double> value); + public void ToJS(Span<int> value); + public void ToJS(string value); + public void ToJS(string[] value); + public void ToJS(Task value); + public unsafe void ToJS(void* value); + public void ToJS<T, TResult>(Func<T, TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<T> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJS<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T3> arg3Marshaler, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJS<T1, T2, T3>(Action<T1, T2, T3>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T3> arg3Marshaler); + public void ToJS<T1, T2, TResult>(Func<T1, T2, TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJS<T1, T2>(Action<T1, T2>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler); + public void ToJS<T>(Action<T>? value, JSMarshalerArgument.ArgumentToManagedCallback<T> arg1Marshaler); + public void ToJS<T>(Task<T>? value, JSMarshalerArgument.ArgumentToJSCallback<T> marshaler); + public void ToJS<TResult>(Func<TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJSBig(long value); + public void ToJSBig(long? value); + public void ToManaged(out Action value); + public void ToManaged(out ArraySegment<byte> value); + public void ToManaged(out ArraySegment<double> value); + public void ToManaged(out ArraySegment<int> value); + public void ToManaged(out bool value); + public void ToManaged(out byte value); + public void ToManaged(out byte[] value); + public void ToManaged(out char value); + public void ToManaged(out DateTime value); + public void ToManaged(out DateTimeOffset value); + public void ToManaged(out double value); + public void ToManaged(out double[] value); + public void ToManaged(out Exception value); + public void ToManaged(out short value); + public void ToManaged(out int value); + public void ToManaged(out int[] value); + public void ToManaged(out long value); + public void ToManaged(out IntPtr value); + public void ToManaged(out bool? value); + public void ToManaged(out byte? value); + public void ToManaged(out char? value); + public void ToManaged(out DateTime? value); + public void ToManaged(out DateTimeOffset? value); + public void ToManaged(out double? value); + public void ToManaged(out short? value); + public void ToManaged(out int? value); + public void ToManaged(out long? value); + public void ToManaged(out IntPtr? value); + public void ToManaged(out float? value); + public void ToManaged(out object value); + public void ToManaged(out object[] value); + public void ToManaged(out JSObject value); + public void ToManaged(out JSObject[] value); + public void ToManaged(out float value); + public void ToManaged(out Span<byte> value); + public void ToManaged(out Span<double> value); + public void ToManaged(out Span<int> value); + public void ToManaged(out string value); + public void ToManaged(out string[] value); + public void ToManaged(out Task value); + public unsafe void ToManaged(out void* value); + public void ToManaged<T, TResult>(out Func<T, TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<T> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManaged<T1, T2, T3, TResult>(out Func<T1, T2, T3, TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T3> arg3Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManaged<T1, T2, T3>(out Action<T1, T2, T3>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T3> arg3Marshaler); + public void ToManaged<T1, T2, TResult>(out Func<T1, T2, TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManaged<T1, T2>(out Action<T1, T2>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler); + public void ToManaged<T>(out Action<T>? value, JSMarshalerArgument.ArgumentToJSCallback<T> arg1Marshaler); + public void ToManaged<T>(out Task<T>? value, JSMarshalerArgument.ArgumentToManagedCallback<T> marshaler); + public void ToManaged<TResult>(out Func<TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManagedBig(out long value); + public void ToManagedBig(out long? value); + public delegate void ArgumentToJSCallback<T>(ref JSMarshalerArgument arg, T value); + public delegate void ArgumentToManagedCallback<T>(ref JSMarshalerArgument arg, out T value); + } + public sealed class JSMarshalerType { + public static JSMarshalerType BigInt64 { get; } + public static JSMarshalerType Boolean { get; } + public static JSMarshalerType Byte { get; } + public static JSMarshalerType Char { get; } + public static JSMarshalerType DateTime { get; } + public static JSMarshalerType DateTimeOffset { get; } + public static JSMarshalerType Discard { get; } + public static JSMarshalerType Double { get; } + public static JSMarshalerType Exception { get; } + public static JSMarshalerType Int16 { get; } + public static JSMarshalerType Int32 { get; } + public static JSMarshalerType Int52 { get; } + public static JSMarshalerType IntPtr { get; } + public static JSMarshalerType JSObject { get; } + public static JSMarshalerType Object { get; } + public static JSMarshalerType Single { get; } + public static JSMarshalerType String { get; } + public static JSMarshalerType Void { get; } + public static JSMarshalerType Action(); + public static JSMarshalerType Action(JSMarshalerType arg1); + public static JSMarshalerType Action(JSMarshalerType arg1, JSMarshalerType arg2); + public static JSMarshalerType Action(JSMarshalerType arg1, JSMarshalerType arg2, JSMarshalerType arg3); + public static JSMarshalerType Array(JSMarshalerType element); + public static JSMarshalerType ArraySegment(JSMarshalerType element); + public static JSMarshalerType Function(JSMarshalerType result); + public static JSMarshalerType Function(JSMarshalerType arg1, JSMarshalerType result); + public static JSMarshalerType Function(JSMarshalerType arg1, JSMarshalerType arg2, JSMarshalerType result); + public static JSMarshalerType Function(JSMarshalerType arg1, JSMarshalerType arg2, JSMarshalerType arg3, JSMarshalerType result); + public static JSMarshalerType Nullable(JSMarshalerType primitive); + public static JSMarshalerType Span(JSMarshalerType element); + public static JSMarshalerType Task(); + public static JSMarshalerType Task(JSMarshalerType result); + } + public class JSObject : IDisposable { + public bool IsDisposed { get; } + public void Dispose(); + public bool GetPropertyAsBoolean(string propertyName); + public byte[]? GetPropertyAsByteArray(string propertyName); + public double GetPropertyAsDouble(string propertyName); + public int GetPropertyAsInt32(string propertyName); + public JSObject? GetPropertyAsJSObject(string propertyName); + public string? GetPropertyAsString(string propertyName); + public string GetTypeOfProperty(string propertyName); + public bool HasProperty(string propertyName); + public void SetProperty(string propertyName, bool value); + public void SetProperty(string propertyName, byte[]? value); + public void SetProperty(string propertyName, double value); + public void SetProperty(string propertyName, int value); + public void SetProperty(string propertyName, JSObject? value); + public void SetProperty(string propertyName, string? value); + } + public abstract class JSType { + public sealed class Any : JSType + public sealed class Array<T> : JSType where T : JSType + public sealed class BigInt : JSType + public sealed class Boolean : JSType + public sealed class Date : JSType + public sealed class Discard : JSType + public sealed class Error : JSType + public sealed class Function : JSType + public sealed class Function<T> : JSType where T : JSType + public sealed class Function<T1, T2> : JSType where T1 : JSType where T2 : JSType + public sealed class Function<T1, T2, T3> : JSType where T1 : JSType where T2 : JSType where T3 : JSType + public sealed class Function<T1, T2, T3, T4> : JSType where T1 : JSType where T2 : JSType where T3 : JSType where T4 : JSType + public sealed class MemoryView : JSType + public sealed class Number : JSType + public sealed class Object : JSType + public sealed class Promise<T> : JSType where T : JSType + public sealed class String : JSType + public sealed class Void : JSType + } +}","title":"System.Runtime.InteropServices.JavaScript"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices.JavaScript/#systemruntimeinteropservicesjavascript","text":"+namespace System.Runtime.InteropServices.JavaScript { + public sealed class JSException : Exception { + public JSException(string msg); + } + public sealed class JSExportAttribute : Attribute { + public JSExportAttribute(); + } + public sealed class JSFunctionBinding { + public JSFunctionBinding(); + public static JSFunctionBinding BindJSFunction(string functionName, string moduleName, ReadOnlySpan<JSMarshalerType> signatures); + public static JSFunctionBinding BindManagedFunction(string fullyQualifiedName, int signatureHash, ReadOnlySpan<JSMarshalerType> signatures); + public static void InvokeJS(JSFunctionBinding signature, Span<JSMarshalerArgument> arguments); + } + public static class JSHost { + public static JSObject DotnetInstance { get; } + public static JSObject GlobalThis { get; } + public static Task<JSObject> ImportAsync(string moduleName, string moduleUrl, CancellationToken cancellationToken = default(CancellationToken)); + } + public sealed class JSImportAttribute : Attribute { + public JSImportAttribute(string functionName); + public JSImportAttribute(string functionName, string moduleName); + public string FunctionName { get; } + public string? ModuleName { get; } + } + public sealed class JSMarshalAsAttribute<T> : Attribute where T : JSType { + public JSMarshalAsAttribute(); + } + public struct JSMarshalerArgument { + public void Initialize(); + public void ToJS(Action value); + public void ToJS(ArraySegment<byte> value); + public void ToJS(ArraySegment<double> value); + public void ToJS(ArraySegment<int> value); + public void ToJS(bool value); + public void ToJS(byte value); + public void ToJS(byte[] value); + public void ToJS(char value); + public void ToJS(DateTime value); + public void ToJS(DateTimeOffset value); + public void ToJS(double value); + public void ToJS(double[] value); + public void ToJS(Exception value); + public void ToJS(short value); + public void ToJS(int value); + public void ToJS(int[] value); + public void ToJS(long value); + public void ToJS(IntPtr value); + public void ToJS(bool? value); + public void ToJS(byte? value); + public void ToJS(char? value); + public void ToJS(DateTime? value); + public void ToJS(DateTimeOffset? value); + public void ToJS(double? value); + public void ToJS(short? value); + public void ToJS(int? value); + public void ToJS(long? value); + public void ToJS(IntPtr? value); + public void ToJS(float? value); + public void ToJS(object value); + public void ToJS(object[] value); + public void ToJS(JSObject value); + public void ToJS(JSObject[] value); + public void ToJS(float value); + public void ToJS(Span<byte> value); + public void ToJS(Span<double> value); + public void ToJS(Span<int> value); + public void ToJS(string value); + public void ToJS(string[] value); + public void ToJS(Task value); + public unsafe void ToJS(void* value); + public void ToJS<T, TResult>(Func<T, TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<T> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJS<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T3> arg3Marshaler, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJS<T1, T2, T3>(Action<T1, T2, T3>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T3> arg3Marshaler); + public void ToJS<T1, T2, TResult>(Func<T1, T2, TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJS<T1, T2>(Action<T1, T2>? value, JSMarshalerArgument.ArgumentToManagedCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<T2> arg2Marshaler); + public void ToJS<T>(Action<T>? value, JSMarshalerArgument.ArgumentToManagedCallback<T> arg1Marshaler); + public void ToJS<T>(Task<T>? value, JSMarshalerArgument.ArgumentToJSCallback<T> marshaler); + public void ToJS<TResult>(Func<TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<TResult> resMarshaler); + public void ToJSBig(long value); + public void ToJSBig(long? value); + public void ToManaged(out Action value); + public void ToManaged(out ArraySegment<byte> value); + public void ToManaged(out ArraySegment<double> value); + public void ToManaged(out ArraySegment<int> value); + public void ToManaged(out bool value); + public void ToManaged(out byte value); + public void ToManaged(out byte[] value); + public void ToManaged(out char value); + public void ToManaged(out DateTime value); + public void ToManaged(out DateTimeOffset value); + public void ToManaged(out double value); + public void ToManaged(out double[] value); + public void ToManaged(out Exception value); + public void ToManaged(out short value); + public void ToManaged(out int value); + public void ToManaged(out int[] value); + public void ToManaged(out long value); + public void ToManaged(out IntPtr value); + public void ToManaged(out bool? value); + public void ToManaged(out byte? value); + public void ToManaged(out char? value); + public void ToManaged(out DateTime? value); + public void ToManaged(out DateTimeOffset? value); + public void ToManaged(out double? value); + public void ToManaged(out short? value); + public void ToManaged(out int? value); + public void ToManaged(out long? value); + public void ToManaged(out IntPtr? value); + public void ToManaged(out float? value); + public void ToManaged(out object value); + public void ToManaged(out object[] value); + public void ToManaged(out JSObject value); + public void ToManaged(out JSObject[] value); + public void ToManaged(out float value); + public void ToManaged(out Span<byte> value); + public void ToManaged(out Span<double> value); + public void ToManaged(out Span<int> value); + public void ToManaged(out string value); + public void ToManaged(out string[] value); + public void ToManaged(out Task value); + public unsafe void ToManaged(out void* value); + public void ToManaged<T, TResult>(out Func<T, TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<T> arg1Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManaged<T1, T2, T3, TResult>(out Func<T1, T2, T3, TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T3> arg3Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManaged<T1, T2, T3>(out Action<T1, T2, T3>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T3> arg3Marshaler); + public void ToManaged<T1, T2, TResult>(out Func<T1, T2, TResult>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManaged<T1, T2>(out Action<T1, T2>? value, JSMarshalerArgument.ArgumentToJSCallback<T1> arg1Marshaler, JSMarshalerArgument.ArgumentToJSCallback<T2> arg2Marshaler); + public void ToManaged<T>(out Action<T>? value, JSMarshalerArgument.ArgumentToJSCallback<T> arg1Marshaler); + public void ToManaged<T>(out Task<T>? value, JSMarshalerArgument.ArgumentToManagedCallback<T> marshaler); + public void ToManaged<TResult>(out Func<TResult>? value, JSMarshalerArgument.ArgumentToManagedCallback<TResult> resMarshaler); + public void ToManagedBig(out long value); + public void ToManagedBig(out long? value); + public delegate void ArgumentToJSCallback<T>(ref JSMarshalerArgument arg, T value); + public delegate void ArgumentToManagedCallback<T>(ref JSMarshalerArgument arg, out T value); + } + public sealed class JSMarshalerType { + public static JSMarshalerType BigInt64 { get; } + public static JSMarshalerType Boolean { get; } + public static JSMarshalerType Byte { get; } + public static JSMarshalerType Char { get; } + public static JSMarshalerType DateTime { get; } + public static JSMarshalerType DateTimeOffset { get; } + public static JSMarshalerType Discard { get; } + public static JSMarshalerType Double { get; } + public static JSMarshalerType Exception { get; } + public static JSMarshalerType Int16 { get; } + public static JSMarshalerType Int32 { get; } + public static JSMarshalerType Int52 { get; } + public static JSMarshalerType IntPtr { get; } + public static JSMarshalerType JSObject { get; } + public static JSMarshalerType Object { get; } + public static JSMarshalerType Single { get; } + public static JSMarshalerType String { get; } + public static JSMarshalerType Void { get; } + public static JSMarshalerType Action(); + public static JSMarshalerType Action(JSMarshalerType arg1); + public static JSMarshalerType Action(JSMarshalerType arg1, JSMarshalerType arg2); + public static JSMarshalerType Action(JSMarshalerType arg1, JSMarshalerType arg2, JSMarshalerType arg3); + public static JSMarshalerType Array(JSMarshalerType element); + public static JSMarshalerType ArraySegment(JSMarshalerType element); + public static JSMarshalerType Function(JSMarshalerType result); + public static JSMarshalerType Function(JSMarshalerType arg1, JSMarshalerType result); + public static JSMarshalerType Function(JSMarshalerType arg1, JSMarshalerType arg2, JSMarshalerType result); + public static JSMarshalerType Function(JSMarshalerType arg1, JSMarshalerType arg2, JSMarshalerType arg3, JSMarshalerType result); + public static JSMarshalerType Nullable(JSMarshalerType primitive); + public static JSMarshalerType Span(JSMarshalerType element); + public static JSMarshalerType Task(); + public static JSMarshalerType Task(JSMarshalerType result); + } + public class JSObject : IDisposable { + public bool IsDisposed { get; } + public void Dispose(); + public bool GetPropertyAsBoolean(string propertyName); + public byte[]? GetPropertyAsByteArray(string propertyName); + public double GetPropertyAsDouble(string propertyName); + public int GetPropertyAsInt32(string propertyName); + public JSObject? GetPropertyAsJSObject(string propertyName); + public string? GetPropertyAsString(string propertyName); + public string GetTypeOfProperty(string propertyName); + public bool HasProperty(string propertyName); + public void SetProperty(string propertyName, bool value); + public void SetProperty(string propertyName, byte[]? value); + public void SetProperty(string propertyName, double value); + public void SetProperty(string propertyName, int value); + public void SetProperty(string propertyName, JSObject? value); + public void SetProperty(string propertyName, string? value); + } + public abstract class JSType { + public sealed class Any : JSType + public sealed class Array<T> : JSType where T : JSType + public sealed class BigInt : JSType + public sealed class Boolean : JSType + public sealed class Date : JSType + public sealed class Discard : JSType + public sealed class Error : JSType + public sealed class Function : JSType + public sealed class Function<T> : JSType where T : JSType + public sealed class Function<T1, T2> : JSType where T1 : JSType where T2 : JSType + public sealed class Function<T1, T2, T3> : JSType where T1 : JSType where T2 : JSType where T3 : JSType + public sealed class Function<T1, T2, T3, T4> : JSType where T1 : JSType where T2 : JSType where T3 : JSType where T4 : JSType + public sealed class MemoryView : JSType + public sealed class Number : JSType + public sealed class Object : JSType + public sealed class Promise<T> : JSType where T : JSType + public sealed class String : JSType + public sealed class Void : JSType + } +}","title":"System.Runtime.InteropServices.JavaScript"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices.Marshalling/","text":"System.Runtime.InteropServices.Marshalling +namespace System.Runtime.InteropServices.Marshalling { + public static class AnsiStringMarshaller { + public unsafe static string? ConvertToManaged(byte* unmanaged); + public unsafe static byte* ConvertToUnmanaged(string? managed); + public unsafe static void Free(byte* unmanaged); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(string? managed, Span<byte> buffer); + public unsafe byte* ToUnmanaged(); + } + } + public static class ArrayMarshaller<T, TUnmanagedElement> where TUnmanagedElement : struct { + public unsafe static T[]? AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements); + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(T[]? managed, out int numElements); + public unsafe static void Free(TUnmanagedElement* unmanaged); + public static Span<T> GetManagedValuesDestination(T[]? managed); + public static ReadOnlySpan<T> GetManagedValuesSource(T[]? managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + public unsafe static ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanagedValue, int numElements); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(T[]? array, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<T> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref T GetPinnableReference(T[]? array); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + } + public static class BStrStringMarshaller { + public unsafe static string? ConvertToManaged(ushort* unmanaged); + public unsafe static ushort* ConvertToUnmanaged(string? managed); + public unsafe static void Free(ushort* unmanaged); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(string? managed, Span<byte> buffer); + public unsafe ushort* ToUnmanaged(); + } + } + public sealed class ContiguousCollectionMarshallerAttribute : Attribute { + public ContiguousCollectionMarshallerAttribute(); + } + public sealed class CustomMarshallerAttribute : Attribute { + public CustomMarshallerAttribute(Type managedType, MarshalMode marshalMode, Type marshallerType); + public Type ManagedType { get; } + public Type MarshallerType { get; } + public MarshalMode MarshalMode { get; } + public struct GenericPlaceholder + } + public enum MarshalMode { + Default = 0, + ElementIn = 7, + ElementOut = 9, + ElementRef = 8, + ManagedToUnmanagedIn = 1, + ManagedToUnmanagedOut = 3, + ManagedToUnmanagedRef = 2, + UnmanagedToManagedIn = 4, + UnmanagedToManagedOut = 6, + UnmanagedToManagedRef = 5, + } + public sealed class MarshalUsingAttribute : Attribute { + public const string ReturnsCountValue = \"return-value\"; + public MarshalUsingAttribute(); + public MarshalUsingAttribute(Type nativeType); + public int ConstantElementCount { get; set; } + public string CountElementName { get; set; } + public int ElementIndirectionDepth { get; set; } + public Type? NativeType { get; } + } + public sealed class NativeMarshallingAttribute : Attribute { + public NativeMarshallingAttribute(Type nativeType); + public Type NativeType { get; } + } + public static class PointerArrayMarshaller<T, TUnmanagedElement> where T : struct where TUnmanagedElement : struct { + public unsafe static T*[]? AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements); + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(T*[]? managed, out int numElements); + public unsafe static void Free(TUnmanagedElement* unmanaged); + public static Span<IntPtr> GetManagedValuesDestination(T*[]? managed); + public static ReadOnlySpan<IntPtr> GetManagedValuesSource(T*[]? managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + public unsafe static ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanagedValue, int numElements); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(T*[]? array, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<IntPtr> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref byte GetPinnableReference(T*[]? array); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + } + public static class ReadOnlySpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : struct { + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(ReadOnlySpan<T> managed, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<T> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref T GetPinnableReference(ReadOnlySpan<T> managed); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + public static class UnmanagedToManagedOut { + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(ReadOnlySpan<T> managed, out int numElements); + public static ReadOnlySpan<T> GetManagedValuesSource(ReadOnlySpan<T> managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + } + } + public static class SpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : struct { + public unsafe static Span<T> AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements); + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(Span<T> managed, out int numElements); + public unsafe static void Free(TUnmanagedElement* unmanaged); + public static Span<T> GetManagedValuesDestination(Span<T> managed); + public static ReadOnlySpan<T> GetManagedValuesSource(Span<T> managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + public unsafe static ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanaged, int numElements); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(Span<T> managed, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<T> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref T GetPinnableReference(Span<T> managed); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + } + public static class Utf16StringMarshaller { + public unsafe static string? ConvertToManaged(ushort* unmanaged); + public unsafe static ushort* ConvertToUnmanaged(string? managed); + public unsafe static void Free(ushort* unmanaged); + public static ref readonly char GetPinnableReference(string? str); + } + public static class Utf8StringMarshaller { + public unsafe static string? ConvertToManaged(byte* unmanaged); + public unsafe static byte* ConvertToUnmanaged(string? managed); + public unsafe static void Free(byte* unmanaged); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(string? managed, Span<byte> buffer); + public unsafe byte* ToUnmanaged(); + } + } +}","title":"System.Runtime.InteropServices.Marshalling"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices.Marshalling/#systemruntimeinteropservicesmarshalling","text":"+namespace System.Runtime.InteropServices.Marshalling { + public static class AnsiStringMarshaller { + public unsafe static string? ConvertToManaged(byte* unmanaged); + public unsafe static byte* ConvertToUnmanaged(string? managed); + public unsafe static void Free(byte* unmanaged); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(string? managed, Span<byte> buffer); + public unsafe byte* ToUnmanaged(); + } + } + public static class ArrayMarshaller<T, TUnmanagedElement> where TUnmanagedElement : struct { + public unsafe static T[]? AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements); + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(T[]? managed, out int numElements); + public unsafe static void Free(TUnmanagedElement* unmanaged); + public static Span<T> GetManagedValuesDestination(T[]? managed); + public static ReadOnlySpan<T> GetManagedValuesSource(T[]? managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + public unsafe static ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanagedValue, int numElements); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(T[]? array, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<T> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref T GetPinnableReference(T[]? array); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + } + public static class BStrStringMarshaller { + public unsafe static string? ConvertToManaged(ushort* unmanaged); + public unsafe static ushort* ConvertToUnmanaged(string? managed); + public unsafe static void Free(ushort* unmanaged); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(string? managed, Span<byte> buffer); + public unsafe ushort* ToUnmanaged(); + } + } + public sealed class ContiguousCollectionMarshallerAttribute : Attribute { + public ContiguousCollectionMarshallerAttribute(); + } + public sealed class CustomMarshallerAttribute : Attribute { + public CustomMarshallerAttribute(Type managedType, MarshalMode marshalMode, Type marshallerType); + public Type ManagedType { get; } + public Type MarshallerType { get; } + public MarshalMode MarshalMode { get; } + public struct GenericPlaceholder + } + public enum MarshalMode { + Default = 0, + ElementIn = 7, + ElementOut = 9, + ElementRef = 8, + ManagedToUnmanagedIn = 1, + ManagedToUnmanagedOut = 3, + ManagedToUnmanagedRef = 2, + UnmanagedToManagedIn = 4, + UnmanagedToManagedOut = 6, + UnmanagedToManagedRef = 5, + } + public sealed class MarshalUsingAttribute : Attribute { + public const string ReturnsCountValue = \"return-value\"; + public MarshalUsingAttribute(); + public MarshalUsingAttribute(Type nativeType); + public int ConstantElementCount { get; set; } + public string CountElementName { get; set; } + public int ElementIndirectionDepth { get; set; } + public Type? NativeType { get; } + } + public sealed class NativeMarshallingAttribute : Attribute { + public NativeMarshallingAttribute(Type nativeType); + public Type NativeType { get; } + } + public static class PointerArrayMarshaller<T, TUnmanagedElement> where T : struct where TUnmanagedElement : struct { + public unsafe static T*[]? AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements); + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(T*[]? managed, out int numElements); + public unsafe static void Free(TUnmanagedElement* unmanaged); + public static Span<IntPtr> GetManagedValuesDestination(T*[]? managed); + public static ReadOnlySpan<IntPtr> GetManagedValuesSource(T*[]? managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + public unsafe static ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanagedValue, int numElements); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(T*[]? array, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<IntPtr> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref byte GetPinnableReference(T*[]? array); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + } + public static class ReadOnlySpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : struct { + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(ReadOnlySpan<T> managed, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<T> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref T GetPinnableReference(ReadOnlySpan<T> managed); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + public static class UnmanagedToManagedOut { + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(ReadOnlySpan<T> managed, out int numElements); + public static ReadOnlySpan<T> GetManagedValuesSource(ReadOnlySpan<T> managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + } + } + public static class SpanMarshaller<T, TUnmanagedElement> where TUnmanagedElement : struct { + public unsafe static Span<T> AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements); + public unsafe static TUnmanagedElement* AllocateContainerForUnmanagedElements(Span<T> managed, out int numElements); + public unsafe static void Free(TUnmanagedElement* unmanaged); + public static Span<T> GetManagedValuesDestination(Span<T> managed); + public static ReadOnlySpan<T> GetManagedValuesSource(Span<T> managed); + public unsafe static Span<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements); + public unsafe static ReadOnlySpan<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanaged, int numElements); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(Span<T> managed, Span<TUnmanagedElement> buffer); + public ReadOnlySpan<T> GetManagedValuesSource(); + public ref TUnmanagedElement GetPinnableReference(); + public static ref T GetPinnableReference(Span<T> managed); + public Span<TUnmanagedElement> GetUnmanagedValuesDestination(); + public unsafe TUnmanagedElement* ToUnmanaged(); + } + } + public static class Utf16StringMarshaller { + public unsafe static string? ConvertToManaged(ushort* unmanaged); + public unsafe static ushort* ConvertToUnmanaged(string? managed); + public unsafe static void Free(ushort* unmanaged); + public static ref readonly char GetPinnableReference(string? str); + } + public static class Utf8StringMarshaller { + public unsafe static string? ConvertToManaged(byte* unmanaged); + public unsafe static byte* ConvertToUnmanaged(string? managed); + public unsafe static void Free(byte* unmanaged); + public ref struct ManagedToUnmanagedIn { + public static int BufferSize { get; } + public void Free(); + public void FromManaged(string? managed, Span<byte> buffer); + public unsafe byte* ToUnmanaged(); + } + } +}","title":"System.Runtime.InteropServices.Marshalling"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices/","text":"System.Runtime.InteropServices namespace System.Runtime.InteropServices { public enum Architecture { + Armv6 = 7, + LoongArch64 = 6, + Ppc64le = 8, } - public readonly struct ArrayWithOffset + public readonly struct ArrayWithOffset : IEquatable<ArrayWithOffset> public enum ClassInterfaceType { AutoDispatch = 1, AutoDual = 2, } - public struct GCHandle { + public struct GCHandle : IEquatable<GCHandle> { + public bool Equals(GCHandle other); } + public sealed class LibraryImportAttribute : Attribute { + public LibraryImportAttribute(string libraryName); + public string EntryPoint { get; set; } + public string LibraryName { get; } + public bool SetLastError { get; set; } + public StringMarshalling StringMarshalling { get; set; } + public Type StringMarshallingCustomType { get; set; } + } public static class Marshal { public static void DestroyStructure(IntPtr ptr, Type structuretype); public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t); public static IntPtr GetFunctionPointerForDelegate(Delegate d); public static IntPtr GetHINSTANCE(Module m); + public static string GetLastPInvokeErrorMessage(); + public static string GetPInvokeErrorMessage(int error); public static void PtrToStructure(IntPtr ptr, object structure); public static object? PtrToStructure(IntPtr ptr, Type structureType); public static byte ReadByte(object ptr, int ofs); public static short ReadInt16(object ptr, int ofs); public static int ReadInt32(object ptr, int ofs); public static long ReadInt64(object ptr, int ofs); public static IntPtr ReadIntPtr(object ptr, int ofs); public static int SizeOf(object structure); public static int SizeOf(Type t); public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld); public static void WriteByte(object ptr, int ofs, byte val); public static void WriteInt16(object ptr, int ofs, char val); public static void WriteInt16(object ptr, int ofs, short val); public static void WriteInt32(object ptr, int ofs, int val); public static void WriteInt64(object ptr, int ofs, long val); public static void WriteIntPtr(object ptr, int ofs, IntPtr val); } public static class NativeLibrary { + public static IntPtr GetMainProgramHandle(); } public static class NativeMemory { + public unsafe static void Clear(void* ptr, UIntPtr byteCount); + public unsafe static void Copy(void* source, void* destination, UIntPtr byteCount); + public unsafe static void Fill(void* ptr, UIntPtr byteCount, byte value); } - public readonly struct NFloat : IEquatable<NFloat> { + public readonly struct NFloat : IAdditionOperators<NFloat, NFloat, NFloat>, IAdditiveIdentity<NFloat, NFloat>, IBinaryFloatingPointIeee754<NFloat>, IBinaryNumber<NFloat>, IBitwiseOperators<NFloat, NFloat, NFloat>, IComparable, IComparable<NFloat>, IComparisonOperators<NFloat, NFloat, bool>, IDecrementOperators<NFloat>, IDivisionOperators<NFloat, NFloat, NFloat>, IEqualityOperators<NFloat, NFloat, bool>, IEquatable<NFloat>, IExponentialFunctions<NFloat>, IFloatingPoint<NFloat>, IFloatingPointConstants<NFloat>, IFloatingPointIeee754<NFloat>, IFormattable, IHyperbolicFunctions<NFloat>, IIncrementOperators<NFloat>, ILogarithmicFunctions<NFloat>, IMinMaxValue<NFloat>, IModulusOperators<NFloat, NFloat, NFloat>, IMultiplicativeIdentity<NFloat, NFloat>, IMultiplyOperators<NFloat, NFloat, NFloat>, INumber<NFloat>, INumberBase<NFloat>, IParsable<NFloat>, IPowerFunctions<NFloat>, IRootFunctions<NFloat>, ISignedNumber<NFloat>, ISpanFormattable, ISpanParsable<NFloat>, ISubtractionOperators<NFloat, NFloat, NFloat>, ITrigonometricFunctions<NFloat>, IUnaryNegationOperators<NFloat, NFloat>, IUnaryPlusOperators<NFloat, NFloat> { + public static NFloat E { get; } + public static NFloat Epsilon { get; } + public static NFloat MaxValue { get; } + public static NFloat MinValue { get; } + public static NFloat NaN { get; } + public static NFloat NegativeInfinity { get; } + public static NFloat NegativeZero { get; } + public static NFloat Pi { get; } + public static NFloat PositiveInfinity { get; } + public static int Size { get; } + static NFloat System.Numerics.IAdditiveIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.AdditiveIdentity { get; } + static NFloat System.Numerics.IBinaryNumber<System.Runtime.InteropServices.NFloat>.AllBitsSet { get; } + static NFloat System.Numerics.IMultiplicativeIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.MultiplicativeIdentity { get; } + static NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.One { get; } + static int System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.Radix { get; } + static NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.Zero { get; } + static NFloat System.Numerics.ISignedNumber<System.Runtime.InteropServices.NFloat>.NegativeOne { get; } + public static NFloat Tau { get; } + public static NFloat Abs(NFloat value); + public static NFloat Acos(NFloat x); + public static NFloat Acosh(NFloat x); + public static NFloat AcosPi(NFloat x); + public static NFloat Asin(NFloat x); + public static NFloat Asinh(NFloat x); + public static NFloat AsinPi(NFloat x); + public static NFloat Atan(NFloat x); + public static NFloat Atan2(NFloat y, NFloat x); + public static NFloat Atan2Pi(NFloat y, NFloat x); + public static NFloat Atanh(NFloat x); + public static NFloat AtanPi(NFloat x); + public static NFloat BitDecrement(NFloat x); + public static NFloat BitIncrement(NFloat x); + public static NFloat Cbrt(NFloat x); + public static NFloat Ceiling(NFloat x); + public static NFloat Clamp(NFloat value, NFloat min, NFloat max); + public int CompareTo(object? obj); + public int CompareTo(NFloat other); + public static NFloat CopySign(NFloat value, NFloat sign); + public static NFloat Cos(NFloat x); + public static NFloat Cosh(NFloat x); + public static NFloat CosPi(NFloat x); + public static NFloat CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static NFloat CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static NFloat CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static NFloat Exp(NFloat x); + public static NFloat Exp10(NFloat x); + public static NFloat Exp10M1(NFloat x); + public static NFloat Exp2(NFloat x); + public static NFloat Exp2M1(NFloat x); + public static NFloat ExpM1(NFloat x); + public static NFloat Floor(NFloat x); + public static NFloat FusedMultiplyAdd(NFloat left, NFloat right, NFloat addend); + public static NFloat Hypot(NFloat x, NFloat y); + public static NFloat Ieee754Remainder(NFloat left, NFloat right); + public static int ILogB(NFloat x); + public static bool IsEvenInteger(NFloat value); + public static bool IsFinite(NFloat value); + public static bool IsInfinity(NFloat value); + public static bool IsInteger(NFloat value); + public static bool IsNaN(NFloat value); + public static bool IsNegative(NFloat value); + public static bool IsNegativeInfinity(NFloat value); + public static bool IsNormal(NFloat value); + public static bool IsOddInteger(NFloat value); + public static bool IsPositive(NFloat value); + public static bool IsPositiveInfinity(NFloat value); + public static bool IsPow2(NFloat value); + public static bool IsRealNumber(NFloat value); + public static bool IsSubnormal(NFloat value); + public static NFloat Log(NFloat x); + public static NFloat Log(NFloat x, NFloat newBase); + public static NFloat Log10(NFloat x); + public static NFloat Log10P1(NFloat x); + public static NFloat Log2(NFloat value); + public static NFloat Log2P1(NFloat x); + public static NFloat LogP1(NFloat x); + public static NFloat Max(NFloat x, NFloat y); + public static NFloat MaxMagnitude(NFloat x, NFloat y); + public static NFloat MaxMagnitudeNumber(NFloat x, NFloat y); + public static NFloat MaxNumber(NFloat x, NFloat y); + public static NFloat Min(NFloat x, NFloat y); + public static NFloat MinMagnitude(NFloat x, NFloat y); + public static NFloat MinMagnitudeNumber(NFloat x, NFloat y); + public static NFloat MinNumber(NFloat x, NFloat y); + public static NFloat operator +(NFloat left, NFloat right); + public static explicit operator checked byte (NFloat value); + public static explicit operator checked char (NFloat value); + public static explicit operator checked short (NFloat value); + public static explicit operator checked int (NFloat value); + public static explicit operator checked long (NFloat value); + public static explicit operator checked Int128 (NFloat value); + public static explicit operator checked IntPtr (NFloat value); + public static explicit operator checked sbyte (NFloat value); + public static explicit operator checked ushort (NFloat value); + public static explicit operator checked uint (NFloat value); + public static explicit operator checked ulong (NFloat value); + public static explicit operator checked UInt128 (NFloat value); + public static explicit operator checked UIntPtr (NFloat value); + public static NFloat operator --(NFloat value); + public static NFloat operator /(NFloat left, NFloat right); + public static bool operator ==(NFloat left, NFloat right); + public static explicit operator NFloat (decimal value); + public static explicit operator NFloat (double value); + public static explicit operator NFloat (Int128 value); + public static explicit operator byte (NFloat value); + public static explicit operator char (NFloat value); + public static explicit operator decimal (NFloat value); + public static explicit operator Half (NFloat value); + public static explicit operator Int128 (NFloat value); + public static explicit operator short (NFloat value); + public static explicit operator int (NFloat value); + public static explicit operator long (NFloat value); + public static explicit operator IntPtr (NFloat value); + public static explicit operator sbyte (NFloat value); + public static explicit operator float (NFloat value); + public static explicit operator UInt128 (NFloat value); + public static explicit operator ushort (NFloat value); + public static explicit operator uint (NFloat value); + public static explicit operator ulong (NFloat value); + public static explicit operator UIntPtr (NFloat value); + public static explicit operator NFloat (UInt128 value); + public static bool operator >(NFloat left, NFloat right); + public static bool operator >=(NFloat left, NFloat right); + public static implicit operator NFloat (byte value); + public static implicit operator NFloat (char value); + public static implicit operator NFloat (Half value); + public static implicit operator NFloat (short value); + public static implicit operator NFloat (int value); + public static implicit operator NFloat (long value); + public static implicit operator NFloat (IntPtr value); + public static implicit operator double (NFloat value); + public static implicit operator NFloat (sbyte value); + public static implicit operator NFloat (float value); + public static implicit operator NFloat (ushort value); + public static implicit operator NFloat (uint value); + public static implicit operator NFloat (ulong value); + public static implicit operator NFloat (UIntPtr value); + public static NFloat operator ++(NFloat value); + public static bool operator !=(NFloat left, NFloat right); + public static bool operator <(NFloat left, NFloat right); + public static bool operator <=(NFloat left, NFloat right); + public static NFloat operator %(NFloat left, NFloat right); + public static NFloat operator *(NFloat left, NFloat right); + public static NFloat operator -(NFloat left, NFloat right); + public static NFloat operator -(NFloat value); + public static NFloat operator +(NFloat value); + public static NFloat Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent | NumberStyles.AllowLeadingSign | NumberStyles.AllowLeadingWhite | NumberStyles.AllowThousands | NumberStyles.AllowTrailingWhite, IFormatProvider? provider = null); + public static NFloat Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static NFloat Parse(string s); + public static NFloat Parse(string s, NumberStyles style); + public static NFloat Parse(string s, NumberStyles style, IFormatProvider? provider); + public static NFloat Parse(string s, IFormatProvider? provider); + public static NFloat Pow(NFloat x, NFloat y); + public static NFloat ReciprocalEstimate(NFloat x); + public static NFloat ReciprocalSqrtEstimate(NFloat x); + public static NFloat RootN(NFloat x, int n); + public static NFloat Round(NFloat x); + public static NFloat Round(NFloat x, int digits); + public static NFloat Round(NFloat x, int digits, MidpointRounding mode); + public static NFloat Round(NFloat x, MidpointRounding mode); + public static NFloat ScaleB(NFloat x, int n); + public static int Sign(NFloat value); + public static NFloat Sin(NFloat x); + public static (NFloat Sin, NFloat Cos) SinCos(NFloat x); + public static (NFloat SinPi, NFloat CosPi) SinCosPi(NFloat x); + public static NFloat Sinh(NFloat x); + public static NFloat SinPi(NFloat x); + public static NFloat Sqrt(NFloat x); + static NFloat IAdditionOperators<NFloat, NFloat, NFloat>.operator checked +(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator &(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator |(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator ^(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator ~(NFloat value); + static NFloat IDecrementOperators<NFloat>.operator checked --(NFloat value); + static NFloat IDivisionOperators<NFloat, NFloat, NFloat>.operator checked /(NFloat left, NFloat right); + int IFloatingPoint<NFloat>.GetExponentByteCount(); + int IFloatingPoint<NFloat>.GetExponentShortestBitLength(); + int IFloatingPoint<NFloat>.GetSignificandBitLength(); + int IFloatingPoint<NFloat>.GetSignificandByteCount(); + bool IFloatingPoint<NFloat>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<NFloat>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<NFloat>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<NFloat>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static NFloat IIncrementOperators<NFloat>.operator checked ++(NFloat value); + static NFloat IMultiplyOperators<NFloat, NFloat, NFloat>.operator checked *(NFloat left, NFloat right); + static bool INumberBase<NFloat>.IsCanonical(NFloat value); + static bool INumberBase<NFloat>.IsComplexNumber(NFloat value); + static bool INumberBase<NFloat>.IsImaginaryNumber(NFloat value); + static bool INumberBase<NFloat>.IsZero(NFloat value); + static bool INumberBase<NFloat>.TryConvertFromChecked<TOther>(TOther value, out NFloat result); + static bool INumberBase<NFloat>.TryConvertFromSaturating<TOther>(TOther value, out NFloat result); + static bool INumberBase<NFloat>.TryConvertFromTruncating<TOther>(TOther value, out NFloat result); + static bool INumberBase<NFloat>.TryConvertToChecked<TOther>(NFloat value, out TOther result); + static bool INumberBase<NFloat>.TryConvertToSaturating<TOther>(NFloat value, out TOther result); + static bool INumberBase<NFloat>.TryConvertToTruncating<TOther>(NFloat value, out TOther result); + static NFloat ISubtractionOperators<NFloat, NFloat, NFloat>.operator checked -(NFloat left, NFloat right); + static NFloat IUnaryNegationOperators<NFloat, NFloat>.operator checked -(NFloat value); + public static NFloat Tan(NFloat x); + public static NFloat Tanh(NFloat x); + public static NFloat TanPi(NFloat x); + public string ToString(IFormatProvider? provider); + public string ToString(string? format); + public string ToString(string? format, IFormatProvider? provider); + public static NFloat Truncate(NFloat x); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out NFloat result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out NFloat result); + public static bool TryParse(ReadOnlySpan<char> s, out NFloat result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out NFloat result); + public static bool TryParse(string? s, IFormatProvider? provider, out NFloat result); + public static bool TryParse(string? s, out NFloat result); } + public enum StringMarshalling { + Custom = 0, + Utf16 = 2, + Utf8 = 1, + } }","title":"System.Runtime.InteropServices"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.InteropServices/#systemruntimeinteropservices","text":"namespace System.Runtime.InteropServices { public enum Architecture { + Armv6 = 7, + LoongArch64 = 6, + Ppc64le = 8, } - public readonly struct ArrayWithOffset + public readonly struct ArrayWithOffset : IEquatable<ArrayWithOffset> public enum ClassInterfaceType { AutoDispatch = 1, AutoDual = 2, } - public struct GCHandle { + public struct GCHandle : IEquatable<GCHandle> { + public bool Equals(GCHandle other); } + public sealed class LibraryImportAttribute : Attribute { + public LibraryImportAttribute(string libraryName); + public string EntryPoint { get; set; } + public string LibraryName { get; } + public bool SetLastError { get; set; } + public StringMarshalling StringMarshalling { get; set; } + public Type StringMarshallingCustomType { get; set; } + } public static class Marshal { public static void DestroyStructure(IntPtr ptr, Type structuretype); public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t); public static IntPtr GetFunctionPointerForDelegate(Delegate d); public static IntPtr GetHINSTANCE(Module m); + public static string GetLastPInvokeErrorMessage(); + public static string GetPInvokeErrorMessage(int error); public static void PtrToStructure(IntPtr ptr, object structure); public static object? PtrToStructure(IntPtr ptr, Type structureType); public static byte ReadByte(object ptr, int ofs); public static short ReadInt16(object ptr, int ofs); public static int ReadInt32(object ptr, int ofs); public static long ReadInt64(object ptr, int ofs); public static IntPtr ReadIntPtr(object ptr, int ofs); public static int SizeOf(object structure); public static int SizeOf(Type t); public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld); public static void WriteByte(object ptr, int ofs, byte val); public static void WriteInt16(object ptr, int ofs, char val); public static void WriteInt16(object ptr, int ofs, short val); public static void WriteInt32(object ptr, int ofs, int val); public static void WriteInt64(object ptr, int ofs, long val); public static void WriteIntPtr(object ptr, int ofs, IntPtr val); } public static class NativeLibrary { + public static IntPtr GetMainProgramHandle(); } public static class NativeMemory { + public unsafe static void Clear(void* ptr, UIntPtr byteCount); + public unsafe static void Copy(void* source, void* destination, UIntPtr byteCount); + public unsafe static void Fill(void* ptr, UIntPtr byteCount, byte value); } - public readonly struct NFloat : IEquatable<NFloat> { + public readonly struct NFloat : IAdditionOperators<NFloat, NFloat, NFloat>, IAdditiveIdentity<NFloat, NFloat>, IBinaryFloatingPointIeee754<NFloat>, IBinaryNumber<NFloat>, IBitwiseOperators<NFloat, NFloat, NFloat>, IComparable, IComparable<NFloat>, IComparisonOperators<NFloat, NFloat, bool>, IDecrementOperators<NFloat>, IDivisionOperators<NFloat, NFloat, NFloat>, IEqualityOperators<NFloat, NFloat, bool>, IEquatable<NFloat>, IExponentialFunctions<NFloat>, IFloatingPoint<NFloat>, IFloatingPointConstants<NFloat>, IFloatingPointIeee754<NFloat>, IFormattable, IHyperbolicFunctions<NFloat>, IIncrementOperators<NFloat>, ILogarithmicFunctions<NFloat>, IMinMaxValue<NFloat>, IModulusOperators<NFloat, NFloat, NFloat>, IMultiplicativeIdentity<NFloat, NFloat>, IMultiplyOperators<NFloat, NFloat, NFloat>, INumber<NFloat>, INumberBase<NFloat>, IParsable<NFloat>, IPowerFunctions<NFloat>, IRootFunctions<NFloat>, ISignedNumber<NFloat>, ISpanFormattable, ISpanParsable<NFloat>, ISubtractionOperators<NFloat, NFloat, NFloat>, ITrigonometricFunctions<NFloat>, IUnaryNegationOperators<NFloat, NFloat>, IUnaryPlusOperators<NFloat, NFloat> { + public static NFloat E { get; } + public static NFloat Epsilon { get; } + public static NFloat MaxValue { get; } + public static NFloat MinValue { get; } + public static NFloat NaN { get; } + public static NFloat NegativeInfinity { get; } + public static NFloat NegativeZero { get; } + public static NFloat Pi { get; } + public static NFloat PositiveInfinity { get; } + public static int Size { get; } + static NFloat System.Numerics.IAdditiveIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.AdditiveIdentity { get; } + static NFloat System.Numerics.IBinaryNumber<System.Runtime.InteropServices.NFloat>.AllBitsSet { get; } + static NFloat System.Numerics.IMultiplicativeIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.MultiplicativeIdentity { get; } + static NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.One { get; } + static int System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.Radix { get; } + static NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.Zero { get; } + static NFloat System.Numerics.ISignedNumber<System.Runtime.InteropServices.NFloat>.NegativeOne { get; } + public static NFloat Tau { get; } + public static NFloat Abs(NFloat value); + public static NFloat Acos(NFloat x); + public static NFloat Acosh(NFloat x); + public static NFloat AcosPi(NFloat x); + public static NFloat Asin(NFloat x); + public static NFloat Asinh(NFloat x); + public static NFloat AsinPi(NFloat x); + public static NFloat Atan(NFloat x); + public static NFloat Atan2(NFloat y, NFloat x); + public static NFloat Atan2Pi(NFloat y, NFloat x); + public static NFloat Atanh(NFloat x); + public static NFloat AtanPi(NFloat x); + public static NFloat BitDecrement(NFloat x); + public static NFloat BitIncrement(NFloat x); + public static NFloat Cbrt(NFloat x); + public static NFloat Ceiling(NFloat x); + public static NFloat Clamp(NFloat value, NFloat min, NFloat max); + public int CompareTo(object? obj); + public int CompareTo(NFloat other); + public static NFloat CopySign(NFloat value, NFloat sign); + public static NFloat Cos(NFloat x); + public static NFloat Cosh(NFloat x); + public static NFloat CosPi(NFloat x); + public static NFloat CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static NFloat CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static NFloat CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static NFloat Exp(NFloat x); + public static NFloat Exp10(NFloat x); + public static NFloat Exp10M1(NFloat x); + public static NFloat Exp2(NFloat x); + public static NFloat Exp2M1(NFloat x); + public static NFloat ExpM1(NFloat x); + public static NFloat Floor(NFloat x); + public static NFloat FusedMultiplyAdd(NFloat left, NFloat right, NFloat addend); + public static NFloat Hypot(NFloat x, NFloat y); + public static NFloat Ieee754Remainder(NFloat left, NFloat right); + public static int ILogB(NFloat x); + public static bool IsEvenInteger(NFloat value); + public static bool IsFinite(NFloat value); + public static bool IsInfinity(NFloat value); + public static bool IsInteger(NFloat value); + public static bool IsNaN(NFloat value); + public static bool IsNegative(NFloat value); + public static bool IsNegativeInfinity(NFloat value); + public static bool IsNormal(NFloat value); + public static bool IsOddInteger(NFloat value); + public static bool IsPositive(NFloat value); + public static bool IsPositiveInfinity(NFloat value); + public static bool IsPow2(NFloat value); + public static bool IsRealNumber(NFloat value); + public static bool IsSubnormal(NFloat value); + public static NFloat Log(NFloat x); + public static NFloat Log(NFloat x, NFloat newBase); + public static NFloat Log10(NFloat x); + public static NFloat Log10P1(NFloat x); + public static NFloat Log2(NFloat value); + public static NFloat Log2P1(NFloat x); + public static NFloat LogP1(NFloat x); + public static NFloat Max(NFloat x, NFloat y); + public static NFloat MaxMagnitude(NFloat x, NFloat y); + public static NFloat MaxMagnitudeNumber(NFloat x, NFloat y); + public static NFloat MaxNumber(NFloat x, NFloat y); + public static NFloat Min(NFloat x, NFloat y); + public static NFloat MinMagnitude(NFloat x, NFloat y); + public static NFloat MinMagnitudeNumber(NFloat x, NFloat y); + public static NFloat MinNumber(NFloat x, NFloat y); + public static NFloat operator +(NFloat left, NFloat right); + public static explicit operator checked byte (NFloat value); + public static explicit operator checked char (NFloat value); + public static explicit operator checked short (NFloat value); + public static explicit operator checked int (NFloat value); + public static explicit operator checked long (NFloat value); + public static explicit operator checked Int128 (NFloat value); + public static explicit operator checked IntPtr (NFloat value); + public static explicit operator checked sbyte (NFloat value); + public static explicit operator checked ushort (NFloat value); + public static explicit operator checked uint (NFloat value); + public static explicit operator checked ulong (NFloat value); + public static explicit operator checked UInt128 (NFloat value); + public static explicit operator checked UIntPtr (NFloat value); + public static NFloat operator --(NFloat value); + public static NFloat operator /(NFloat left, NFloat right); + public static bool operator ==(NFloat left, NFloat right); + public static explicit operator NFloat (decimal value); + public static explicit operator NFloat (double value); + public static explicit operator NFloat (Int128 value); + public static explicit operator byte (NFloat value); + public static explicit operator char (NFloat value); + public static explicit operator decimal (NFloat value); + public static explicit operator Half (NFloat value); + public static explicit operator Int128 (NFloat value); + public static explicit operator short (NFloat value); + public static explicit operator int (NFloat value); + public static explicit operator long (NFloat value); + public static explicit operator IntPtr (NFloat value); + public static explicit operator sbyte (NFloat value); + public static explicit operator float (NFloat value); + public static explicit operator UInt128 (NFloat value); + public static explicit operator ushort (NFloat value); + public static explicit operator uint (NFloat value); + public static explicit operator ulong (NFloat value); + public static explicit operator UIntPtr (NFloat value); + public static explicit operator NFloat (UInt128 value); + public static bool operator >(NFloat left, NFloat right); + public static bool operator >=(NFloat left, NFloat right); + public static implicit operator NFloat (byte value); + public static implicit operator NFloat (char value); + public static implicit operator NFloat (Half value); + public static implicit operator NFloat (short value); + public static implicit operator NFloat (int value); + public static implicit operator NFloat (long value); + public static implicit operator NFloat (IntPtr value); + public static implicit operator double (NFloat value); + public static implicit operator NFloat (sbyte value); + public static implicit operator NFloat (float value); + public static implicit operator NFloat (ushort value); + public static implicit operator NFloat (uint value); + public static implicit operator NFloat (ulong value); + public static implicit operator NFloat (UIntPtr value); + public static NFloat operator ++(NFloat value); + public static bool operator !=(NFloat left, NFloat right); + public static bool operator <(NFloat left, NFloat right); + public static bool operator <=(NFloat left, NFloat right); + public static NFloat operator %(NFloat left, NFloat right); + public static NFloat operator *(NFloat left, NFloat right); + public static NFloat operator -(NFloat left, NFloat right); + public static NFloat operator -(NFloat value); + public static NFloat operator +(NFloat value); + public static NFloat Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent | NumberStyles.AllowLeadingSign | NumberStyles.AllowLeadingWhite | NumberStyles.AllowThousands | NumberStyles.AllowTrailingWhite, IFormatProvider? provider = null); + public static NFloat Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static NFloat Parse(string s); + public static NFloat Parse(string s, NumberStyles style); + public static NFloat Parse(string s, NumberStyles style, IFormatProvider? provider); + public static NFloat Parse(string s, IFormatProvider? provider); + public static NFloat Pow(NFloat x, NFloat y); + public static NFloat ReciprocalEstimate(NFloat x); + public static NFloat ReciprocalSqrtEstimate(NFloat x); + public static NFloat RootN(NFloat x, int n); + public static NFloat Round(NFloat x); + public static NFloat Round(NFloat x, int digits); + public static NFloat Round(NFloat x, int digits, MidpointRounding mode); + public static NFloat Round(NFloat x, MidpointRounding mode); + public static NFloat ScaleB(NFloat x, int n); + public static int Sign(NFloat value); + public static NFloat Sin(NFloat x); + public static (NFloat Sin, NFloat Cos) SinCos(NFloat x); + public static (NFloat SinPi, NFloat CosPi) SinCosPi(NFloat x); + public static NFloat Sinh(NFloat x); + public static NFloat SinPi(NFloat x); + public static NFloat Sqrt(NFloat x); + static NFloat IAdditionOperators<NFloat, NFloat, NFloat>.operator checked +(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator &(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator |(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator ^(NFloat left, NFloat right); + static NFloat IBitwiseOperators<NFloat, NFloat, NFloat>.operator ~(NFloat value); + static NFloat IDecrementOperators<NFloat>.operator checked --(NFloat value); + static NFloat IDivisionOperators<NFloat, NFloat, NFloat>.operator checked /(NFloat left, NFloat right); + int IFloatingPoint<NFloat>.GetExponentByteCount(); + int IFloatingPoint<NFloat>.GetExponentShortestBitLength(); + int IFloatingPoint<NFloat>.GetSignificandBitLength(); + int IFloatingPoint<NFloat>.GetSignificandByteCount(); + bool IFloatingPoint<NFloat>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<NFloat>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<NFloat>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<NFloat>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static NFloat IIncrementOperators<NFloat>.operator checked ++(NFloat value); + static NFloat IMultiplyOperators<NFloat, NFloat, NFloat>.operator checked *(NFloat left, NFloat right); + static bool INumberBase<NFloat>.IsCanonical(NFloat value); + static bool INumberBase<NFloat>.IsComplexNumber(NFloat value); + static bool INumberBase<NFloat>.IsImaginaryNumber(NFloat value); + static bool INumberBase<NFloat>.IsZero(NFloat value); + static bool INumberBase<NFloat>.TryConvertFromChecked<TOther>(TOther value, out NFloat result); + static bool INumberBase<NFloat>.TryConvertFromSaturating<TOther>(TOther value, out NFloat result); + static bool INumberBase<NFloat>.TryConvertFromTruncating<TOther>(TOther value, out NFloat result); + static bool INumberBase<NFloat>.TryConvertToChecked<TOther>(NFloat value, out TOther result); + static bool INumberBase<NFloat>.TryConvertToSaturating<TOther>(NFloat value, out TOther result); + static bool INumberBase<NFloat>.TryConvertToTruncating<TOther>(NFloat value, out TOther result); + static NFloat ISubtractionOperators<NFloat, NFloat, NFloat>.operator checked -(NFloat left, NFloat right); + static NFloat IUnaryNegationOperators<NFloat, NFloat>.operator checked -(NFloat value); + public static NFloat Tan(NFloat x); + public static NFloat Tanh(NFloat x); + public static NFloat TanPi(NFloat x); + public string ToString(IFormatProvider? provider); + public string ToString(string? format); + public string ToString(string? format, IFormatProvider? provider); + public static NFloat Truncate(NFloat x); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out NFloat result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out NFloat result); + public static bool TryParse(ReadOnlySpan<char> s, out NFloat result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out NFloat result); + public static bool TryParse(string? s, IFormatProvider? provider, out NFloat result); + public static bool TryParse(string? s, out NFloat result); } + public enum StringMarshalling { + Custom = 0, + Utf16 = 2, + Utf8 = 1, + } }","title":"System.Runtime.InteropServices"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Intrinsics.Arm/","text":"System.Runtime.Intrinsics.Arm namespace System.Runtime.Intrinsics.Arm { public abstract class AdvSimd : ArmBase { public new abstract class Arm64 : ArmBase.Arm64 { + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairScalarVector64(int* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairScalarVector64(float* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairScalarVector64(uint* address); + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairScalarVector64NonTemporal(int* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairScalarVector64NonTemporal(float* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairScalarVector64NonTemporal(uint* address); + public unsafe static (Vector128<byte> Value1, Vector128<byte> Value2) LoadPairVector128(byte* address); + public unsafe static (Vector128<double> Value1, Vector128<double> Value2) LoadPairVector128(double* address); + public unsafe static (Vector128<short> Value1, Vector128<short> Value2) LoadPairVector128(short* address); + public unsafe static (Vector128<int> Value1, Vector128<int> Value2) LoadPairVector128(int* address); + public unsafe static (Vector128<long> Value1, Vector128<long> Value2) LoadPairVector128(long* address); + public unsafe static (Vector128<sbyte> Value1, Vector128<sbyte> Value2) LoadPairVector128(sbyte* address); + public unsafe static (Vector128<float> Value1, Vector128<float> Value2) LoadPairVector128(float* address); + public unsafe static (Vector128<ushort> Value1, Vector128<ushort> Value2) LoadPairVector128(ushort* address); + public unsafe static (Vector128<uint> Value1, Vector128<uint> Value2) LoadPairVector128(uint* address); + public unsafe static (Vector128<ulong> Value1, Vector128<ulong> Value2) LoadPairVector128(ulong* address); + public unsafe static (Vector128<byte> Value1, Vector128<byte> Value2) LoadPairVector128NonTemporal(byte* address); + public unsafe static (Vector128<double> Value1, Vector128<double> Value2) LoadPairVector128NonTemporal(double* address); + public unsafe static (Vector128<short> Value1, Vector128<short> Value2) LoadPairVector128NonTemporal(short* address); + public unsafe static (Vector128<int> Value1, Vector128<int> Value2) LoadPairVector128NonTemporal(int* address); + public unsafe static (Vector128<long> Value1, Vector128<long> Value2) LoadPairVector128NonTemporal(long* address); + public unsafe static (Vector128<sbyte> Value1, Vector128<sbyte> Value2) LoadPairVector128NonTemporal(sbyte* address); + public unsafe static (Vector128<float> Value1, Vector128<float> Value2) LoadPairVector128NonTemporal(float* address); + public unsafe static (Vector128<ushort> Value1, Vector128<ushort> Value2) LoadPairVector128NonTemporal(ushort* address); + public unsafe static (Vector128<uint> Value1, Vector128<uint> Value2) LoadPairVector128NonTemporal(uint* address); + public unsafe static (Vector128<ulong> Value1, Vector128<ulong> Value2) LoadPairVector128NonTemporal(ulong* address); + public unsafe static (Vector64<byte> Value1, Vector64<byte> Value2) LoadPairVector64(byte* address); + public unsafe static (Vector64<double> Value1, Vector64<double> Value2) LoadPairVector64(double* address); + public unsafe static (Vector64<short> Value1, Vector64<short> Value2) LoadPairVector64(short* address); + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairVector64(int* address); + public unsafe static (Vector64<long> Value1, Vector64<long> Value2) LoadPairVector64(long* address); + public unsafe static (Vector64<sbyte> Value1, Vector64<sbyte> Value2) LoadPairVector64(sbyte* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairVector64(float* address); + public unsafe static (Vector64<ushort> Value1, Vector64<ushort> Value2) LoadPairVector64(ushort* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairVector64(uint* address); + public unsafe static (Vector64<ulong> Value1, Vector64<ulong> Value2) LoadPairVector64(ulong* address); + public unsafe static (Vector64<byte> Value1, Vector64<byte> Value2) LoadPairVector64NonTemporal(byte* address); + public unsafe static (Vector64<double> Value1, Vector64<double> Value2) LoadPairVector64NonTemporal(double* address); + public unsafe static (Vector64<short> Value1, Vector64<short> Value2) LoadPairVector64NonTemporal(short* address); + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairVector64NonTemporal(int* address); + public unsafe static (Vector64<long> Value1, Vector64<long> Value2) LoadPairVector64NonTemporal(long* address); + public unsafe static (Vector64<sbyte> Value1, Vector64<sbyte> Value2) LoadPairVector64NonTemporal(sbyte* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairVector64NonTemporal(float* address); + public unsafe static (Vector64<ushort> Value1, Vector64<ushort> Value2) LoadPairVector64NonTemporal(ushort* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairVector64NonTemporal(uint* address); + public unsafe static (Vector64<ulong> Value1, Vector64<ulong> Value2) LoadPairVector64NonTemporal(ulong* address); } } public abstract class ArmBase { + public static void Yield(); } }","title":"System.Runtime.Intrinsics.Arm"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Intrinsics.Arm/#systemruntimeintrinsicsarm","text":"namespace System.Runtime.Intrinsics.Arm { public abstract class AdvSimd : ArmBase { public new abstract class Arm64 : ArmBase.Arm64 { + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairScalarVector64(int* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairScalarVector64(float* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairScalarVector64(uint* address); + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairScalarVector64NonTemporal(int* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairScalarVector64NonTemporal(float* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairScalarVector64NonTemporal(uint* address); + public unsafe static (Vector128<byte> Value1, Vector128<byte> Value2) LoadPairVector128(byte* address); + public unsafe static (Vector128<double> Value1, Vector128<double> Value2) LoadPairVector128(double* address); + public unsafe static (Vector128<short> Value1, Vector128<short> Value2) LoadPairVector128(short* address); + public unsafe static (Vector128<int> Value1, Vector128<int> Value2) LoadPairVector128(int* address); + public unsafe static (Vector128<long> Value1, Vector128<long> Value2) LoadPairVector128(long* address); + public unsafe static (Vector128<sbyte> Value1, Vector128<sbyte> Value2) LoadPairVector128(sbyte* address); + public unsafe static (Vector128<float> Value1, Vector128<float> Value2) LoadPairVector128(float* address); + public unsafe static (Vector128<ushort> Value1, Vector128<ushort> Value2) LoadPairVector128(ushort* address); + public unsafe static (Vector128<uint> Value1, Vector128<uint> Value2) LoadPairVector128(uint* address); + public unsafe static (Vector128<ulong> Value1, Vector128<ulong> Value2) LoadPairVector128(ulong* address); + public unsafe static (Vector128<byte> Value1, Vector128<byte> Value2) LoadPairVector128NonTemporal(byte* address); + public unsafe static (Vector128<double> Value1, Vector128<double> Value2) LoadPairVector128NonTemporal(double* address); + public unsafe static (Vector128<short> Value1, Vector128<short> Value2) LoadPairVector128NonTemporal(short* address); + public unsafe static (Vector128<int> Value1, Vector128<int> Value2) LoadPairVector128NonTemporal(int* address); + public unsafe static (Vector128<long> Value1, Vector128<long> Value2) LoadPairVector128NonTemporal(long* address); + public unsafe static (Vector128<sbyte> Value1, Vector128<sbyte> Value2) LoadPairVector128NonTemporal(sbyte* address); + public unsafe static (Vector128<float> Value1, Vector128<float> Value2) LoadPairVector128NonTemporal(float* address); + public unsafe static (Vector128<ushort> Value1, Vector128<ushort> Value2) LoadPairVector128NonTemporal(ushort* address); + public unsafe static (Vector128<uint> Value1, Vector128<uint> Value2) LoadPairVector128NonTemporal(uint* address); + public unsafe static (Vector128<ulong> Value1, Vector128<ulong> Value2) LoadPairVector128NonTemporal(ulong* address); + public unsafe static (Vector64<byte> Value1, Vector64<byte> Value2) LoadPairVector64(byte* address); + public unsafe static (Vector64<double> Value1, Vector64<double> Value2) LoadPairVector64(double* address); + public unsafe static (Vector64<short> Value1, Vector64<short> Value2) LoadPairVector64(short* address); + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairVector64(int* address); + public unsafe static (Vector64<long> Value1, Vector64<long> Value2) LoadPairVector64(long* address); + public unsafe static (Vector64<sbyte> Value1, Vector64<sbyte> Value2) LoadPairVector64(sbyte* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairVector64(float* address); + public unsafe static (Vector64<ushort> Value1, Vector64<ushort> Value2) LoadPairVector64(ushort* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairVector64(uint* address); + public unsafe static (Vector64<ulong> Value1, Vector64<ulong> Value2) LoadPairVector64(ulong* address); + public unsafe static (Vector64<byte> Value1, Vector64<byte> Value2) LoadPairVector64NonTemporal(byte* address); + public unsafe static (Vector64<double> Value1, Vector64<double> Value2) LoadPairVector64NonTemporal(double* address); + public unsafe static (Vector64<short> Value1, Vector64<short> Value2) LoadPairVector64NonTemporal(short* address); + public unsafe static (Vector64<int> Value1, Vector64<int> Value2) LoadPairVector64NonTemporal(int* address); + public unsafe static (Vector64<long> Value1, Vector64<long> Value2) LoadPairVector64NonTemporal(long* address); + public unsafe static (Vector64<sbyte> Value1, Vector64<sbyte> Value2) LoadPairVector64NonTemporal(sbyte* address); + public unsafe static (Vector64<float> Value1, Vector64<float> Value2) LoadPairVector64NonTemporal(float* address); + public unsafe static (Vector64<ushort> Value1, Vector64<ushort> Value2) LoadPairVector64NonTemporal(ushort* address); + public unsafe static (Vector64<uint> Value1, Vector64<uint> Value2) LoadPairVector64NonTemporal(uint* address); + public unsafe static (Vector64<ulong> Value1, Vector64<ulong> Value2) LoadPairVector64NonTemporal(ulong* address); } } public abstract class ArmBase { + public static void Yield(); } }","title":"System.Runtime.Intrinsics.Arm"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Intrinsics.X86/","text":"System.Runtime.Intrinsics.X86 namespace System.Runtime.Intrinsics.X86 { public abstract class X86Base { + public static void Pause(); } + public abstract class X86Serialize : X86Base { + public static new bool IsSupported { get; } + public static void Serialize(); + public new abstract class X64 : X86Base.X64 { + public static new bool IsSupported { get; } + } + } }","title":"System.Runtime.Intrinsics.X86"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Intrinsics.X86/#systemruntimeintrinsicsx86","text":"namespace System.Runtime.Intrinsics.X86 { public abstract class X86Base { + public static void Pause(); } + public abstract class X86Serialize : X86Base { + public static new bool IsSupported { get; } + public static void Serialize(); + public new abstract class X64 : X86Base.X64 { + public static new bool IsSupported { get; } + } + } }","title":"System.Runtime.Intrinsics.X86"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Intrinsics/","text":"System.Runtime.Intrinsics namespace System.Runtime.Intrinsics { public static class Vector128 { + public static bool IsHardwareAccelerated { get; } + public static Vector128<T> Abs<T>(Vector128<T> vector) where T : struct; + public static Vector128<T> Add<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> AndNot<T>(Vector128<T> left, Vector128<T> right) where T : struct; - public static Vector128<U> As<T, U>(this Vector128<T> vector) where T : struct where U : struct; + public static Vector128<TTo> As<TFrom, TTo>(this Vector128<TFrom> vector) where TFrom : struct where TTo : struct; + public static Vector128<IntPtr> AsNInt<T>(this Vector128<T> vector) where T : struct; + public static Vector128<UIntPtr> AsNUInt<T>(this Vector128<T> vector) where T : struct; + public static Vector128<T> BitwiseAnd<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> BitwiseOr<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<double> Ceiling(Vector128<double> vector); + public static Vector128<float> Ceiling(Vector128<float> vector); + public static Vector128<T> ConditionalSelect<T>(Vector128<T> condition, Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<double> ConvertToDouble(Vector128<long> vector); + public static Vector128<double> ConvertToDouble(Vector128<ulong> vector); + public static Vector128<int> ConvertToInt32(Vector128<float> vector); + public static Vector128<long> ConvertToInt64(Vector128<double> vector); + public static Vector128<float> ConvertToSingle(Vector128<int> vector); + public static Vector128<float> ConvertToSingle(Vector128<uint> vector); + public static Vector128<uint> ConvertToUInt32(Vector128<float> vector); + public static Vector128<ulong> ConvertToUInt64(Vector128<double> vector); + public static void CopyTo<T>(this Vector128<T> vector, Span<T> destination) where T : struct; + public static void CopyTo<T>(this Vector128<T> vector, T[] destination) where T : struct; + public static void CopyTo<T>(this Vector128<T> vector, T[] destination, int startIndex) where T : struct; + public static Vector128<IntPtr> Create(IntPtr value); + public static Vector128<UIntPtr> Create(UIntPtr value); + public static Vector128<T> Create<T>(ReadOnlySpan<T> values) where T : struct; + public static Vector128<T> Create<T>(T value) where T : struct; + public static Vector128<T> Create<T>(T[] values) where T : struct; + public static Vector128<T> Create<T>(T[] values, int index) where T : struct; + public static Vector128<IntPtr> CreateScalar(IntPtr value); + public static Vector128<UIntPtr> CreateScalar(UIntPtr value); + public static Vector128<IntPtr> CreateScalarUnsafe(IntPtr value); + public static Vector128<UIntPtr> CreateScalarUnsafe(UIntPtr value); + public static Vector128<T> Divide<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static T Dot<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Equals<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool EqualsAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool EqualsAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static uint ExtractMostSignificantBits<T>(this Vector128<T> vector) where T : struct; + public static Vector128<double> Floor(Vector128<double> vector); + public static Vector128<float> Floor(Vector128<float> vector); + public static Vector128<T> GreaterThan<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> GreaterThanOrEqual<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanOrEqualAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanOrEqualAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> LessThan<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> LessThanOrEqual<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanOrEqualAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanOrEqualAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public unsafe static Vector128<T> Load<T>(T* source) where T : struct; + public unsafe static Vector128<T> LoadAligned<T>(T* source) where T : struct; + public unsafe static Vector128<T> LoadAlignedNonTemporal<T>(T* source) where T : struct; + public static Vector128<T> LoadUnsafe<T>(ref T source) where T : struct; + public static Vector128<T> LoadUnsafe<T>(ref T source, UIntPtr elementOffset) where T : struct; + public static Vector128<T> Max<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Min<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Multiply<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Multiply<T>(Vector128<T> left, T right) where T : struct; + public static Vector128<T> Multiply<T>(T left, Vector128<T> right) where T : struct; + public static Vector128<float> Narrow(Vector128<double> lower, Vector128<double> upper); + public static Vector128<sbyte> Narrow(Vector128<short> lower, Vector128<short> upper); + public static Vector128<short> Narrow(Vector128<int> lower, Vector128<int> upper); + public static Vector128<int> Narrow(Vector128<long> lower, Vector128<long> upper); + public static Vector128<byte> Narrow(Vector128<ushort> lower, Vector128<ushort> upper); + public static Vector128<ushort> Narrow(Vector128<uint> lower, Vector128<uint> upper); + public static Vector128<uint> Narrow(Vector128<ulong> lower, Vector128<ulong> upper); + public static Vector128<T> Negate<T>(Vector128<T> vector) where T : struct; + public static Vector128<T> OnesComplement<T>(Vector128<T> vector) where T : struct; + public static Vector128<byte> ShiftLeft(Vector128<byte> vector, int shiftCount); + public static Vector128<short> ShiftLeft(Vector128<short> vector, int shiftCount); + public static Vector128<int> ShiftLeft(Vector128<int> vector, int shiftCount); + public static Vector128<long> ShiftLeft(Vector128<long> vector, int shiftCount); + public static Vector128<IntPtr> ShiftLeft(Vector128<IntPtr> vector, int shiftCount); + public static Vector128<sbyte> ShiftLeft(Vector128<sbyte> vector, int shiftCount); + public static Vector128<ushort> ShiftLeft(Vector128<ushort> vector, int shiftCount); + public static Vector128<uint> ShiftLeft(Vector128<uint> vector, int shiftCount); + public static Vector128<ulong> ShiftLeft(Vector128<ulong> vector, int shiftCount); + public static Vector128<UIntPtr> ShiftLeft(Vector128<UIntPtr> vector, int shiftCount); + public static Vector128<short> ShiftRightArithmetic(Vector128<short> vector, int shiftCount); + public static Vector128<int> ShiftRightArithmetic(Vector128<int> vector, int shiftCount); + public static Vector128<long> ShiftRightArithmetic(Vector128<long> vector, int shiftCount); + public static Vector128<IntPtr> ShiftRightArithmetic(Vector128<IntPtr> vector, int shiftCount); + public static Vector128<sbyte> ShiftRightArithmetic(Vector128<sbyte> vector, int shiftCount); + public static Vector128<byte> ShiftRightLogical(Vector128<byte> vector, int shiftCount); + public static Vector128<short> ShiftRightLogical(Vector128<short> vector, int shiftCount); + public static Vector128<int> ShiftRightLogical(Vector128<int> vector, int shiftCount); + public static Vector128<long> ShiftRightLogical(Vector128<long> vector, int shiftCount); + public static Vector128<IntPtr> ShiftRightLogical(Vector128<IntPtr> vector, int shiftCount); + public static Vector128<sbyte> ShiftRightLogical(Vector128<sbyte> vector, int shiftCount); + public static Vector128<ushort> ShiftRightLogical(Vector128<ushort> vector, int shiftCount); + public static Vector128<uint> ShiftRightLogical(Vector128<uint> vector, int shiftCount); + public static Vector128<ulong> ShiftRightLogical(Vector128<ulong> vector, int shiftCount); + public static Vector128<UIntPtr> ShiftRightLogical(Vector128<UIntPtr> vector, int shiftCount); + public static Vector128<byte> Shuffle(Vector128<byte> vector, Vector128<byte> indices); + public static Vector128<double> Shuffle(Vector128<double> vector, Vector128<long> indices); + public static Vector128<short> Shuffle(Vector128<short> vector, Vector128<short> indices); + public static Vector128<int> Shuffle(Vector128<int> vector, Vector128<int> indices); + public static Vector128<long> Shuffle(Vector128<long> vector, Vector128<long> indices); + public static Vector128<sbyte> Shuffle(Vector128<sbyte> vector, Vector128<sbyte> indices); + public static Vector128<float> Shuffle(Vector128<float> vector, Vector128<int> indices); + public static Vector128<ushort> Shuffle(Vector128<ushort> vector, Vector128<ushort> indices); + public static Vector128<uint> Shuffle(Vector128<uint> vector, Vector128<uint> indices); + public static Vector128<ulong> Shuffle(Vector128<ulong> vector, Vector128<ulong> indices); + public static Vector128<T> Sqrt<T>(Vector128<T> vector) where T : struct; + public unsafe static void Store<T>(this Vector128<T> source, T* destination) where T : struct; + public unsafe static void StoreAligned<T>(this Vector128<T> source, T* destination) where T : struct; + public unsafe static void StoreAlignedNonTemporal<T>(this Vector128<T> source, T* destination) where T : struct; + public static void StoreUnsafe<T>(this Vector128<T> source, ref T destination) where T : struct; + public static void StoreUnsafe<T>(this Vector128<T> source, ref T destination, UIntPtr elementOffset) where T : struct; + public static Vector128<T> Subtract<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static T Sum<T>(Vector128<T> vector) where T : struct; + public static bool TryCopyTo<T>(this Vector128<T> vector, Span<T> destination) where T : struct; + public static (Vector128<ushort> Lower, Vector128<ushort> Upper) Widen(Vector128<byte> source); + public static (Vector128<int> Lower, Vector128<int> Upper) Widen(Vector128<short> source); + public static (Vector128<long> Lower, Vector128<long> Upper) Widen(Vector128<int> source); + public static (Vector128<short> Lower, Vector128<short> Upper) Widen(Vector128<sbyte> source); + public static (Vector128<double> Lower, Vector128<double> Upper) Widen(Vector128<float> source); + public static (Vector128<uint> Lower, Vector128<uint> Upper) Widen(Vector128<ushort> source); + public static (Vector128<ulong> Lower, Vector128<ulong> Upper) Widen(Vector128<uint> source); + public static Vector128<T> Xor<T>(Vector128<T> left, Vector128<T> right) where T : struct; } public readonly struct Vector128<T> : IEquatable<Vector128<T>> where T : struct { + public static bool IsSupported { get; } + public T this[int index] { get; } + public static Vector128<T> operator +(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator &(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator |(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator /(Vector128<T> left, Vector128<T> right); + public static bool operator ==(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator ^(Vector128<T> left, Vector128<T> right); + public static bool operator !=(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator *(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator *(Vector128<T> left, T right); + public static Vector128<T> operator *(T left, Vector128<T> right); + public static Vector128<T> operator ~(Vector128<T> vector); + public static Vector128<T> operator -(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator -(Vector128<T> vector); + public static Vector128<T> operator +(Vector128<T> value); } public static class Vector256 { + public static bool IsHardwareAccelerated { get; } + public static Vector256<T> Abs<T>(Vector256<T> vector) where T : struct; + public static Vector256<T> Add<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> AndNot<T>(Vector256<T> left, Vector256<T> right) where T : struct; - public static Vector256<U> As<T, U>(this Vector256<T> vector) where T : struct where U : struct; + public static Vector256<TTo> As<TFrom, TTo>(this Vector256<TFrom> vector) where TFrom : struct where TTo : struct; + public static Vector256<IntPtr> AsNInt<T>(this Vector256<T> vector) where T : struct; + public static Vector256<UIntPtr> AsNUInt<T>(this Vector256<T> vector) where T : struct; + public static Vector256<T> BitwiseAnd<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> BitwiseOr<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<double> Ceiling(Vector256<double> vector); + public static Vector256<float> Ceiling(Vector256<float> vector); + public static Vector256<T> ConditionalSelect<T>(Vector256<T> condition, Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<double> ConvertToDouble(Vector256<long> vector); + public static Vector256<double> ConvertToDouble(Vector256<ulong> vector); + public static Vector256<int> ConvertToInt32(Vector256<float> vector); + public static Vector256<long> ConvertToInt64(Vector256<double> vector); + public static Vector256<float> ConvertToSingle(Vector256<int> vector); + public static Vector256<float> ConvertToSingle(Vector256<uint> vector); + public static Vector256<uint> ConvertToUInt32(Vector256<float> vector); + public static Vector256<ulong> ConvertToUInt64(Vector256<double> vector); + public static void CopyTo<T>(this Vector256<T> vector, Span<T> destination) where T : struct; + public static void CopyTo<T>(this Vector256<T> vector, T[] destination) where T : struct; + public static void CopyTo<T>(this Vector256<T> vector, T[] destination, int startIndex) where T : struct; + public static Vector256<IntPtr> Create(IntPtr value); + public static Vector256<UIntPtr> Create(UIntPtr value); + public static Vector256<T> Create<T>(ReadOnlySpan<T> values) where T : struct; + public static Vector256<T> Create<T>(T value) where T : struct; + public static Vector256<T> Create<T>(T[] values) where T : struct; + public static Vector256<T> Create<T>(T[] values, int index) where T : struct; + public static Vector256<IntPtr> CreateScalar(IntPtr value); + public static Vector256<UIntPtr> CreateScalar(UIntPtr value); + public static Vector256<IntPtr> CreateScalarUnsafe(IntPtr value); + public static Vector256<UIntPtr> CreateScalarUnsafe(UIntPtr value); + public static Vector256<T> Divide<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static T Dot<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Equals<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool EqualsAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool EqualsAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static uint ExtractMostSignificantBits<T>(this Vector256<T> vector) where T : struct; + public static Vector256<double> Floor(Vector256<double> vector); + public static Vector256<float> Floor(Vector256<float> vector); + public static Vector256<T> GreaterThan<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> GreaterThanOrEqual<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanOrEqualAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanOrEqualAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> LessThan<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> LessThanOrEqual<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanOrEqualAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanOrEqualAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public unsafe static Vector256<T> Load<T>(T* source) where T : struct; + public unsafe static Vector256<T> LoadAligned<T>(T* source) where T : struct; + public unsafe static Vector256<T> LoadAlignedNonTemporal<T>(T* source) where T : struct; + public static Vector256<T> LoadUnsafe<T>(ref T source) where T : struct; + public static Vector256<T> LoadUnsafe<T>(ref T source, UIntPtr elementOffset) where T : struct; + public static Vector256<T> Max<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Min<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Multiply<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Multiply<T>(Vector256<T> left, T right) where T : struct; + public static Vector256<T> Multiply<T>(T left, Vector256<T> right) where T : struct; + public static Vector256<float> Narrow(Vector256<double> lower, Vector256<double> upper); + public static Vector256<sbyte> Narrow(Vector256<short> lower, Vector256<short> upper); + public static Vector256<short> Narrow(Vector256<int> lower, Vector256<int> upper); + public static Vector256<int> Narrow(Vector256<long> lower, Vector256<long> upper); + public static Vector256<byte> Narrow(Vector256<ushort> lower, Vector256<ushort> upper); + public static Vector256<ushort> Narrow(Vector256<uint> lower, Vector256<uint> upper); + public static Vector256<uint> Narrow(Vector256<ulong> lower, Vector256<ulong> upper); + public static Vector256<T> Negate<T>(Vector256<T> vector) where T : struct; + public static Vector256<T> OnesComplement<T>(Vector256<T> vector) where T : struct; + public static Vector256<byte> ShiftLeft(Vector256<byte> vector, int shiftCount); + public static Vector256<short> ShiftLeft(Vector256<short> vector, int shiftCount); + public static Vector256<int> ShiftLeft(Vector256<int> vector, int shiftCount); + public static Vector256<long> ShiftLeft(Vector256<long> vector, int shiftCount); + public static Vector256<IntPtr> ShiftLeft(Vector256<IntPtr> vector, int shiftCount); + public static Vector256<sbyte> ShiftLeft(Vector256<sbyte> vector, int shiftCount); + public static Vector256<ushort> ShiftLeft(Vector256<ushort> vector, int shiftCount); + public static Vector256<uint> ShiftLeft(Vector256<uint> vector, int shiftCount); + public static Vector256<ulong> ShiftLeft(Vector256<ulong> vector, int shiftCount); + public static Vector256<UIntPtr> ShiftLeft(Vector256<UIntPtr> vector, int shiftCount); + public static Vector256<short> ShiftRightArithmetic(Vector256<short> vector, int shiftCount); + public static Vector256<int> ShiftRightArithmetic(Vector256<int> vector, int shiftCount); + public static Vector256<long> ShiftRightArithmetic(Vector256<long> vector, int shiftCount); + public static Vector256<IntPtr> ShiftRightArithmetic(Vector256<IntPtr> vector, int shiftCount); + public static Vector256<sbyte> ShiftRightArithmetic(Vector256<sbyte> vector, int shiftCount); + public static Vector256<byte> ShiftRightLogical(Vector256<byte> vector, int shiftCount); + public static Vector256<short> ShiftRightLogical(Vector256<short> vector, int shiftCount); + public static Vector256<int> ShiftRightLogical(Vector256<int> vector, int shiftCount); + public static Vector256<long> ShiftRightLogical(Vector256<long> vector, int shiftCount); + public static Vector256<IntPtr> ShiftRightLogical(Vector256<IntPtr> vector, int shiftCount); + public static Vector256<sbyte> ShiftRightLogical(Vector256<sbyte> vector, int shiftCount); + public static Vector256<ushort> ShiftRightLogical(Vector256<ushort> vector, int shiftCount); + public static Vector256<uint> ShiftRightLogical(Vector256<uint> vector, int shiftCount); + public static Vector256<ulong> ShiftRightLogical(Vector256<ulong> vector, int shiftCount); + public static Vector256<UIntPtr> ShiftRightLogical(Vector256<UIntPtr> vector, int shiftCount); + public static Vector256<byte> Shuffle(Vector256<byte> vector, Vector256<byte> indices); + public static Vector256<double> Shuffle(Vector256<double> vector, Vector256<long> indices); + public static Vector256<short> Shuffle(Vector256<short> vector, Vector256<short> indices); + public static Vector256<int> Shuffle(Vector256<int> vector, Vector256<int> indices); + public static Vector256<long> Shuffle(Vector256<long> vector, Vector256<long> indices); + public static Vector256<sbyte> Shuffle(Vector256<sbyte> vector, Vector256<sbyte> indices); + public static Vector256<float> Shuffle(Vector256<float> vector, Vector256<int> indices); + public static Vector256<ushort> Shuffle(Vector256<ushort> vector, Vector256<ushort> indices); + public static Vector256<uint> Shuffle(Vector256<uint> vector, Vector256<uint> indices); + public static Vector256<ulong> Shuffle(Vector256<ulong> vector, Vector256<ulong> indices); + public static Vector256<T> Sqrt<T>(Vector256<T> vector) where T : struct; + public unsafe static void Store<T>(this Vector256<T> source, T* destination) where T : struct; + public unsafe static void StoreAligned<T>(this Vector256<T> source, T* destination) where T : struct; + public unsafe static void StoreAlignedNonTemporal<T>(this Vector256<T> source, T* destination) where T : struct; + public static void StoreUnsafe<T>(this Vector256<T> source, ref T destination) where T : struct; + public static void StoreUnsafe<T>(this Vector256<T> source, ref T destination, UIntPtr elementOffset) where T : struct; + public static Vector256<T> Subtract<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static T Sum<T>(Vector256<T> vector) where T : struct; + public static bool TryCopyTo<T>(this Vector256<T> vector, Span<T> destination) where T : struct; + public static (Vector256<ushort> Lower, Vector256<ushort> Upper) Widen(Vector256<byte> source); + public static (Vector256<int> Lower, Vector256<int> Upper) Widen(Vector256<short> source); + public static (Vector256<long> Lower, Vector256<long> Upper) Widen(Vector256<int> source); + public static (Vector256<short> Lower, Vector256<short> Upper) Widen(Vector256<sbyte> source); + public static (Vector256<double> Lower, Vector256<double> Upper) Widen(Vector256<float> source); + public static (Vector256<uint> Lower, Vector256<uint> Upper) Widen(Vector256<ushort> source); + public static (Vector256<ulong> Lower, Vector256<ulong> Upper) Widen(Vector256<uint> source); + public static Vector256<T> Xor<T>(Vector256<T> left, Vector256<T> right) where T : struct; } public readonly struct Vector256<T> : IEquatable<Vector256<T>> where T : struct { + public static bool IsSupported { get; } + public T this[int index] { get; } + public static Vector256<T> operator +(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator &(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator |(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator /(Vector256<T> left, Vector256<T> right); + public static bool operator ==(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator ^(Vector256<T> left, Vector256<T> right); + public static bool operator !=(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator *(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator *(Vector256<T> left, T right); + public static Vector256<T> operator *(T left, Vector256<T> right); + public static Vector256<T> operator ~(Vector256<T> vector); + public static Vector256<T> operator -(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator -(Vector256<T> vector); + public static Vector256<T> operator +(Vector256<T> value); } public static class Vector64 { + public static bool IsHardwareAccelerated { get; } + public static Vector64<T> Abs<T>(Vector64<T> vector) where T : struct; + public static Vector64<T> Add<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> AndNot<T>(Vector64<T> left, Vector64<T> right) where T : struct; - public static Vector64<U> As<T, U>(this Vector64<T> vector) where T : struct where U : struct; + public static Vector64<TTo> As<TFrom, TTo>(this Vector64<TFrom> vector) where TFrom : struct where TTo : struct; + public static Vector64<IntPtr> AsNInt<T>(this Vector64<T> vector) where T : struct; + public static Vector64<UIntPtr> AsNUInt<T>(this Vector64<T> vector) where T : struct; + public static Vector64<T> BitwiseAnd<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> BitwiseOr<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<double> Ceiling(Vector64<double> vector); + public static Vector64<float> Ceiling(Vector64<float> vector); + public static Vector64<T> ConditionalSelect<T>(Vector64<T> condition, Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<double> ConvertToDouble(Vector64<long> vector); + public static Vector64<double> ConvertToDouble(Vector64<ulong> vector); + public static Vector64<int> ConvertToInt32(Vector64<float> vector); + public static Vector64<long> ConvertToInt64(Vector64<double> vector); + public static Vector64<float> ConvertToSingle(Vector64<int> vector); + public static Vector64<float> ConvertToSingle(Vector64<uint> vector); + public static Vector64<uint> ConvertToUInt32(Vector64<float> vector); + public static Vector64<ulong> ConvertToUInt64(Vector64<double> vector); + public static void CopyTo<T>(this Vector64<T> vector, Span<T> destination) where T : struct; + public static void CopyTo<T>(this Vector64<T> vector, T[] destination) where T : struct; + public static void CopyTo<T>(this Vector64<T> vector, T[] destination, int startIndex) where T : struct; + public static Vector64<IntPtr> Create(IntPtr value); + public static Vector64<UIntPtr> Create(UIntPtr value); + public static Vector64<T> Create<T>(ReadOnlySpan<T> values) where T : struct; + public static Vector64<T> Create<T>(T value) where T : struct; + public static Vector64<T> Create<T>(T[] values) where T : struct; + public static Vector64<T> Create<T>(T[] values, int index) where T : struct; + public static Vector64<IntPtr> CreateScalar(IntPtr value); + public static Vector64<UIntPtr> CreateScalar(UIntPtr value); + public static Vector64<IntPtr> CreateScalarUnsafe(IntPtr value); + public static Vector64<UIntPtr> CreateScalarUnsafe(UIntPtr value); + public static Vector64<T> Divide<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static T Dot<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Equals<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool EqualsAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool EqualsAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static uint ExtractMostSignificantBits<T>(this Vector64<T> vector) where T : struct; + public static Vector64<double> Floor(Vector64<double> vector); + public static Vector64<float> Floor(Vector64<float> vector); + public static Vector64<T> GreaterThan<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> GreaterThanOrEqual<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanOrEqualAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanOrEqualAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> LessThan<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> LessThanOrEqual<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanOrEqualAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanOrEqualAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public unsafe static Vector64<T> Load<T>(T* source) where T : struct; + public unsafe static Vector64<T> LoadAligned<T>(T* source) where T : struct; + public unsafe static Vector64<T> LoadAlignedNonTemporal<T>(T* source) where T : struct; + public static Vector64<T> LoadUnsafe<T>(ref T source) where T : struct; + public static Vector64<T> LoadUnsafe<T>(ref T source, UIntPtr elementOffset) where T : struct; + public static Vector64<T> Max<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Min<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Multiply<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Multiply<T>(Vector64<T> left, T right) where T : struct; + public static Vector64<T> Multiply<T>(T left, Vector64<T> right) where T : struct; + public static Vector64<float> Narrow(Vector64<double> lower, Vector64<double> upper); + public static Vector64<sbyte> Narrow(Vector64<short> lower, Vector64<short> upper); + public static Vector64<short> Narrow(Vector64<int> lower, Vector64<int> upper); + public static Vector64<int> Narrow(Vector64<long> lower, Vector64<long> upper); + public static Vector64<byte> Narrow(Vector64<ushort> lower, Vector64<ushort> upper); + public static Vector64<ushort> Narrow(Vector64<uint> lower, Vector64<uint> upper); + public static Vector64<uint> Narrow(Vector64<ulong> lower, Vector64<ulong> upper); + public static Vector64<T> Negate<T>(Vector64<T> vector) where T : struct; + public static Vector64<T> OnesComplement<T>(Vector64<T> vector) where T : struct; + public static Vector64<byte> ShiftLeft(Vector64<byte> vector, int shiftCount); + public static Vector64<short> ShiftLeft(Vector64<short> vector, int shiftCount); + public static Vector64<int> ShiftLeft(Vector64<int> vector, int shiftCount); + public static Vector64<long> ShiftLeft(Vector64<long> vector, int shiftCount); + public static Vector64<IntPtr> ShiftLeft(Vector64<IntPtr> vector, int shiftCount); + public static Vector64<sbyte> ShiftLeft(Vector64<sbyte> vector, int shiftCount); + public static Vector64<ushort> ShiftLeft(Vector64<ushort> vector, int shiftCount); + public static Vector64<uint> ShiftLeft(Vector64<uint> vector, int shiftCount); + public static Vector64<ulong> ShiftLeft(Vector64<ulong> vector, int shiftCount); + public static Vector64<UIntPtr> ShiftLeft(Vector64<UIntPtr> vector, int shiftCount); + public static Vector64<short> ShiftRightArithmetic(Vector64<short> vector, int shiftCount); + public static Vector64<int> ShiftRightArithmetic(Vector64<int> vector, int shiftCount); + public static Vector64<long> ShiftRightArithmetic(Vector64<long> vector, int shiftCount); + public static Vector64<IntPtr> ShiftRightArithmetic(Vector64<IntPtr> vector, int shiftCount); + public static Vector64<sbyte> ShiftRightArithmetic(Vector64<sbyte> vector, int shiftCount); + public static Vector64<byte> ShiftRightLogical(Vector64<byte> vector, int shiftCount); + public static Vector64<short> ShiftRightLogical(Vector64<short> vector, int shiftCount); + public static Vector64<int> ShiftRightLogical(Vector64<int> vector, int shiftCount); + public static Vector64<long> ShiftRightLogical(Vector64<long> vector, int shiftCount); + public static Vector64<IntPtr> ShiftRightLogical(Vector64<IntPtr> vector, int shiftCount); + public static Vector64<sbyte> ShiftRightLogical(Vector64<sbyte> vector, int shiftCount); + public static Vector64<ushort> ShiftRightLogical(Vector64<ushort> vector, int shiftCount); + public static Vector64<uint> ShiftRightLogical(Vector64<uint> vector, int shiftCount); + public static Vector64<ulong> ShiftRightLogical(Vector64<ulong> vector, int shiftCount); + public static Vector64<UIntPtr> ShiftRightLogical(Vector64<UIntPtr> vector, int shiftCount); + public static Vector64<byte> Shuffle(Vector64<byte> vector, Vector64<byte> indices); + public static Vector64<short> Shuffle(Vector64<short> vector, Vector64<short> indices); + public static Vector64<int> Shuffle(Vector64<int> vector, Vector64<int> indices); + public static Vector64<sbyte> Shuffle(Vector64<sbyte> vector, Vector64<sbyte> indices); + public static Vector64<float> Shuffle(Vector64<float> vector, Vector64<int> indices); + public static Vector64<ushort> Shuffle(Vector64<ushort> vector, Vector64<ushort> indices); + public static Vector64<uint> Shuffle(Vector64<uint> vector, Vector64<uint> indices); + public static Vector64<T> Sqrt<T>(Vector64<T> vector) where T : struct; + public unsafe static void Store<T>(this Vector64<T> source, T* destination) where T : struct; + public unsafe static void StoreAligned<T>(this Vector64<T> source, T* destination) where T : struct; + public unsafe static void StoreAlignedNonTemporal<T>(this Vector64<T> source, T* destination) where T : struct; + public static void StoreUnsafe<T>(this Vector64<T> source, ref T destination) where T : struct; + public static void StoreUnsafe<T>(this Vector64<T> source, ref T destination, UIntPtr elementOffset) where T : struct; + public static Vector64<T> Subtract<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static T Sum<T>(Vector64<T> vector) where T : struct; + public static bool TryCopyTo<T>(this Vector64<T> vector, Span<T> destination) where T : struct; + public static (Vector64<ushort> Lower, Vector64<ushort> Upper) Widen(Vector64<byte> source); + public static (Vector64<int> Lower, Vector64<int> Upper) Widen(Vector64<short> source); + public static (Vector64<long> Lower, Vector64<long> Upper) Widen(Vector64<int> source); + public static (Vector64<short> Lower, Vector64<short> Upper) Widen(Vector64<sbyte> source); + public static (Vector64<double> Lower, Vector64<double> Upper) Widen(Vector64<float> source); + public static (Vector64<uint> Lower, Vector64<uint> Upper) Widen(Vector64<ushort> source); + public static (Vector64<ulong> Lower, Vector64<ulong> Upper) Widen(Vector64<uint> source); + public static Vector64<T> Xor<T>(Vector64<T> left, Vector64<T> right) where T : struct; } public readonly struct Vector64<T> : IEquatable<Vector64<T>> where T : struct { + public static bool IsSupported { get; } + public T this[int index] { get; } + public static Vector64<T> operator +(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator &(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator |(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator /(Vector64<T> left, Vector64<T> right); + public static bool operator ==(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator ^(Vector64<T> left, Vector64<T> right); + public static bool operator !=(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator *(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator *(Vector64<T> left, T right); + public static Vector64<T> operator *(T left, Vector64<T> right); + public static Vector64<T> operator ~(Vector64<T> vector); + public static Vector64<T> operator -(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator -(Vector64<T> vector); + public static Vector64<T> operator +(Vector64<T> value); } }","title":"System.Runtime.Intrinsics"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Intrinsics/#systemruntimeintrinsics","text":"namespace System.Runtime.Intrinsics { public static class Vector128 { + public static bool IsHardwareAccelerated { get; } + public static Vector128<T> Abs<T>(Vector128<T> vector) where T : struct; + public static Vector128<T> Add<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> AndNot<T>(Vector128<T> left, Vector128<T> right) where T : struct; - public static Vector128<U> As<T, U>(this Vector128<T> vector) where T : struct where U : struct; + public static Vector128<TTo> As<TFrom, TTo>(this Vector128<TFrom> vector) where TFrom : struct where TTo : struct; + public static Vector128<IntPtr> AsNInt<T>(this Vector128<T> vector) where T : struct; + public static Vector128<UIntPtr> AsNUInt<T>(this Vector128<T> vector) where T : struct; + public static Vector128<T> BitwiseAnd<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> BitwiseOr<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<double> Ceiling(Vector128<double> vector); + public static Vector128<float> Ceiling(Vector128<float> vector); + public static Vector128<T> ConditionalSelect<T>(Vector128<T> condition, Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<double> ConvertToDouble(Vector128<long> vector); + public static Vector128<double> ConvertToDouble(Vector128<ulong> vector); + public static Vector128<int> ConvertToInt32(Vector128<float> vector); + public static Vector128<long> ConvertToInt64(Vector128<double> vector); + public static Vector128<float> ConvertToSingle(Vector128<int> vector); + public static Vector128<float> ConvertToSingle(Vector128<uint> vector); + public static Vector128<uint> ConvertToUInt32(Vector128<float> vector); + public static Vector128<ulong> ConvertToUInt64(Vector128<double> vector); + public static void CopyTo<T>(this Vector128<T> vector, Span<T> destination) where T : struct; + public static void CopyTo<T>(this Vector128<T> vector, T[] destination) where T : struct; + public static void CopyTo<T>(this Vector128<T> vector, T[] destination, int startIndex) where T : struct; + public static Vector128<IntPtr> Create(IntPtr value); + public static Vector128<UIntPtr> Create(UIntPtr value); + public static Vector128<T> Create<T>(ReadOnlySpan<T> values) where T : struct; + public static Vector128<T> Create<T>(T value) where T : struct; + public static Vector128<T> Create<T>(T[] values) where T : struct; + public static Vector128<T> Create<T>(T[] values, int index) where T : struct; + public static Vector128<IntPtr> CreateScalar(IntPtr value); + public static Vector128<UIntPtr> CreateScalar(UIntPtr value); + public static Vector128<IntPtr> CreateScalarUnsafe(IntPtr value); + public static Vector128<UIntPtr> CreateScalarUnsafe(UIntPtr value); + public static Vector128<T> Divide<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static T Dot<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Equals<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool EqualsAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool EqualsAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static uint ExtractMostSignificantBits<T>(this Vector128<T> vector) where T : struct; + public static Vector128<double> Floor(Vector128<double> vector); + public static Vector128<float> Floor(Vector128<float> vector); + public static Vector128<T> GreaterThan<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> GreaterThanOrEqual<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanOrEqualAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool GreaterThanOrEqualAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> LessThan<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> LessThanOrEqual<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanOrEqualAll<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static bool LessThanOrEqualAny<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public unsafe static Vector128<T> Load<T>(T* source) where T : struct; + public unsafe static Vector128<T> LoadAligned<T>(T* source) where T : struct; + public unsafe static Vector128<T> LoadAlignedNonTemporal<T>(T* source) where T : struct; + public static Vector128<T> LoadUnsafe<T>(ref T source) where T : struct; + public static Vector128<T> LoadUnsafe<T>(ref T source, UIntPtr elementOffset) where T : struct; + public static Vector128<T> Max<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Min<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Multiply<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static Vector128<T> Multiply<T>(Vector128<T> left, T right) where T : struct; + public static Vector128<T> Multiply<T>(T left, Vector128<T> right) where T : struct; + public static Vector128<float> Narrow(Vector128<double> lower, Vector128<double> upper); + public static Vector128<sbyte> Narrow(Vector128<short> lower, Vector128<short> upper); + public static Vector128<short> Narrow(Vector128<int> lower, Vector128<int> upper); + public static Vector128<int> Narrow(Vector128<long> lower, Vector128<long> upper); + public static Vector128<byte> Narrow(Vector128<ushort> lower, Vector128<ushort> upper); + public static Vector128<ushort> Narrow(Vector128<uint> lower, Vector128<uint> upper); + public static Vector128<uint> Narrow(Vector128<ulong> lower, Vector128<ulong> upper); + public static Vector128<T> Negate<T>(Vector128<T> vector) where T : struct; + public static Vector128<T> OnesComplement<T>(Vector128<T> vector) where T : struct; + public static Vector128<byte> ShiftLeft(Vector128<byte> vector, int shiftCount); + public static Vector128<short> ShiftLeft(Vector128<short> vector, int shiftCount); + public static Vector128<int> ShiftLeft(Vector128<int> vector, int shiftCount); + public static Vector128<long> ShiftLeft(Vector128<long> vector, int shiftCount); + public static Vector128<IntPtr> ShiftLeft(Vector128<IntPtr> vector, int shiftCount); + public static Vector128<sbyte> ShiftLeft(Vector128<sbyte> vector, int shiftCount); + public static Vector128<ushort> ShiftLeft(Vector128<ushort> vector, int shiftCount); + public static Vector128<uint> ShiftLeft(Vector128<uint> vector, int shiftCount); + public static Vector128<ulong> ShiftLeft(Vector128<ulong> vector, int shiftCount); + public static Vector128<UIntPtr> ShiftLeft(Vector128<UIntPtr> vector, int shiftCount); + public static Vector128<short> ShiftRightArithmetic(Vector128<short> vector, int shiftCount); + public static Vector128<int> ShiftRightArithmetic(Vector128<int> vector, int shiftCount); + public static Vector128<long> ShiftRightArithmetic(Vector128<long> vector, int shiftCount); + public static Vector128<IntPtr> ShiftRightArithmetic(Vector128<IntPtr> vector, int shiftCount); + public static Vector128<sbyte> ShiftRightArithmetic(Vector128<sbyte> vector, int shiftCount); + public static Vector128<byte> ShiftRightLogical(Vector128<byte> vector, int shiftCount); + public static Vector128<short> ShiftRightLogical(Vector128<short> vector, int shiftCount); + public static Vector128<int> ShiftRightLogical(Vector128<int> vector, int shiftCount); + public static Vector128<long> ShiftRightLogical(Vector128<long> vector, int shiftCount); + public static Vector128<IntPtr> ShiftRightLogical(Vector128<IntPtr> vector, int shiftCount); + public static Vector128<sbyte> ShiftRightLogical(Vector128<sbyte> vector, int shiftCount); + public static Vector128<ushort> ShiftRightLogical(Vector128<ushort> vector, int shiftCount); + public static Vector128<uint> ShiftRightLogical(Vector128<uint> vector, int shiftCount); + public static Vector128<ulong> ShiftRightLogical(Vector128<ulong> vector, int shiftCount); + public static Vector128<UIntPtr> ShiftRightLogical(Vector128<UIntPtr> vector, int shiftCount); + public static Vector128<byte> Shuffle(Vector128<byte> vector, Vector128<byte> indices); + public static Vector128<double> Shuffle(Vector128<double> vector, Vector128<long> indices); + public static Vector128<short> Shuffle(Vector128<short> vector, Vector128<short> indices); + public static Vector128<int> Shuffle(Vector128<int> vector, Vector128<int> indices); + public static Vector128<long> Shuffle(Vector128<long> vector, Vector128<long> indices); + public static Vector128<sbyte> Shuffle(Vector128<sbyte> vector, Vector128<sbyte> indices); + public static Vector128<float> Shuffle(Vector128<float> vector, Vector128<int> indices); + public static Vector128<ushort> Shuffle(Vector128<ushort> vector, Vector128<ushort> indices); + public static Vector128<uint> Shuffle(Vector128<uint> vector, Vector128<uint> indices); + public static Vector128<ulong> Shuffle(Vector128<ulong> vector, Vector128<ulong> indices); + public static Vector128<T> Sqrt<T>(Vector128<T> vector) where T : struct; + public unsafe static void Store<T>(this Vector128<T> source, T* destination) where T : struct; + public unsafe static void StoreAligned<T>(this Vector128<T> source, T* destination) where T : struct; + public unsafe static void StoreAlignedNonTemporal<T>(this Vector128<T> source, T* destination) where T : struct; + public static void StoreUnsafe<T>(this Vector128<T> source, ref T destination) where T : struct; + public static void StoreUnsafe<T>(this Vector128<T> source, ref T destination, UIntPtr elementOffset) where T : struct; + public static Vector128<T> Subtract<T>(Vector128<T> left, Vector128<T> right) where T : struct; + public static T Sum<T>(Vector128<T> vector) where T : struct; + public static bool TryCopyTo<T>(this Vector128<T> vector, Span<T> destination) where T : struct; + public static (Vector128<ushort> Lower, Vector128<ushort> Upper) Widen(Vector128<byte> source); + public static (Vector128<int> Lower, Vector128<int> Upper) Widen(Vector128<short> source); + public static (Vector128<long> Lower, Vector128<long> Upper) Widen(Vector128<int> source); + public static (Vector128<short> Lower, Vector128<short> Upper) Widen(Vector128<sbyte> source); + public static (Vector128<double> Lower, Vector128<double> Upper) Widen(Vector128<float> source); + public static (Vector128<uint> Lower, Vector128<uint> Upper) Widen(Vector128<ushort> source); + public static (Vector128<ulong> Lower, Vector128<ulong> Upper) Widen(Vector128<uint> source); + public static Vector128<T> Xor<T>(Vector128<T> left, Vector128<T> right) where T : struct; } public readonly struct Vector128<T> : IEquatable<Vector128<T>> where T : struct { + public static bool IsSupported { get; } + public T this[int index] { get; } + public static Vector128<T> operator +(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator &(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator |(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator /(Vector128<T> left, Vector128<T> right); + public static bool operator ==(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator ^(Vector128<T> left, Vector128<T> right); + public static bool operator !=(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator *(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator *(Vector128<T> left, T right); + public static Vector128<T> operator *(T left, Vector128<T> right); + public static Vector128<T> operator ~(Vector128<T> vector); + public static Vector128<T> operator -(Vector128<T> left, Vector128<T> right); + public static Vector128<T> operator -(Vector128<T> vector); + public static Vector128<T> operator +(Vector128<T> value); } public static class Vector256 { + public static bool IsHardwareAccelerated { get; } + public static Vector256<T> Abs<T>(Vector256<T> vector) where T : struct; + public static Vector256<T> Add<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> AndNot<T>(Vector256<T> left, Vector256<T> right) where T : struct; - public static Vector256<U> As<T, U>(this Vector256<T> vector) where T : struct where U : struct; + public static Vector256<TTo> As<TFrom, TTo>(this Vector256<TFrom> vector) where TFrom : struct where TTo : struct; + public static Vector256<IntPtr> AsNInt<T>(this Vector256<T> vector) where T : struct; + public static Vector256<UIntPtr> AsNUInt<T>(this Vector256<T> vector) where T : struct; + public static Vector256<T> BitwiseAnd<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> BitwiseOr<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<double> Ceiling(Vector256<double> vector); + public static Vector256<float> Ceiling(Vector256<float> vector); + public static Vector256<T> ConditionalSelect<T>(Vector256<T> condition, Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<double> ConvertToDouble(Vector256<long> vector); + public static Vector256<double> ConvertToDouble(Vector256<ulong> vector); + public static Vector256<int> ConvertToInt32(Vector256<float> vector); + public static Vector256<long> ConvertToInt64(Vector256<double> vector); + public static Vector256<float> ConvertToSingle(Vector256<int> vector); + public static Vector256<float> ConvertToSingle(Vector256<uint> vector); + public static Vector256<uint> ConvertToUInt32(Vector256<float> vector); + public static Vector256<ulong> ConvertToUInt64(Vector256<double> vector); + public static void CopyTo<T>(this Vector256<T> vector, Span<T> destination) where T : struct; + public static void CopyTo<T>(this Vector256<T> vector, T[] destination) where T : struct; + public static void CopyTo<T>(this Vector256<T> vector, T[] destination, int startIndex) where T : struct; + public static Vector256<IntPtr> Create(IntPtr value); + public static Vector256<UIntPtr> Create(UIntPtr value); + public static Vector256<T> Create<T>(ReadOnlySpan<T> values) where T : struct; + public static Vector256<T> Create<T>(T value) where T : struct; + public static Vector256<T> Create<T>(T[] values) where T : struct; + public static Vector256<T> Create<T>(T[] values, int index) where T : struct; + public static Vector256<IntPtr> CreateScalar(IntPtr value); + public static Vector256<UIntPtr> CreateScalar(UIntPtr value); + public static Vector256<IntPtr> CreateScalarUnsafe(IntPtr value); + public static Vector256<UIntPtr> CreateScalarUnsafe(UIntPtr value); + public static Vector256<T> Divide<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static T Dot<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Equals<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool EqualsAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool EqualsAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static uint ExtractMostSignificantBits<T>(this Vector256<T> vector) where T : struct; + public static Vector256<double> Floor(Vector256<double> vector); + public static Vector256<float> Floor(Vector256<float> vector); + public static Vector256<T> GreaterThan<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> GreaterThanOrEqual<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanOrEqualAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool GreaterThanOrEqualAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> LessThan<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> LessThanOrEqual<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanOrEqualAll<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static bool LessThanOrEqualAny<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public unsafe static Vector256<T> Load<T>(T* source) where T : struct; + public unsafe static Vector256<T> LoadAligned<T>(T* source) where T : struct; + public unsafe static Vector256<T> LoadAlignedNonTemporal<T>(T* source) where T : struct; + public static Vector256<T> LoadUnsafe<T>(ref T source) where T : struct; + public static Vector256<T> LoadUnsafe<T>(ref T source, UIntPtr elementOffset) where T : struct; + public static Vector256<T> Max<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Min<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Multiply<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static Vector256<T> Multiply<T>(Vector256<T> left, T right) where T : struct; + public static Vector256<T> Multiply<T>(T left, Vector256<T> right) where T : struct; + public static Vector256<float> Narrow(Vector256<double> lower, Vector256<double> upper); + public static Vector256<sbyte> Narrow(Vector256<short> lower, Vector256<short> upper); + public static Vector256<short> Narrow(Vector256<int> lower, Vector256<int> upper); + public static Vector256<int> Narrow(Vector256<long> lower, Vector256<long> upper); + public static Vector256<byte> Narrow(Vector256<ushort> lower, Vector256<ushort> upper); + public static Vector256<ushort> Narrow(Vector256<uint> lower, Vector256<uint> upper); + public static Vector256<uint> Narrow(Vector256<ulong> lower, Vector256<ulong> upper); + public static Vector256<T> Negate<T>(Vector256<T> vector) where T : struct; + public static Vector256<T> OnesComplement<T>(Vector256<T> vector) where T : struct; + public static Vector256<byte> ShiftLeft(Vector256<byte> vector, int shiftCount); + public static Vector256<short> ShiftLeft(Vector256<short> vector, int shiftCount); + public static Vector256<int> ShiftLeft(Vector256<int> vector, int shiftCount); + public static Vector256<long> ShiftLeft(Vector256<long> vector, int shiftCount); + public static Vector256<IntPtr> ShiftLeft(Vector256<IntPtr> vector, int shiftCount); + public static Vector256<sbyte> ShiftLeft(Vector256<sbyte> vector, int shiftCount); + public static Vector256<ushort> ShiftLeft(Vector256<ushort> vector, int shiftCount); + public static Vector256<uint> ShiftLeft(Vector256<uint> vector, int shiftCount); + public static Vector256<ulong> ShiftLeft(Vector256<ulong> vector, int shiftCount); + public static Vector256<UIntPtr> ShiftLeft(Vector256<UIntPtr> vector, int shiftCount); + public static Vector256<short> ShiftRightArithmetic(Vector256<short> vector, int shiftCount); + public static Vector256<int> ShiftRightArithmetic(Vector256<int> vector, int shiftCount); + public static Vector256<long> ShiftRightArithmetic(Vector256<long> vector, int shiftCount); + public static Vector256<IntPtr> ShiftRightArithmetic(Vector256<IntPtr> vector, int shiftCount); + public static Vector256<sbyte> ShiftRightArithmetic(Vector256<sbyte> vector, int shiftCount); + public static Vector256<byte> ShiftRightLogical(Vector256<byte> vector, int shiftCount); + public static Vector256<short> ShiftRightLogical(Vector256<short> vector, int shiftCount); + public static Vector256<int> ShiftRightLogical(Vector256<int> vector, int shiftCount); + public static Vector256<long> ShiftRightLogical(Vector256<long> vector, int shiftCount); + public static Vector256<IntPtr> ShiftRightLogical(Vector256<IntPtr> vector, int shiftCount); + public static Vector256<sbyte> ShiftRightLogical(Vector256<sbyte> vector, int shiftCount); + public static Vector256<ushort> ShiftRightLogical(Vector256<ushort> vector, int shiftCount); + public static Vector256<uint> ShiftRightLogical(Vector256<uint> vector, int shiftCount); + public static Vector256<ulong> ShiftRightLogical(Vector256<ulong> vector, int shiftCount); + public static Vector256<UIntPtr> ShiftRightLogical(Vector256<UIntPtr> vector, int shiftCount); + public static Vector256<byte> Shuffle(Vector256<byte> vector, Vector256<byte> indices); + public static Vector256<double> Shuffle(Vector256<double> vector, Vector256<long> indices); + public static Vector256<short> Shuffle(Vector256<short> vector, Vector256<short> indices); + public static Vector256<int> Shuffle(Vector256<int> vector, Vector256<int> indices); + public static Vector256<long> Shuffle(Vector256<long> vector, Vector256<long> indices); + public static Vector256<sbyte> Shuffle(Vector256<sbyte> vector, Vector256<sbyte> indices); + public static Vector256<float> Shuffle(Vector256<float> vector, Vector256<int> indices); + public static Vector256<ushort> Shuffle(Vector256<ushort> vector, Vector256<ushort> indices); + public static Vector256<uint> Shuffle(Vector256<uint> vector, Vector256<uint> indices); + public static Vector256<ulong> Shuffle(Vector256<ulong> vector, Vector256<ulong> indices); + public static Vector256<T> Sqrt<T>(Vector256<T> vector) where T : struct; + public unsafe static void Store<T>(this Vector256<T> source, T* destination) where T : struct; + public unsafe static void StoreAligned<T>(this Vector256<T> source, T* destination) where T : struct; + public unsafe static void StoreAlignedNonTemporal<T>(this Vector256<T> source, T* destination) where T : struct; + public static void StoreUnsafe<T>(this Vector256<T> source, ref T destination) where T : struct; + public static void StoreUnsafe<T>(this Vector256<T> source, ref T destination, UIntPtr elementOffset) where T : struct; + public static Vector256<T> Subtract<T>(Vector256<T> left, Vector256<T> right) where T : struct; + public static T Sum<T>(Vector256<T> vector) where T : struct; + public static bool TryCopyTo<T>(this Vector256<T> vector, Span<T> destination) where T : struct; + public static (Vector256<ushort> Lower, Vector256<ushort> Upper) Widen(Vector256<byte> source); + public static (Vector256<int> Lower, Vector256<int> Upper) Widen(Vector256<short> source); + public static (Vector256<long> Lower, Vector256<long> Upper) Widen(Vector256<int> source); + public static (Vector256<short> Lower, Vector256<short> Upper) Widen(Vector256<sbyte> source); + public static (Vector256<double> Lower, Vector256<double> Upper) Widen(Vector256<float> source); + public static (Vector256<uint> Lower, Vector256<uint> Upper) Widen(Vector256<ushort> source); + public static (Vector256<ulong> Lower, Vector256<ulong> Upper) Widen(Vector256<uint> source); + public static Vector256<T> Xor<T>(Vector256<T> left, Vector256<T> right) where T : struct; } public readonly struct Vector256<T> : IEquatable<Vector256<T>> where T : struct { + public static bool IsSupported { get; } + public T this[int index] { get; } + public static Vector256<T> operator +(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator &(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator |(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator /(Vector256<T> left, Vector256<T> right); + public static bool operator ==(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator ^(Vector256<T> left, Vector256<T> right); + public static bool operator !=(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator *(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator *(Vector256<T> left, T right); + public static Vector256<T> operator *(T left, Vector256<T> right); + public static Vector256<T> operator ~(Vector256<T> vector); + public static Vector256<T> operator -(Vector256<T> left, Vector256<T> right); + public static Vector256<T> operator -(Vector256<T> vector); + public static Vector256<T> operator +(Vector256<T> value); } public static class Vector64 { + public static bool IsHardwareAccelerated { get; } + public static Vector64<T> Abs<T>(Vector64<T> vector) where T : struct; + public static Vector64<T> Add<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> AndNot<T>(Vector64<T> left, Vector64<T> right) where T : struct; - public static Vector64<U> As<T, U>(this Vector64<T> vector) where T : struct where U : struct; + public static Vector64<TTo> As<TFrom, TTo>(this Vector64<TFrom> vector) where TFrom : struct where TTo : struct; + public static Vector64<IntPtr> AsNInt<T>(this Vector64<T> vector) where T : struct; + public static Vector64<UIntPtr> AsNUInt<T>(this Vector64<T> vector) where T : struct; + public static Vector64<T> BitwiseAnd<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> BitwiseOr<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<double> Ceiling(Vector64<double> vector); + public static Vector64<float> Ceiling(Vector64<float> vector); + public static Vector64<T> ConditionalSelect<T>(Vector64<T> condition, Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<double> ConvertToDouble(Vector64<long> vector); + public static Vector64<double> ConvertToDouble(Vector64<ulong> vector); + public static Vector64<int> ConvertToInt32(Vector64<float> vector); + public static Vector64<long> ConvertToInt64(Vector64<double> vector); + public static Vector64<float> ConvertToSingle(Vector64<int> vector); + public static Vector64<float> ConvertToSingle(Vector64<uint> vector); + public static Vector64<uint> ConvertToUInt32(Vector64<float> vector); + public static Vector64<ulong> ConvertToUInt64(Vector64<double> vector); + public static void CopyTo<T>(this Vector64<T> vector, Span<T> destination) where T : struct; + public static void CopyTo<T>(this Vector64<T> vector, T[] destination) where T : struct; + public static void CopyTo<T>(this Vector64<T> vector, T[] destination, int startIndex) where T : struct; + public static Vector64<IntPtr> Create(IntPtr value); + public static Vector64<UIntPtr> Create(UIntPtr value); + public static Vector64<T> Create<T>(ReadOnlySpan<T> values) where T : struct; + public static Vector64<T> Create<T>(T value) where T : struct; + public static Vector64<T> Create<T>(T[] values) where T : struct; + public static Vector64<T> Create<T>(T[] values, int index) where T : struct; + public static Vector64<IntPtr> CreateScalar(IntPtr value); + public static Vector64<UIntPtr> CreateScalar(UIntPtr value); + public static Vector64<IntPtr> CreateScalarUnsafe(IntPtr value); + public static Vector64<UIntPtr> CreateScalarUnsafe(UIntPtr value); + public static Vector64<T> Divide<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static T Dot<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Equals<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool EqualsAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool EqualsAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static uint ExtractMostSignificantBits<T>(this Vector64<T> vector) where T : struct; + public static Vector64<double> Floor(Vector64<double> vector); + public static Vector64<float> Floor(Vector64<float> vector); + public static Vector64<T> GreaterThan<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> GreaterThanOrEqual<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanOrEqualAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool GreaterThanOrEqualAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> LessThan<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> LessThanOrEqual<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanOrEqualAll<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static bool LessThanOrEqualAny<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public unsafe static Vector64<T> Load<T>(T* source) where T : struct; + public unsafe static Vector64<T> LoadAligned<T>(T* source) where T : struct; + public unsafe static Vector64<T> LoadAlignedNonTemporal<T>(T* source) where T : struct; + public static Vector64<T> LoadUnsafe<T>(ref T source) where T : struct; + public static Vector64<T> LoadUnsafe<T>(ref T source, UIntPtr elementOffset) where T : struct; + public static Vector64<T> Max<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Min<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Multiply<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static Vector64<T> Multiply<T>(Vector64<T> left, T right) where T : struct; + public static Vector64<T> Multiply<T>(T left, Vector64<T> right) where T : struct; + public static Vector64<float> Narrow(Vector64<double> lower, Vector64<double> upper); + public static Vector64<sbyte> Narrow(Vector64<short> lower, Vector64<short> upper); + public static Vector64<short> Narrow(Vector64<int> lower, Vector64<int> upper); + public static Vector64<int> Narrow(Vector64<long> lower, Vector64<long> upper); + public static Vector64<byte> Narrow(Vector64<ushort> lower, Vector64<ushort> upper); + public static Vector64<ushort> Narrow(Vector64<uint> lower, Vector64<uint> upper); + public static Vector64<uint> Narrow(Vector64<ulong> lower, Vector64<ulong> upper); + public static Vector64<T> Negate<T>(Vector64<T> vector) where T : struct; + public static Vector64<T> OnesComplement<T>(Vector64<T> vector) where T : struct; + public static Vector64<byte> ShiftLeft(Vector64<byte> vector, int shiftCount); + public static Vector64<short> ShiftLeft(Vector64<short> vector, int shiftCount); + public static Vector64<int> ShiftLeft(Vector64<int> vector, int shiftCount); + public static Vector64<long> ShiftLeft(Vector64<long> vector, int shiftCount); + public static Vector64<IntPtr> ShiftLeft(Vector64<IntPtr> vector, int shiftCount); + public static Vector64<sbyte> ShiftLeft(Vector64<sbyte> vector, int shiftCount); + public static Vector64<ushort> ShiftLeft(Vector64<ushort> vector, int shiftCount); + public static Vector64<uint> ShiftLeft(Vector64<uint> vector, int shiftCount); + public static Vector64<ulong> ShiftLeft(Vector64<ulong> vector, int shiftCount); + public static Vector64<UIntPtr> ShiftLeft(Vector64<UIntPtr> vector, int shiftCount); + public static Vector64<short> ShiftRightArithmetic(Vector64<short> vector, int shiftCount); + public static Vector64<int> ShiftRightArithmetic(Vector64<int> vector, int shiftCount); + public static Vector64<long> ShiftRightArithmetic(Vector64<long> vector, int shiftCount); + public static Vector64<IntPtr> ShiftRightArithmetic(Vector64<IntPtr> vector, int shiftCount); + public static Vector64<sbyte> ShiftRightArithmetic(Vector64<sbyte> vector, int shiftCount); + public static Vector64<byte> ShiftRightLogical(Vector64<byte> vector, int shiftCount); + public static Vector64<short> ShiftRightLogical(Vector64<short> vector, int shiftCount); + public static Vector64<int> ShiftRightLogical(Vector64<int> vector, int shiftCount); + public static Vector64<long> ShiftRightLogical(Vector64<long> vector, int shiftCount); + public static Vector64<IntPtr> ShiftRightLogical(Vector64<IntPtr> vector, int shiftCount); + public static Vector64<sbyte> ShiftRightLogical(Vector64<sbyte> vector, int shiftCount); + public static Vector64<ushort> ShiftRightLogical(Vector64<ushort> vector, int shiftCount); + public static Vector64<uint> ShiftRightLogical(Vector64<uint> vector, int shiftCount); + public static Vector64<ulong> ShiftRightLogical(Vector64<ulong> vector, int shiftCount); + public static Vector64<UIntPtr> ShiftRightLogical(Vector64<UIntPtr> vector, int shiftCount); + public static Vector64<byte> Shuffle(Vector64<byte> vector, Vector64<byte> indices); + public static Vector64<short> Shuffle(Vector64<short> vector, Vector64<short> indices); + public static Vector64<int> Shuffle(Vector64<int> vector, Vector64<int> indices); + public static Vector64<sbyte> Shuffle(Vector64<sbyte> vector, Vector64<sbyte> indices); + public static Vector64<float> Shuffle(Vector64<float> vector, Vector64<int> indices); + public static Vector64<ushort> Shuffle(Vector64<ushort> vector, Vector64<ushort> indices); + public static Vector64<uint> Shuffle(Vector64<uint> vector, Vector64<uint> indices); + public static Vector64<T> Sqrt<T>(Vector64<T> vector) where T : struct; + public unsafe static void Store<T>(this Vector64<T> source, T* destination) where T : struct; + public unsafe static void StoreAligned<T>(this Vector64<T> source, T* destination) where T : struct; + public unsafe static void StoreAlignedNonTemporal<T>(this Vector64<T> source, T* destination) where T : struct; + public static void StoreUnsafe<T>(this Vector64<T> source, ref T destination) where T : struct; + public static void StoreUnsafe<T>(this Vector64<T> source, ref T destination, UIntPtr elementOffset) where T : struct; + public static Vector64<T> Subtract<T>(Vector64<T> left, Vector64<T> right) where T : struct; + public static T Sum<T>(Vector64<T> vector) where T : struct; + public static bool TryCopyTo<T>(this Vector64<T> vector, Span<T> destination) where T : struct; + public static (Vector64<ushort> Lower, Vector64<ushort> Upper) Widen(Vector64<byte> source); + public static (Vector64<int> Lower, Vector64<int> Upper) Widen(Vector64<short> source); + public static (Vector64<long> Lower, Vector64<long> Upper) Widen(Vector64<int> source); + public static (Vector64<short> Lower, Vector64<short> Upper) Widen(Vector64<sbyte> source); + public static (Vector64<double> Lower, Vector64<double> Upper) Widen(Vector64<float> source); + public static (Vector64<uint> Lower, Vector64<uint> Upper) Widen(Vector64<ushort> source); + public static (Vector64<ulong> Lower, Vector64<ulong> Upper) Widen(Vector64<uint> source); + public static Vector64<T> Xor<T>(Vector64<T> left, Vector64<T> right) where T : struct; } public readonly struct Vector64<T> : IEquatable<Vector64<T>> where T : struct { + public static bool IsSupported { get; } + public T this[int index] { get; } + public static Vector64<T> operator +(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator &(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator |(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator /(Vector64<T> left, Vector64<T> right); + public static bool operator ==(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator ^(Vector64<T> left, Vector64<T> right); + public static bool operator !=(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator *(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator *(Vector64<T> left, T right); + public static Vector64<T> operator *(T left, Vector64<T> right); + public static Vector64<T> operator ~(Vector64<T> vector); + public static Vector64<T> operator -(Vector64<T> left, Vector64<T> right); + public static Vector64<T> operator -(Vector64<T> vector); + public static Vector64<T> operator +(Vector64<T> value); } }","title":"System.Runtime.Intrinsics"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Serialization.DataContracts/","text":"System.Runtime.Serialization.DataContracts +namespace System.Runtime.Serialization.DataContracts { + public abstract class DataContract { + public virtual DataContract? BaseContract { get; } + public virtual string? ContractType { get; } + public virtual ReadOnlyCollection<DataMember> DataMembers { get; } + public virtual bool IsBuiltInDataContract { get; } + public virtual bool IsISerializable { get; } + public virtual bool IsReference { get; } + public virtual bool IsValueType { get; } + public virtual Dictionary<XmlQualifiedName, DataContract>? KnownDataContracts { get; } + public virtual Type OriginalUnderlyingType { get; } + public virtual XmlDictionaryString? TopLevelElementName { get; } + public virtual XmlDictionaryString? TopLevelElementNamespace { get; } + public virtual Type UnderlyingType { get; } + public virtual XmlQualifiedName XmlName { get; } + public virtual XmlQualifiedName GetArrayTypeName(bool isNullable); + public static DataContract? GetBuiltInDataContract(string name, string ns); + public static XmlQualifiedName GetXmlName(Type type); + public virtual bool IsDictionaryLike(out string? keyName, out string? valueName, out string? itemName); + } + public sealed class DataContractSet { + public DataContractSet(DataContractSet dataContractSet); + public DataContractSet(ISerializationSurrogateProvider? dataContractSurrogate, IEnumerable<Type>? referencedTypes, IEnumerable<Type>? referencedCollectionTypes); + public Dictionary<XmlQualifiedName, DataContract> Contracts { get; } + public Dictionary<XmlQualifiedName, DataContract>? KnownTypesForObject { get; } + public Dictionary<DataContract, object> ProcessedContracts { get; } + public Hashtable SurrogateData { get; } + public DataContract GetDataContract(Type type); + public DataContract? GetDataContract(XmlQualifiedName key); + public Type? GetReferencedType(XmlQualifiedName xmlName, DataContract dataContract, out DataContract? referencedContract, out object[]? genericParameters, bool? supportGenericTypes = default(bool?)); + public List<XmlQualifiedName> ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable<XmlSchemaElement> elements, bool importXmlDataType); + public void ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable<XmlQualifiedName>? typeNames, bool importXmlDataType); + } + public sealed class DataMember { + public bool EmitDefaultValue { get; } + public bool IsNullable { get; } + public bool IsRequired { get; } + public DataContract MemberTypeContract { get; } + public string Name { get; } + public long Order { get; } + } + public sealed class XmlDataContract : DataContract { + public bool HasRoot { get; } + public bool IsAnonymous { get; } + public bool IsTopLevelElementNullable { get; } + public bool IsTypeDefinedOnImport { get; set; } + public new bool IsValueType { get; set; } + public XmlSchemaType XsdType { get; } + } +}","title":"System.Runtime.Serialization.DataContracts"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Serialization.DataContracts/#systemruntimeserializationdatacontracts","text":"+namespace System.Runtime.Serialization.DataContracts { + public abstract class DataContract { + public virtual DataContract? BaseContract { get; } + public virtual string? ContractType { get; } + public virtual ReadOnlyCollection<DataMember> DataMembers { get; } + public virtual bool IsBuiltInDataContract { get; } + public virtual bool IsISerializable { get; } + public virtual bool IsReference { get; } + public virtual bool IsValueType { get; } + public virtual Dictionary<XmlQualifiedName, DataContract>? KnownDataContracts { get; } + public virtual Type OriginalUnderlyingType { get; } + public virtual XmlDictionaryString? TopLevelElementName { get; } + public virtual XmlDictionaryString? TopLevelElementNamespace { get; } + public virtual Type UnderlyingType { get; } + public virtual XmlQualifiedName XmlName { get; } + public virtual XmlQualifiedName GetArrayTypeName(bool isNullable); + public static DataContract? GetBuiltInDataContract(string name, string ns); + public static XmlQualifiedName GetXmlName(Type type); + public virtual bool IsDictionaryLike(out string? keyName, out string? valueName, out string? itemName); + } + public sealed class DataContractSet { + public DataContractSet(DataContractSet dataContractSet); + public DataContractSet(ISerializationSurrogateProvider? dataContractSurrogate, IEnumerable<Type>? referencedTypes, IEnumerable<Type>? referencedCollectionTypes); + public Dictionary<XmlQualifiedName, DataContract> Contracts { get; } + public Dictionary<XmlQualifiedName, DataContract>? KnownTypesForObject { get; } + public Dictionary<DataContract, object> ProcessedContracts { get; } + public Hashtable SurrogateData { get; } + public DataContract GetDataContract(Type type); + public DataContract? GetDataContract(XmlQualifiedName key); + public Type? GetReferencedType(XmlQualifiedName xmlName, DataContract dataContract, out DataContract? referencedContract, out object[]? genericParameters, bool? supportGenericTypes = default(bool?)); + public List<XmlQualifiedName> ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable<XmlSchemaElement> elements, bool importXmlDataType); + public void ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable<XmlQualifiedName>? typeNames, bool importXmlDataType); + } + public sealed class DataMember { + public bool EmitDefaultValue { get; } + public bool IsNullable { get; } + public bool IsRequired { get; } + public DataContract MemberTypeContract { get; } + public string Name { get; } + public long Order { get; } + } + public sealed class XmlDataContract : DataContract { + public bool HasRoot { get; } + public bool IsAnonymous { get; } + public bool IsTopLevelElementNullable { get; } + public bool IsTypeDefinedOnImport { get; set; } + public new bool IsValueType { get; set; } + public XmlSchemaType XsdType { get; } + } +}","title":"System.Runtime.Serialization.DataContracts"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Serialization.Json/","text":"System.Runtime.Serialization.Json namespace System.Runtime.Serialization.Json { public sealed class DataContractJsonSerializer : XmlObjectSerializer { + public ISerializationSurrogateProvider? GetSerializationSurrogateProvider(); + public void SetSerializationSurrogateProvider(ISerializationSurrogateProvider? provider); } }","title":"System.Runtime.Serialization.Json"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Serialization.Json/#systemruntimeserializationjson","text":"namespace System.Runtime.Serialization.Json { public sealed class DataContractJsonSerializer : XmlObjectSerializer { + public ISerializationSurrogateProvider? GetSerializationSurrogateProvider(); + public void SetSerializationSurrogateProvider(ISerializationSurrogateProvider? provider); } }","title":"System.Runtime.Serialization.Json"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Serialization/","text":"System.Runtime.Serialization namespace System.Runtime.Serialization { public class ExportOptions { + public ISerializationSurrogateProvider DataContractSurrogate { get; set; } } + public interface ISerializationSurrogateProvider2 : ISerializationSurrogateProvider { + object? GetCustomDataToExport(MemberInfo memberInfo, Type dataContractType); + object? GetCustomDataToExport(Type runtimeType, Type dataContractType); + void GetKnownCustomDataTypes(Collection<Type> customDataTypes); + Type? GetReferencedTypeOnImport(string typeName, string typeNamespace, object? customData); + } }","title":"System.Runtime.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Serialization/#systemruntimeserialization","text":"namespace System.Runtime.Serialization { public class ExportOptions { + public ISerializationSurrogateProvider DataContractSurrogate { get; set; } } + public interface ISerializationSurrogateProvider2 : ISerializationSurrogateProvider { + object? GetCustomDataToExport(MemberInfo memberInfo, Type dataContractType); + object? GetCustomDataToExport(Type runtimeType, Type dataContractType); + void GetKnownCustomDataTypes(Collection<Type> customDataTypes); + Type? GetReferencedTypeOnImport(string typeName, string typeNamespace, object? customData); + } }","title":"System.Runtime.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Versioning/","text":"System.Runtime.Versioning namespace System.Runtime.Versioning { + public sealed class ObsoletedOSPlatformAttribute : OSPlatformAttribute { + public ObsoletedOSPlatformAttribute(string platformName); + public ObsoletedOSPlatformAttribute(string platformName, string? message); + public string Message { get; } + public string Url { get; set; } + } public abstract class OSPlatformAttribute : Attribute { public string PlatformName { get; } } public sealed class UnsupportedOSPlatformAttribute : OSPlatformAttribute { + public UnsupportedOSPlatformAttribute(string platformName, string? message); + public string? Message { get; } } }","title":"System.Runtime.Versioning"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime.Versioning/#systemruntimeversioning","text":"namespace System.Runtime.Versioning { + public sealed class ObsoletedOSPlatformAttribute : OSPlatformAttribute { + public ObsoletedOSPlatformAttribute(string platformName); + public ObsoletedOSPlatformAttribute(string platformName, string? message); + public string Message { get; } + public string Url { get; set; } + } public abstract class OSPlatformAttribute : Attribute { public string PlatformName { get; } } public sealed class UnsupportedOSPlatformAttribute : OSPlatformAttribute { + public UnsupportedOSPlatformAttribute(string platformName, string? message); + public string? Message { get; } } }","title":"System.Runtime.Versioning"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime/","text":"System.Runtime namespace System.Runtime { + public static class ControlledExecution { + public static void Run(Action action, CancellationToken cancellationToken); + } }","title":"System.Runtime"},{"location":"Microsoft.NETCore.App/7.0_System.Runtime/#systemruntime","text":"namespace System.Runtime { + public static class ControlledExecution { + public static void Run(Action action, CancellationToken cancellationToken); + } }","title":"System.Runtime"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Authentication.ExtendedProtection/","text":"System.Security.Authentication.ExtendedProtection namespace System.Security.Authentication.ExtendedProtection { public class ExtendedProtectionPolicyTypeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Security.Authentication.ExtendedProtection"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Authentication.ExtendedProtection/#systemsecurityauthenticationextendedprotection","text":"namespace System.Security.Authentication.ExtendedProtection { public class ExtendedProtectionPolicyTypeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Security.Authentication.ExtendedProtection"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Authentication/","text":"System.Security.Authentication namespace System.Security.Authentication { public enum SslProtocols { Tls = 192, Tls11 = 768, } }","title":"System.Security.Authentication"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Authentication/#systemsecurityauthentication","text":"namespace System.Security.Authentication { public enum SslProtocols { Tls = 192, Tls11 = 768, } }","title":"System.Security.Authentication"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Cryptography.X509Certificates/","text":"System.Security.Cryptography.X509Certificates namespace System.Security.Cryptography.X509Certificates { public sealed class CertificateRequest { + public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm, RSASignaturePadding? rsaSignaturePadding = null); + public Collection<AsnEncodedData> OtherRequestAttributes { get; } + public string CreateSigningRequestPem(); + public string CreateSigningRequestPem(X509SignatureGenerator signatureGenerator); + public static CertificateRequest LoadSigningRequest(byte[] pkcs10, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); + public static CertificateRequest LoadSigningRequest(ReadOnlySpan<byte> pkcs10, HashAlgorithmName signerHashAlgorithm, out int bytesConsumed, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); + public static CertificateRequest LoadSigningRequestPem(ReadOnlySpan<char> pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); + public static CertificateRequest LoadSigningRequestPem(string pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); } + public enum CertificateRequestLoadOptions { + Default = 0, + SkipSignatureValidation = 1, + UnsafeLoadCertificateExtensions = 2, + } + public sealed class CertificateRevocationListBuilder { + public CertificateRevocationListBuilder(); + public void AddEntry(byte[] serialNumber, DateTimeOffset? revocationTime = default(DateTimeOffset?), X509RevocationReason? reason = default(X509RevocationReason?)); + public void AddEntry(ReadOnlySpan<byte> serialNumber, DateTimeOffset? revocationTime = default(DateTimeOffset?), X509RevocationReason? reason = default(X509RevocationReason?)); + public void AddEntry(X509Certificate2 certificate, DateTimeOffset? revocationTime = default(DateTimeOffset?), X509RevocationReason? reason = default(X509RevocationReason?)); + public byte[] Build(X500DistinguishedName issuerName, X509SignatureGenerator generator, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, X509AuthorityKeyIdentifierExtension authorityKeyIdentifier, DateTimeOffset? thisUpdate = default(DateTimeOffset?)); + public byte[] Build(X509Certificate2 issuerCertificate, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, RSASignaturePadding? rsaSignaturePadding = null, DateTimeOffset? thisUpdate = default(DateTimeOffset?)); + public static X509Extension BuildCrlDistributionPointExtension(IEnumerable<string> uris, bool critical = false); + public static CertificateRevocationListBuilder Load(byte[] currentCrl, out BigInteger currentCrlNumber); + public static CertificateRevocationListBuilder Load(ReadOnlySpan<byte> currentCrl, out BigInteger currentCrlNumber, out int bytesConsumed); + public static CertificateRevocationListBuilder LoadPem(ReadOnlySpan<char> currentCrl, out BigInteger currentCrlNumber); + public static CertificateRevocationListBuilder LoadPem(string currentCrl, out BigInteger currentCrlNumber); + public bool RemoveEntry(byte[] serialNumber); + public bool RemoveEntry(ReadOnlySpan<byte> serialNumber); + } public sealed class PublicKey { public DSA? GetDSAPublicKey(); public ECDiffieHellman? GetECDiffieHellmanPublicKey(); public ECDsa? GetECDsaPublicKey(); public RSA? GetRSAPublicKey(); } public sealed class X500DistinguishedName : AsnEncodedData { + public IEnumerable<X500RelativeDistinguishedName> EnumerateRelativeDistinguishedNames(bool reversed = true); } + public sealed class X500DistinguishedNameBuilder { + public X500DistinguishedNameBuilder(); + public void Add(Oid oid, string value, UniversalTagNumber? stringEncodingType = default(UniversalTagNumber?)); + public void Add(string oidValue, string value, UniversalTagNumber? stringEncodingType = default(UniversalTagNumber?)); + public void AddCommonName(string commonName); + public void AddCountryOrRegion(string twoLetterCode); + public void AddDomainComponent(string domainComponent); + public void AddEmailAddress(string emailAddress); + public void AddLocalityName(string localityName); + public void AddOrganizationalUnitName(string organizationalUnitName); + public void AddOrganizationName(string organizationName); + public void AddStateOrProvinceName(string stateOrProvinceName); + public X500DistinguishedName Build(); + } + public sealed class X500RelativeDistinguishedName { + public bool HasMultipleElements { get; } + public ReadOnlyMemory<byte> RawData { get; } + public Oid GetSingleElementType(); + public string? GetSingleElementValue(); + } + public sealed class X509AuthorityInformationAccessExtension : X509Extension { + public X509AuthorityInformationAccessExtension(); + public X509AuthorityInformationAccessExtension(byte[] rawData, bool critical = false); + public X509AuthorityInformationAccessExtension(IEnumerable<string>? ocspUris, IEnumerable<string>? caIssuersUris, bool critical = false); + public X509AuthorityInformationAccessExtension(ReadOnlySpan<byte> rawData, bool critical = false); + public override void CopyFrom(AsnEncodedData asnEncodedData); + public IEnumerable<string> EnumerateCAIssuersUris(); + public IEnumerable<string> EnumerateOcspUris(); + public IEnumerable<string> EnumerateUris(Oid accessMethodOid); + public IEnumerable<string> EnumerateUris(string accessMethodOid); + } + public sealed class X509AuthorityKeyIdentifierExtension : X509Extension { + public X509AuthorityKeyIdentifierExtension(); + public X509AuthorityKeyIdentifierExtension(byte[] rawData, bool critical = false); + public X509AuthorityKeyIdentifierExtension(ReadOnlySpan<byte> rawData, bool critical = false); + public ReadOnlyMemory<byte>? KeyIdentifier { get; } + public X500DistinguishedName? NamedIssuer { get; } + public ReadOnlyMemory<byte>? RawIssuer { get; } + public ReadOnlyMemory<byte>? SerialNumber { get; } + public override void CopyFrom(AsnEncodedData asnEncodedData); + public static X509AuthorityKeyIdentifierExtension Create(byte[] keyIdentifier, X500DistinguishedName issuerName, byte[] serialNumber); + public static X509AuthorityKeyIdentifierExtension Create(ReadOnlySpan<byte> keyIdentifier, X500DistinguishedName issuerName, ReadOnlySpan<byte> serialNumber); + public static X509AuthorityKeyIdentifierExtension CreateFromCertificate(X509Certificate2 certificate, bool includeKeyIdentifier, bool includeIssuerAndSerial); + public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, byte[] serialNumber); + public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, ReadOnlySpan<byte> serialNumber); + public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(byte[] subjectKeyIdentifier); + public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(ReadOnlySpan<byte> subjectKeyIdentifier); + public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(X509SubjectKeyIdentifierExtension subjectKeyIdentifier); + } public sealed class X509BasicConstraintsExtension : X509Extension { + public static X509BasicConstraintsExtension CreateForCertificateAuthority(int? pathLengthConstraint = default(int?)); + public static X509BasicConstraintsExtension CreateForEndEntity(bool critical = false); } public class X509Certificate : IDeserializationCallback, IDisposable, ISerializable { public X509Certificate(); public X509Certificate(byte[] data); public X509Certificate(byte[] rawData, SecureString? password); public X509Certificate(byte[] rawData, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate(byte[] rawData, string? password); public X509Certificate(byte[] rawData, string? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate(IntPtr handle); public X509Certificate(X509Certificate cert); public X509Certificate(string fileName); public X509Certificate(string fileName, SecureString? password); public X509Certificate(string fileName, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate(string fileName, string? password); public X509Certificate(string fileName, string? password, X509KeyStorageFlags keyStorageFlags); + public ReadOnlyMemory<byte> SerialNumberBytes { get; } public static X509Certificate CreateFromCertFile(string filename); public static X509Certificate CreateFromSignedFile(string filename); } public class X509Certificate2 : X509Certificate { public X509Certificate2(); public X509Certificate2(byte[] rawData); public X509Certificate2(byte[] rawData, SecureString? password); public X509Certificate2(byte[] rawData, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate2(byte[] rawData, string? password); public X509Certificate2(byte[] rawData, string? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate2(IntPtr handle); public X509Certificate2(ReadOnlySpan<byte> rawData); public X509Certificate2(ReadOnlySpan<byte> rawData, ReadOnlySpan<char> password, X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet); public X509Certificate2(X509Certificate certificate); public X509Certificate2(string fileName); public X509Certificate2(string fileName, ReadOnlySpan<char> password, X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet); public X509Certificate2(string fileName, SecureString? password); public X509Certificate2(string fileName, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate2(string fileName, string? password); public X509Certificate2(string fileName, string? password, X509KeyStorageFlags keyStorageFlags); + public ReadOnlyMemory<byte> RawDataMemory { get; } public static X509Certificate2 CreateFromEncryptedPem(ReadOnlySpan<char> certPem, ReadOnlySpan<char> keyPem, ReadOnlySpan<char> password); public static X509Certificate2 CreateFromEncryptedPemFile(string certPemFilePath, ReadOnlySpan<char> password, string? keyPemFilePath = null); public static X509Certificate2 CreateFromPem(ReadOnlySpan<char> certPem); public static X509Certificate2 CreateFromPem(ReadOnlySpan<char> certPem, ReadOnlySpan<char> keyPem); public static X509Certificate2 CreateFromPemFile(string certPemFilePath, string? keyPemFilePath = null); + public string ExportCertificatePem(); public static X509ContentType GetCertContentType(byte[] rawData); public static X509ContentType GetCertContentType(ReadOnlySpan<byte> rawData); public static X509ContentType GetCertContentType(string fileName); + public bool MatchesHostname(string hostname, bool allowWildcards = true, bool allowCommonName = true); + public bool TryExportCertificatePem(Span<char> destination, out int charsWritten); } public class X509Certificate2Collection : X509CertificateCollection, IEnumerable, IEnumerable<X509Certificate2> { + public string ExportCertificatePems(); + public string ExportPkcs7Pem(); + public bool TryExportCertificatePems(Span<char> destination, out int charsWritten); + public bool TryExportPkcs7Pem(Span<char> destination, out int charsWritten); } public class X509Chain : IDisposable { public bool Build(X509Certificate2 certificate); } public sealed class X509ChainPolicy { + public bool VerificationTimeIgnored { get; set; } + public X509ChainPolicy Clone(); } + public enum X509RevocationReason { + AACompromise = 10, + AffiliationChanged = 3, + CACompromise = 2, + CertificateHold = 6, + CessationOfOperation = 5, + KeyCompromise = 1, + PrivilegeWithdrawn = 9, + RemoveFromCrl = 8, + Superseded = 4, + Unspecified = 0, + WeakAlgorithmOrKey = 11, + } + public sealed class X509SubjectAlternativeNameExtension : X509Extension { + public X509SubjectAlternativeNameExtension(); + public X509SubjectAlternativeNameExtension(byte[] rawData, bool critical = false); + public X509SubjectAlternativeNameExtension(ReadOnlySpan<byte> rawData, bool critical = false); + public override void CopyFrom(AsnEncodedData asnEncodedData); + public IEnumerable<string> EnumerateDnsNames(); + public IEnumerable<IPAddress> EnumerateIPAddresses(); + } public sealed class X509SubjectKeyIdentifierExtension : X509Extension { + public ReadOnlyMemory<byte> SubjectKeyIdentifierBytes { get; } } }","title":"System.Security.Cryptography.X509Certificates"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Cryptography.X509Certificates/#systemsecuritycryptographyx509certificates","text":"namespace System.Security.Cryptography.X509Certificates { public sealed class CertificateRequest { + public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm, RSASignaturePadding? rsaSignaturePadding = null); + public Collection<AsnEncodedData> OtherRequestAttributes { get; } + public string CreateSigningRequestPem(); + public string CreateSigningRequestPem(X509SignatureGenerator signatureGenerator); + public static CertificateRequest LoadSigningRequest(byte[] pkcs10, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); + public static CertificateRequest LoadSigningRequest(ReadOnlySpan<byte> pkcs10, HashAlgorithmName signerHashAlgorithm, out int bytesConsumed, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); + public static CertificateRequest LoadSigningRequestPem(ReadOnlySpan<char> pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); + public static CertificateRequest LoadSigningRequestPem(string pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options = CertificateRequestLoadOptions.Default, RSASignaturePadding? signerSignaturePadding = null); } + public enum CertificateRequestLoadOptions { + Default = 0, + SkipSignatureValidation = 1, + UnsafeLoadCertificateExtensions = 2, + } + public sealed class CertificateRevocationListBuilder { + public CertificateRevocationListBuilder(); + public void AddEntry(byte[] serialNumber, DateTimeOffset? revocationTime = default(DateTimeOffset?), X509RevocationReason? reason = default(X509RevocationReason?)); + public void AddEntry(ReadOnlySpan<byte> serialNumber, DateTimeOffset? revocationTime = default(DateTimeOffset?), X509RevocationReason? reason = default(X509RevocationReason?)); + public void AddEntry(X509Certificate2 certificate, DateTimeOffset? revocationTime = default(DateTimeOffset?), X509RevocationReason? reason = default(X509RevocationReason?)); + public byte[] Build(X500DistinguishedName issuerName, X509SignatureGenerator generator, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, X509AuthorityKeyIdentifierExtension authorityKeyIdentifier, DateTimeOffset? thisUpdate = default(DateTimeOffset?)); + public byte[] Build(X509Certificate2 issuerCertificate, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, RSASignaturePadding? rsaSignaturePadding = null, DateTimeOffset? thisUpdate = default(DateTimeOffset?)); + public static X509Extension BuildCrlDistributionPointExtension(IEnumerable<string> uris, bool critical = false); + public static CertificateRevocationListBuilder Load(byte[] currentCrl, out BigInteger currentCrlNumber); + public static CertificateRevocationListBuilder Load(ReadOnlySpan<byte> currentCrl, out BigInteger currentCrlNumber, out int bytesConsumed); + public static CertificateRevocationListBuilder LoadPem(ReadOnlySpan<char> currentCrl, out BigInteger currentCrlNumber); + public static CertificateRevocationListBuilder LoadPem(string currentCrl, out BigInteger currentCrlNumber); + public bool RemoveEntry(byte[] serialNumber); + public bool RemoveEntry(ReadOnlySpan<byte> serialNumber); + } public sealed class PublicKey { public DSA? GetDSAPublicKey(); public ECDiffieHellman? GetECDiffieHellmanPublicKey(); public ECDsa? GetECDsaPublicKey(); public RSA? GetRSAPublicKey(); } public sealed class X500DistinguishedName : AsnEncodedData { + public IEnumerable<X500RelativeDistinguishedName> EnumerateRelativeDistinguishedNames(bool reversed = true); } + public sealed class X500DistinguishedNameBuilder { + public X500DistinguishedNameBuilder(); + public void Add(Oid oid, string value, UniversalTagNumber? stringEncodingType = default(UniversalTagNumber?)); + public void Add(string oidValue, string value, UniversalTagNumber? stringEncodingType = default(UniversalTagNumber?)); + public void AddCommonName(string commonName); + public void AddCountryOrRegion(string twoLetterCode); + public void AddDomainComponent(string domainComponent); + public void AddEmailAddress(string emailAddress); + public void AddLocalityName(string localityName); + public void AddOrganizationalUnitName(string organizationalUnitName); + public void AddOrganizationName(string organizationName); + public void AddStateOrProvinceName(string stateOrProvinceName); + public X500DistinguishedName Build(); + } + public sealed class X500RelativeDistinguishedName { + public bool HasMultipleElements { get; } + public ReadOnlyMemory<byte> RawData { get; } + public Oid GetSingleElementType(); + public string? GetSingleElementValue(); + } + public sealed class X509AuthorityInformationAccessExtension : X509Extension { + public X509AuthorityInformationAccessExtension(); + public X509AuthorityInformationAccessExtension(byte[] rawData, bool critical = false); + public X509AuthorityInformationAccessExtension(IEnumerable<string>? ocspUris, IEnumerable<string>? caIssuersUris, bool critical = false); + public X509AuthorityInformationAccessExtension(ReadOnlySpan<byte> rawData, bool critical = false); + public override void CopyFrom(AsnEncodedData asnEncodedData); + public IEnumerable<string> EnumerateCAIssuersUris(); + public IEnumerable<string> EnumerateOcspUris(); + public IEnumerable<string> EnumerateUris(Oid accessMethodOid); + public IEnumerable<string> EnumerateUris(string accessMethodOid); + } + public sealed class X509AuthorityKeyIdentifierExtension : X509Extension { + public X509AuthorityKeyIdentifierExtension(); + public X509AuthorityKeyIdentifierExtension(byte[] rawData, bool critical = false); + public X509AuthorityKeyIdentifierExtension(ReadOnlySpan<byte> rawData, bool critical = false); + public ReadOnlyMemory<byte>? KeyIdentifier { get; } + public X500DistinguishedName? NamedIssuer { get; } + public ReadOnlyMemory<byte>? RawIssuer { get; } + public ReadOnlyMemory<byte>? SerialNumber { get; } + public override void CopyFrom(AsnEncodedData asnEncodedData); + public static X509AuthorityKeyIdentifierExtension Create(byte[] keyIdentifier, X500DistinguishedName issuerName, byte[] serialNumber); + public static X509AuthorityKeyIdentifierExtension Create(ReadOnlySpan<byte> keyIdentifier, X500DistinguishedName issuerName, ReadOnlySpan<byte> serialNumber); + public static X509AuthorityKeyIdentifierExtension CreateFromCertificate(X509Certificate2 certificate, bool includeKeyIdentifier, bool includeIssuerAndSerial); + public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, byte[] serialNumber); + public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, ReadOnlySpan<byte> serialNumber); + public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(byte[] subjectKeyIdentifier); + public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(ReadOnlySpan<byte> subjectKeyIdentifier); + public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(X509SubjectKeyIdentifierExtension subjectKeyIdentifier); + } public sealed class X509BasicConstraintsExtension : X509Extension { + public static X509BasicConstraintsExtension CreateForCertificateAuthority(int? pathLengthConstraint = default(int?)); + public static X509BasicConstraintsExtension CreateForEndEntity(bool critical = false); } public class X509Certificate : IDeserializationCallback, IDisposable, ISerializable { public X509Certificate(); public X509Certificate(byte[] data); public X509Certificate(byte[] rawData, SecureString? password); public X509Certificate(byte[] rawData, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate(byte[] rawData, string? password); public X509Certificate(byte[] rawData, string? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate(IntPtr handle); public X509Certificate(X509Certificate cert); public X509Certificate(string fileName); public X509Certificate(string fileName, SecureString? password); public X509Certificate(string fileName, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate(string fileName, string? password); public X509Certificate(string fileName, string? password, X509KeyStorageFlags keyStorageFlags); + public ReadOnlyMemory<byte> SerialNumberBytes { get; } public static X509Certificate CreateFromCertFile(string filename); public static X509Certificate CreateFromSignedFile(string filename); } public class X509Certificate2 : X509Certificate { public X509Certificate2(); public X509Certificate2(byte[] rawData); public X509Certificate2(byte[] rawData, SecureString? password); public X509Certificate2(byte[] rawData, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate2(byte[] rawData, string? password); public X509Certificate2(byte[] rawData, string? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate2(IntPtr handle); public X509Certificate2(ReadOnlySpan<byte> rawData); public X509Certificate2(ReadOnlySpan<byte> rawData, ReadOnlySpan<char> password, X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet); public X509Certificate2(X509Certificate certificate); public X509Certificate2(string fileName); public X509Certificate2(string fileName, ReadOnlySpan<char> password, X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet); public X509Certificate2(string fileName, SecureString? password); public X509Certificate2(string fileName, SecureString? password, X509KeyStorageFlags keyStorageFlags); public X509Certificate2(string fileName, string? password); public X509Certificate2(string fileName, string? password, X509KeyStorageFlags keyStorageFlags); + public ReadOnlyMemory<byte> RawDataMemory { get; } public static X509Certificate2 CreateFromEncryptedPem(ReadOnlySpan<char> certPem, ReadOnlySpan<char> keyPem, ReadOnlySpan<char> password); public static X509Certificate2 CreateFromEncryptedPemFile(string certPemFilePath, ReadOnlySpan<char> password, string? keyPemFilePath = null); public static X509Certificate2 CreateFromPem(ReadOnlySpan<char> certPem); public static X509Certificate2 CreateFromPem(ReadOnlySpan<char> certPem, ReadOnlySpan<char> keyPem); public static X509Certificate2 CreateFromPemFile(string certPemFilePath, string? keyPemFilePath = null); + public string ExportCertificatePem(); public static X509ContentType GetCertContentType(byte[] rawData); public static X509ContentType GetCertContentType(ReadOnlySpan<byte> rawData); public static X509ContentType GetCertContentType(string fileName); + public bool MatchesHostname(string hostname, bool allowWildcards = true, bool allowCommonName = true); + public bool TryExportCertificatePem(Span<char> destination, out int charsWritten); } public class X509Certificate2Collection : X509CertificateCollection, IEnumerable, IEnumerable<X509Certificate2> { + public string ExportCertificatePems(); + public string ExportPkcs7Pem(); + public bool TryExportCertificatePems(Span<char> destination, out int charsWritten); + public bool TryExportPkcs7Pem(Span<char> destination, out int charsWritten); } public class X509Chain : IDisposable { public bool Build(X509Certificate2 certificate); } public sealed class X509ChainPolicy { + public bool VerificationTimeIgnored { get; set; } + public X509ChainPolicy Clone(); } + public enum X509RevocationReason { + AACompromise = 10, + AffiliationChanged = 3, + CACompromise = 2, + CertificateHold = 6, + CessationOfOperation = 5, + KeyCompromise = 1, + PrivilegeWithdrawn = 9, + RemoveFromCrl = 8, + Superseded = 4, + Unspecified = 0, + WeakAlgorithmOrKey = 11, + } + public sealed class X509SubjectAlternativeNameExtension : X509Extension { + public X509SubjectAlternativeNameExtension(); + public X509SubjectAlternativeNameExtension(byte[] rawData, bool critical = false); + public X509SubjectAlternativeNameExtension(ReadOnlySpan<byte> rawData, bool critical = false); + public override void CopyFrom(AsnEncodedData asnEncodedData); + public IEnumerable<string> EnumerateDnsNames(); + public IEnumerable<IPAddress> EnumerateIPAddresses(); + } public sealed class X509SubjectKeyIdentifierExtension : X509Extension { + public ReadOnlyMemory<byte> SubjectKeyIdentifierBytes { get; } } }","title":"System.Security.Cryptography.X509Certificates"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Cryptography/","text":"System.Security.Cryptography namespace System.Security.Cryptography { public abstract class Aes : SymmetricAlgorithm { public static new Aes Create(); public static new Aes? Create(string algorithmName); } public sealed class AesCng : Aes { public AesCng(); public AesCng(string keyName); public AesCng(string keyName, CngProvider provider); public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions); + protected override bool TryDecryptCbcCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryDecryptCfbCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryDecryptEcbCore(ReadOnlySpan<byte> ciphertext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCbcCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCfbCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryEncryptEcbCore(ReadOnlySpan<byte> plaintext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); } public sealed class AesCryptoServiceProvider : Aes { public AesCryptoServiceProvider(); } public abstract class AsymmetricAlgorithm : IDisposable { public static AsymmetricAlgorithm Create(); public static AsymmetricAlgorithm? Create(string algName); + public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan<char> password, PbeParameters pbeParameters); + public string ExportPkcs8PrivateKeyPem(); + public string ExportSubjectPublicKeyInfoPem(); + public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<char> destination, out int charsWritten); + public bool TryExportPkcs8PrivateKeyPem(Span<char> destination, out int charsWritten); + public bool TryExportSubjectPublicKeyInfoPem(Span<char> destination, out int charsWritten); } public abstract class AsymmetricKeyExchangeDeformatter public abstract class AsymmetricKeyExchangeFormatter public abstract class AsymmetricSignatureDeformatter public abstract class AsymmetricSignatureFormatter public sealed class CngKey : IDisposable { public static CngKey Create(CngAlgorithm algorithm); public static CngKey Create(CngAlgorithm algorithm, string? keyName); public static CngKey Create(CngAlgorithm algorithm, string? keyName, CngKeyCreationParameters? creationParameters); public static bool Exists(string keyName); public static bool Exists(string keyName, CngProvider provider); public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options); public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format); public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider); public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions); public static CngKey Open(string keyName); public static CngKey Open(string keyName, CngProvider provider); public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions); } public class CryptographicException : SystemException { public CryptographicException(string format, string? insert); } public abstract class DeriveBytes : IDisposable public abstract class DES : SymmetricAlgorithm { public static new DES Create(); public static new DES? Create(string algName); } public abstract class DSA : AsymmetricAlgorithm { public static new DSA Create(); public static DSA Create(int keySizeInBits); public static DSA Create(DSAParameters parameters); public static new DSA? Create(string algName); } public sealed class DSACng : DSA { public DSACng(); public DSACng(int keySize); public DSACng(CngKey key); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + protected override bool TryCreateSignatureCore(ReadOnlySpan<byte> hash, Span<byte> destination, DSASignatureFormat signatureFormat, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + protected override bool VerifySignatureCore(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature, DSASignatureFormat signatureFormat); } public sealed class DSACryptoServiceProvider : DSA, ICspAsymmetricAlgorithm { public DSACryptoServiceProvider(); public DSACryptoServiceProvider(int dwKeySize); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); } public sealed class DSAOpenSsl : DSA { public DSAOpenSsl(); public DSAOpenSsl(int keySize); public DSAOpenSsl(IntPtr handle); public DSAOpenSsl(DSAParameters parameters); public DSAOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override int KeySize { set; } - public override KeySizes[] LegalKeySizes { get; } - protected override void Dispose(bool disposing); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); } public class DSASignatureDeformatter : AsymmetricSignatureDeformatter public class DSASignatureFormatter : AsymmetricSignatureFormatter + public abstract class ECAlgorithm : AsymmetricAlgorithm { + protected ECAlgorithm(); + public virtual byte[] ExportECPrivateKey(); + public string ExportECPrivateKeyPem(); + public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters); + public virtual ECParameters ExportParameters(bool includePrivateParameters); + public virtual void GenerateKey(ECCurve curve); + public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<byte> passwordBytes); + public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<char> password); + public override void ImportFromPem(ReadOnlySpan<char> input); + public virtual void ImportParameters(ECParameters parameters); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportSubjectPublicKeyInfo(ReadOnlySpan<byte> source, out int bytesRead); + public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten); + public bool TryExportECPrivateKeyPem(Span<char> destination, out int charsWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + public override bool TryExportSubjectPublicKeyInfo(Span<byte> destination, out int bytesWritten); + } public struct ECCurve - public abstract class ECDiffieHellman : AsymmetricAlgorithm { + public abstract class ECDiffieHellman : ECAlgorithm { public static new ECDiffieHellman Create(); public static ECDiffieHellman Create(ECCurve curve); public static ECDiffieHellman Create(ECParameters parameters); public static new ECDiffieHellman? Create(string algorithm); - public virtual byte[] ExportECPrivateKey(); - public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters); - public virtual ECParameters ExportParameters(bool includePrivateParameters); - public virtual void GenerateKey(ECCurve curve); - public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<byte> passwordBytes); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<char> password); - public override void ImportFromPem(ReadOnlySpan<char> input); - public virtual void ImportParameters(ECParameters parameters); - public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportSubjectPublicKeyInfo(ReadOnlySpan<byte> source, out int bytesRead); - public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportSubjectPublicKeyInfo(Span<byte> destination, out int bytesWritten); } public sealed class ECDiffieHellmanCng : ECDiffieHellman { public ECDiffieHellmanCng(); public ECDiffieHellmanCng(int keySize); public ECDiffieHellmanCng(CngKey key); public ECDiffieHellmanCng(ECCurve curve); + public override KeySizes[] LegalKeySizes { get; } + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); public void FromXmlString(string xml, ECKeyXmlFormat format); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); public string ToXmlString(ECKeyXmlFormat format); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); } public sealed class ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey { public static ECDiffieHellmanPublicKey FromByteArray(byte[] publicKeyBlob, CngKeyBlobFormat format); public static ECDiffieHellmanCngPublicKey FromXmlString(string xml); public override string ToXmlString(); } public sealed class ECDiffieHellmanOpenSsl : ECDiffieHellman { public ECDiffieHellmanOpenSsl(); public ECDiffieHellmanOpenSsl(int keySize); public ECDiffieHellmanOpenSsl(IntPtr handle); public ECDiffieHellmanOpenSsl(ECCurve curve); public ECDiffieHellmanOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[]? secretPrepend, byte[]? secretAppend); - public override byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[]? hmacKey, byte[]? secretPrepend, byte[]? secretAppend); - public override byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey); - public override byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed); - public override ECParameters ExportExplicitParameters(bool includePrivateParameters); - public override void GenerateKey(ECCurve curve); } public abstract class ECDiffieHellmanPublicKey : IDisposable { protected ECDiffieHellmanPublicKey(byte[] keyBlob); public virtual byte[] ToByteArray(); public virtual string ToXmlString(); } - public abstract class ECDsa : AsymmetricAlgorithm { + public abstract class ECDsa : ECAlgorithm { public static new ECDsa Create(); public static ECDsa Create(ECCurve curve); public static ECDsa Create(ECParameters parameters); public static new ECDsa? Create(string algorithm); - public virtual byte[] ExportECPrivateKey(); - public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters); - public virtual ECParameters ExportParameters(bool includePrivateParameters); - public virtual void GenerateKey(ECCurve curve); - public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<byte> passwordBytes); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<char> password); - public override void ImportFromPem(ReadOnlySpan<char> input); - public virtual void ImportParameters(ECParameters parameters); - public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportSubjectPublicKeyInfo(ReadOnlySpan<byte> source, out int bytesRead); + public byte[] SignData(ReadOnlySpan<byte> data, HashAlgorithmName hashAlgorithm); + public byte[] SignData(ReadOnlySpan<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat); + public int SignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm); + public int SignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat); + public byte[] SignHash(ReadOnlySpan<byte> hash); + public byte[] SignHash(ReadOnlySpan<byte> hash, DSASignatureFormat signatureFormat); + public int SignHash(ReadOnlySpan<byte> hash, Span<byte> destination); + public int SignHash(ReadOnlySpan<byte> hash, Span<byte> destination, DSASignatureFormat signatureFormat); - public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportSubjectPublicKeyInfo(Span<byte> destination, out int bytesWritten); } public sealed class ECDsaCng : ECDsa { public ECDsaCng(); public ECDsaCng(int keySize); public ECDsaCng(CngKey key); public ECDsaCng(ECCurve curve); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); public void FromXmlString(string xml, ECKeyXmlFormat format); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); public string ToXmlString(ECKeyXmlFormat format); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + public override bool TrySignHash(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten); + protected override bool TrySignHashCore(ReadOnlySpan<byte> hash, Span<byte> destination, DSASignatureFormat signatureFormat, out int bytesWritten); + public override bool VerifyHash(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature); + protected override bool VerifyHashCore(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature, DSASignatureFormat signatureFormat); } public sealed class ECDsaOpenSsl : ECDsa { public ECDsaOpenSsl(); public ECDsaOpenSsl(int keySize); public ECDsaOpenSsl(IntPtr handle); public ECDsaOpenSsl(ECCurve curve); public ECDsaOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override int KeySize { get; set; } - public override KeySizes[] LegalKeySizes { get; } - protected override void Dispose(bool disposing); - public override ECParameters ExportExplicitParameters(bool includePrivateParameters); - public override ECParameters ExportParameters(bool includePrivateParameters); - public override void GenerateKey(ECCurve curve); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); - public override void ImportParameters(ECParameters parameters); } public struct ECParameters public abstract class HashAlgorithm : ICryptoTransform, IDisposable { public static HashAlgorithm Create(); public static HashAlgorithm? Create(string hashName); } public static class HKDF public abstract class HMAC : KeyedHashAlgorithm { public static new HMAC Create(); public static new HMAC? Create(string algorithmName); } public class HMACMD5 : HMAC { + public const int HashSizeInBits = 128; + public const int HashSizeInBytes = 16; public HMACMD5(); public HMACMD5(byte[] key); public static byte[] HashData(byte[] key, byte[] source); + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); public static byte[] HashData(ReadOnlySpan<byte> key, ReadOnlySpan<byte> source); public static int HashData(ReadOnlySpan<byte> key, ReadOnlySpan<byte> source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); public static bool TryHashData(ReadOnlySpan<byte> key, ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten); } public class HMACSHA1 : HMAC { + public const int HashSizeInBits = 160; + public const int HashSizeInBytes = 20; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class HMACSHA256 : HMAC { + public const int HashSizeInBits = 256; + public const int HashSizeInBytes = 32; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class HMACSHA384 : HMAC { + public const int HashSizeInBits = 384; + public const int HashSizeInBytes = 48; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class HMACSHA512 : HMAC { + public const int HashSizeInBits = 512; + public const int HashSizeInBytes = 64; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public sealed class IncrementalHash : IDisposable { public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, byte[] key); public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, ReadOnlySpan<byte> key); } public abstract class KeyedHashAlgorithm : HashAlgorithm { public static new KeyedHashAlgorithm Create(); public static new KeyedHashAlgorithm? Create(string algName); } public abstract class MaskGenerationMethod public abstract class MD5 : HashAlgorithm { + public const int HashSizeInBits = 128; + public const int HashSizeInBytes = 16; public static new MD5 Create(); public static new MD5? Create(string algName); public static byte[] HashData(byte[] source); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); public static byte[] HashData(ReadOnlySpan<byte> source); public static int HashData(ReadOnlySpan<byte> source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); public static bool TryHashData(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten); } public static class PemEncoding { + public static string WriteString(ReadOnlySpan<char> label, ReadOnlySpan<byte> data); } public class PKCS1MaskGenerationMethod : MaskGenerationMethod public abstract class RandomNumberGenerator : IDisposable { public static RandomNumberGenerator? Create(string rngName); } public abstract class RC2 : SymmetricAlgorithm { public static new RC2 Create(); public static new RC2? Create(string AlgName); } public sealed class RC2CryptoServiceProvider : RC2 { public RC2CryptoServiceProvider(); } public class Rfc2898DeriveBytes : DeriveBytes { public Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations); public Rfc2898DeriveBytes(string password, byte[] salt); public Rfc2898DeriveBytes(string password, byte[] salt, int iterations); public Rfc2898DeriveBytes(string password, int saltSize); public Rfc2898DeriveBytes(string password, int saltSize, int iterations); } public abstract class Rijndael : SymmetricAlgorithm { public static new Rijndael Create(); public static new Rijndael? Create(string algName); } public abstract class RSA : AsymmetricAlgorithm { public static new RSA Create(); public static RSA Create(int keySizeInBits); public static RSA Create(RSAParameters parameters); public static new RSA? Create(string algName); + public byte[] Decrypt(ReadOnlySpan<byte> data, RSAEncryptionPadding padding); + public int Decrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding); + public byte[] Encrypt(ReadOnlySpan<byte> data, RSAEncryptionPadding padding); + public int Encrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding); + public string ExportRSAPrivateKeyPem(); + public string ExportRSAPublicKeyPem(); + public byte[] SignData(ReadOnlySpan<byte> data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public int SignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public byte[] SignHash(ReadOnlySpan<byte> hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public int SignHash(ReadOnlySpan<byte> hash, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public bool TryExportRSAPrivateKeyPem(Span<char> destination, out int charsWritten); + public bool TryExportRSAPublicKeyPem(Span<char> destination, out int charsWritten); } public sealed class RSACng : RSA { public RSACng(); public RSACng(int keySize); public RSACng(CngKey key); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); + public override bool TryDecrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding, out int bytesWritten); + public override bool TryEncrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + public override bool TrySignHash(ReadOnlySpan<byte> hash, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, out int bytesWritten); + public override bool VerifyHash(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); } public sealed class RSACryptoServiceProvider : RSA, ICspAsymmetricAlgorithm { public RSACryptoServiceProvider(); public RSACryptoServiceProvider(int dwKeySize); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); } public sealed class RSAEncryptionPadding : IEquatable<RSAEncryptionPadding> public class RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter public class RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter public sealed class RSAOpenSsl : RSA { public RSAOpenSsl(); public RSAOpenSsl(int keySize); public RSAOpenSsl(IntPtr handle); public RSAOpenSsl(RSAParameters parameters); public RSAOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override int KeySize { set; } - public override KeySizes[] LegalKeySizes { get; } - public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding); - protected override void Dispose(bool disposing); - public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); - public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); - public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); } public class RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter public class RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter public sealed class RSASignaturePadding : IEquatable<RSASignaturePadding> public sealed class SafeEvpPKeyHandle : SafeHandle { public SafeEvpPKeyHandle(); public SafeEvpPKeyHandle(IntPtr handle, bool ownsHandle); public static long OpenSslVersion { get; } } public abstract class SHA1 : HashAlgorithm { + public const int HashSizeInBits = 160; + public const int HashSizeInBytes = 20; public static new SHA1? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class SHA256 : HashAlgorithm { + public const int HashSizeInBits = 256; + public const int HashSizeInBytes = 32; public static new SHA256? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class SHA384 : HashAlgorithm { + public const int HashSizeInBits = 384; + public const int HashSizeInBytes = 48; public static new SHA384? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class SHA512 : HashAlgorithm { + public const int HashSizeInBits = 512; + public const int HashSizeInBytes = 64; public static new SHA512? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class SignatureDescription public abstract class SymmetricAlgorithm : IDisposable { public static SymmetricAlgorithm Create(); public static SymmetricAlgorithm? Create(string algName); } public abstract class TripleDES : SymmetricAlgorithm { public static new TripleDES Create(); public static new TripleDES? Create(string str); } public sealed class TripleDESCng : TripleDES { public TripleDESCng(); public TripleDESCng(string keyName); public TripleDESCng(string keyName, CngProvider provider); public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions); + protected override bool TryDecryptCbcCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryDecryptCfbCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryDecryptEcbCore(ReadOnlySpan<byte> ciphertext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCbcCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCfbCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryEncryptEcbCore(ReadOnlySpan<byte> plaintext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); } }","title":"System.Security.Cryptography"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Cryptography/#systemsecuritycryptography","text":"namespace System.Security.Cryptography { public abstract class Aes : SymmetricAlgorithm { public static new Aes Create(); public static new Aes? Create(string algorithmName); } public sealed class AesCng : Aes { public AesCng(); public AesCng(string keyName); public AesCng(string keyName, CngProvider provider); public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions); + protected override bool TryDecryptCbcCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryDecryptCfbCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryDecryptEcbCore(ReadOnlySpan<byte> ciphertext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCbcCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCfbCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryEncryptEcbCore(ReadOnlySpan<byte> plaintext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); } public sealed class AesCryptoServiceProvider : Aes { public AesCryptoServiceProvider(); } public abstract class AsymmetricAlgorithm : IDisposable { public static AsymmetricAlgorithm Create(); public static AsymmetricAlgorithm? Create(string algName); + public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan<char> password, PbeParameters pbeParameters); + public string ExportPkcs8PrivateKeyPem(); + public string ExportSubjectPublicKeyInfoPem(); + public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<char> destination, out int charsWritten); + public bool TryExportPkcs8PrivateKeyPem(Span<char> destination, out int charsWritten); + public bool TryExportSubjectPublicKeyInfoPem(Span<char> destination, out int charsWritten); } public abstract class AsymmetricKeyExchangeDeformatter public abstract class AsymmetricKeyExchangeFormatter public abstract class AsymmetricSignatureDeformatter public abstract class AsymmetricSignatureFormatter public sealed class CngKey : IDisposable { public static CngKey Create(CngAlgorithm algorithm); public static CngKey Create(CngAlgorithm algorithm, string? keyName); public static CngKey Create(CngAlgorithm algorithm, string? keyName, CngKeyCreationParameters? creationParameters); public static bool Exists(string keyName); public static bool Exists(string keyName, CngProvider provider); public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options); public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format); public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider); public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions); public static CngKey Open(string keyName); public static CngKey Open(string keyName, CngProvider provider); public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions); } public class CryptographicException : SystemException { public CryptographicException(string format, string? insert); } public abstract class DeriveBytes : IDisposable public abstract class DES : SymmetricAlgorithm { public static new DES Create(); public static new DES? Create(string algName); } public abstract class DSA : AsymmetricAlgorithm { public static new DSA Create(); public static DSA Create(int keySizeInBits); public static DSA Create(DSAParameters parameters); public static new DSA? Create(string algName); } public sealed class DSACng : DSA { public DSACng(); public DSACng(int keySize); public DSACng(CngKey key); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + protected override bool TryCreateSignatureCore(ReadOnlySpan<byte> hash, Span<byte> destination, DSASignatureFormat signatureFormat, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + protected override bool VerifySignatureCore(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature, DSASignatureFormat signatureFormat); } public sealed class DSACryptoServiceProvider : DSA, ICspAsymmetricAlgorithm { public DSACryptoServiceProvider(); public DSACryptoServiceProvider(int dwKeySize); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); } public sealed class DSAOpenSsl : DSA { public DSAOpenSsl(); public DSAOpenSsl(int keySize); public DSAOpenSsl(IntPtr handle); public DSAOpenSsl(DSAParameters parameters); public DSAOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override int KeySize { set; } - public override KeySizes[] LegalKeySizes { get; } - protected override void Dispose(bool disposing); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); } public class DSASignatureDeformatter : AsymmetricSignatureDeformatter public class DSASignatureFormatter : AsymmetricSignatureFormatter + public abstract class ECAlgorithm : AsymmetricAlgorithm { + protected ECAlgorithm(); + public virtual byte[] ExportECPrivateKey(); + public string ExportECPrivateKeyPem(); + public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters); + public virtual ECParameters ExportParameters(bool includePrivateParameters); + public virtual void GenerateKey(ECCurve curve); + public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<byte> passwordBytes); + public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<char> password); + public override void ImportFromPem(ReadOnlySpan<char> input); + public virtual void ImportParameters(ECParameters parameters); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportSubjectPublicKeyInfo(ReadOnlySpan<byte> source, out int bytesRead); + public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten); + public bool TryExportECPrivateKeyPem(Span<char> destination, out int charsWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + public override bool TryExportSubjectPublicKeyInfo(Span<byte> destination, out int bytesWritten); + } public struct ECCurve - public abstract class ECDiffieHellman : AsymmetricAlgorithm { + public abstract class ECDiffieHellman : ECAlgorithm { public static new ECDiffieHellman Create(); public static ECDiffieHellman Create(ECCurve curve); public static ECDiffieHellman Create(ECParameters parameters); public static new ECDiffieHellman? Create(string algorithm); - public virtual byte[] ExportECPrivateKey(); - public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters); - public virtual ECParameters ExportParameters(bool includePrivateParameters); - public virtual void GenerateKey(ECCurve curve); - public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<byte> passwordBytes); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<char> password); - public override void ImportFromPem(ReadOnlySpan<char> input); - public virtual void ImportParameters(ECParameters parameters); - public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportSubjectPublicKeyInfo(ReadOnlySpan<byte> source, out int bytesRead); - public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportSubjectPublicKeyInfo(Span<byte> destination, out int bytesWritten); } public sealed class ECDiffieHellmanCng : ECDiffieHellman { public ECDiffieHellmanCng(); public ECDiffieHellmanCng(int keySize); public ECDiffieHellmanCng(CngKey key); public ECDiffieHellmanCng(ECCurve curve); + public override KeySizes[] LegalKeySizes { get; } + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); public void FromXmlString(string xml, ECKeyXmlFormat format); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); public string ToXmlString(ECKeyXmlFormat format); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); } public sealed class ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey { public static ECDiffieHellmanPublicKey FromByteArray(byte[] publicKeyBlob, CngKeyBlobFormat format); public static ECDiffieHellmanCngPublicKey FromXmlString(string xml); public override string ToXmlString(); } public sealed class ECDiffieHellmanOpenSsl : ECDiffieHellman { public ECDiffieHellmanOpenSsl(); public ECDiffieHellmanOpenSsl(int keySize); public ECDiffieHellmanOpenSsl(IntPtr handle); public ECDiffieHellmanOpenSsl(ECCurve curve); public ECDiffieHellmanOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[]? secretPrepend, byte[]? secretAppend); - public override byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[]? hmacKey, byte[]? secretPrepend, byte[]? secretAppend); - public override byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey); - public override byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed); - public override ECParameters ExportExplicitParameters(bool includePrivateParameters); - public override void GenerateKey(ECCurve curve); } public abstract class ECDiffieHellmanPublicKey : IDisposable { protected ECDiffieHellmanPublicKey(byte[] keyBlob); public virtual byte[] ToByteArray(); public virtual string ToXmlString(); } - public abstract class ECDsa : AsymmetricAlgorithm { + public abstract class ECDsa : ECAlgorithm { public static new ECDsa Create(); public static ECDsa Create(ECCurve curve); public static ECDsa Create(ECParameters parameters); public static new ECDsa? Create(string algorithm); - public virtual byte[] ExportECPrivateKey(); - public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters); - public virtual ECParameters ExportParameters(bool includePrivateParameters); - public virtual void GenerateKey(ECCurve curve); - public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<byte> passwordBytes); - public override void ImportFromEncryptedPem(ReadOnlySpan<char> input, ReadOnlySpan<char> password); - public override void ImportFromPem(ReadOnlySpan<char> input); - public virtual void ImportParameters(ECParameters parameters); - public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); - public override void ImportSubjectPublicKeyInfo(ReadOnlySpan<byte> source, out int bytesRead); + public byte[] SignData(ReadOnlySpan<byte> data, HashAlgorithmName hashAlgorithm); + public byte[] SignData(ReadOnlySpan<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat); + public int SignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm); + public int SignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat); + public byte[] SignHash(ReadOnlySpan<byte> hash); + public byte[] SignHash(ReadOnlySpan<byte> hash, DSASignatureFormat signatureFormat); + public int SignHash(ReadOnlySpan<byte> hash, Span<byte> destination); + public int SignHash(ReadOnlySpan<byte> hash, Span<byte> destination, DSASignatureFormat signatureFormat); - public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); - public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); - public override bool TryExportSubjectPublicKeyInfo(Span<byte> destination, out int bytesWritten); } public sealed class ECDsaCng : ECDsa { public ECDsaCng(); public ECDsaCng(int keySize); public ECDsaCng(CngKey key); public ECDsaCng(ECCurve curve); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); public void FromXmlString(string xml, ECKeyXmlFormat format); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); public string ToXmlString(ECKeyXmlFormat format); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + public override bool TrySignHash(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten); + protected override bool TrySignHashCore(ReadOnlySpan<byte> hash, Span<byte> destination, DSASignatureFormat signatureFormat, out int bytesWritten); + public override bool VerifyHash(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature); + protected override bool VerifyHashCore(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature, DSASignatureFormat signatureFormat); } public sealed class ECDsaOpenSsl : ECDsa { public ECDsaOpenSsl(); public ECDsaOpenSsl(int keySize); public ECDsaOpenSsl(IntPtr handle); public ECDsaOpenSsl(ECCurve curve); public ECDsaOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override int KeySize { get; set; } - public override KeySizes[] LegalKeySizes { get; } - protected override void Dispose(bool disposing); - public override ECParameters ExportExplicitParameters(bool includePrivateParameters); - public override ECParameters ExportParameters(bool includePrivateParameters); - public override void GenerateKey(ECCurve curve); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); - public override void ImportParameters(ECParameters parameters); } public struct ECParameters public abstract class HashAlgorithm : ICryptoTransform, IDisposable { public static HashAlgorithm Create(); public static HashAlgorithm? Create(string hashName); } public static class HKDF public abstract class HMAC : KeyedHashAlgorithm { public static new HMAC Create(); public static new HMAC? Create(string algorithmName); } public class HMACMD5 : HMAC { + public const int HashSizeInBits = 128; + public const int HashSizeInBytes = 16; public HMACMD5(); public HMACMD5(byte[] key); public static byte[] HashData(byte[] key, byte[] source); + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); public static byte[] HashData(ReadOnlySpan<byte> key, ReadOnlySpan<byte> source); public static int HashData(ReadOnlySpan<byte> key, ReadOnlySpan<byte> source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); public static bool TryHashData(ReadOnlySpan<byte> key, ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten); } public class HMACSHA1 : HMAC { + public const int HashSizeInBits = 160; + public const int HashSizeInBytes = 20; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class HMACSHA256 : HMAC { + public const int HashSizeInBits = 256; + public const int HashSizeInBytes = 32; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class HMACSHA384 : HMAC { + public const int HashSizeInBits = 384; + public const int HashSizeInBytes = 48; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class HMACSHA512 : HMAC { + public const int HashSizeInBits = 512; + public const int HashSizeInBytes = 64; + public static byte[] HashData(byte[] key, Stream source); + public static byte[] HashData(ReadOnlySpan<byte> key, Stream source); + public static int HashData(ReadOnlySpan<byte> key, Stream source, Span<byte> destination); + public static ValueTask<byte[]> HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<int> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(ReadOnlyMemory<byte> key, Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public sealed class IncrementalHash : IDisposable { public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, byte[] key); public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, ReadOnlySpan<byte> key); } public abstract class KeyedHashAlgorithm : HashAlgorithm { public static new KeyedHashAlgorithm Create(); public static new KeyedHashAlgorithm? Create(string algName); } public abstract class MaskGenerationMethod public abstract class MD5 : HashAlgorithm { + public const int HashSizeInBits = 128; + public const int HashSizeInBytes = 16; public static new MD5 Create(); public static new MD5? Create(string algName); public static byte[] HashData(byte[] source); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); public static byte[] HashData(ReadOnlySpan<byte> source); public static int HashData(ReadOnlySpan<byte> source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); public static bool TryHashData(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten); } public static class PemEncoding { + public static string WriteString(ReadOnlySpan<char> label, ReadOnlySpan<byte> data); } public class PKCS1MaskGenerationMethod : MaskGenerationMethod public abstract class RandomNumberGenerator : IDisposable { public static RandomNumberGenerator? Create(string rngName); } public abstract class RC2 : SymmetricAlgorithm { public static new RC2 Create(); public static new RC2? Create(string AlgName); } public sealed class RC2CryptoServiceProvider : RC2 { public RC2CryptoServiceProvider(); } public class Rfc2898DeriveBytes : DeriveBytes { public Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations); public Rfc2898DeriveBytes(string password, byte[] salt); public Rfc2898DeriveBytes(string password, byte[] salt, int iterations); public Rfc2898DeriveBytes(string password, int saltSize); public Rfc2898DeriveBytes(string password, int saltSize, int iterations); } public abstract class Rijndael : SymmetricAlgorithm { public static new Rijndael Create(); public static new Rijndael? Create(string algName); } public abstract class RSA : AsymmetricAlgorithm { public static new RSA Create(); public static RSA Create(int keySizeInBits); public static RSA Create(RSAParameters parameters); public static new RSA? Create(string algName); + public byte[] Decrypt(ReadOnlySpan<byte> data, RSAEncryptionPadding padding); + public int Decrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding); + public byte[] Encrypt(ReadOnlySpan<byte> data, RSAEncryptionPadding padding); + public int Encrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding); + public string ExportRSAPrivateKeyPem(); + public string ExportRSAPublicKeyPem(); + public byte[] SignData(ReadOnlySpan<byte> data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public int SignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public byte[] SignHash(ReadOnlySpan<byte> hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public int SignHash(ReadOnlySpan<byte> hash, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); + public bool TryExportRSAPrivateKeyPem(Span<char> destination, out int charsWritten); + public bool TryExportRSAPublicKeyPem(Span<char> destination, out int charsWritten); } public sealed class RSACng : RSA { public RSACng(); public RSACng(int keySize); public RSACng(CngKey key); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters); + public override byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportPkcs8PrivateKey(ReadOnlySpan<byte> source, out int bytesRead); + public override bool TryDecrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding, out int bytesWritten); + public override bool TryEncrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, PbeParameters pbeParameters, Span<byte> destination, out int bytesWritten); + public override bool TryExportPkcs8PrivateKey(Span<byte> destination, out int bytesWritten); + public override bool TrySignHash(ReadOnlySpan<byte> hash, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, out int bytesWritten); + public override bool VerifyHash(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); } public sealed class RSACryptoServiceProvider : RSA, ICspAsymmetricAlgorithm { public RSACryptoServiceProvider(); public RSACryptoServiceProvider(int dwKeySize); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<byte> passwordBytes, ReadOnlySpan<byte> source, out int bytesRead); + public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan<char> password, ReadOnlySpan<byte> source, out int bytesRead); } public sealed class RSAEncryptionPadding : IEquatable<RSAEncryptionPadding> public class RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter public class RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter public sealed class RSAOpenSsl : RSA { public RSAOpenSsl(); public RSAOpenSsl(int keySize); public RSAOpenSsl(IntPtr handle); public RSAOpenSsl(RSAParameters parameters); public RSAOpenSsl(SafeEvpPKeyHandle pkeyHandle); - public override int KeySize { set; } - public override KeySizes[] LegalKeySizes { get; } - public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding); - protected override void Dispose(bool disposing); - public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding); - protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm); - protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm); - public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); - public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding); } public class RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter public class RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter public sealed class RSASignaturePadding : IEquatable<RSASignaturePadding> public sealed class SafeEvpPKeyHandle : SafeHandle { public SafeEvpPKeyHandle(); public SafeEvpPKeyHandle(IntPtr handle, bool ownsHandle); public static long OpenSslVersion { get; } } public abstract class SHA1 : HashAlgorithm { + public const int HashSizeInBits = 160; + public const int HashSizeInBytes = 20; public static new SHA1? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class SHA256 : HashAlgorithm { + public const int HashSizeInBits = 256; + public const int HashSizeInBytes = 32; public static new SHA256? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class SHA384 : HashAlgorithm { + public const int HashSizeInBits = 384; + public const int HashSizeInBytes = 48; public static new SHA384? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public abstract class SHA512 : HashAlgorithm { + public const int HashSizeInBits = 512; + public const int HashSizeInBytes = 64; public static new SHA512? Create(string hashName); + public static byte[] HashData(Stream source); + public static int HashData(Stream source, Span<byte> destination); + public static ValueTask<int> HashDataAsync(Stream source, Memory<byte> destination, CancellationToken cancellationToken = default(CancellationToken)); + public static ValueTask<byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken = default(CancellationToken)); } public class SignatureDescription public abstract class SymmetricAlgorithm : IDisposable { public static SymmetricAlgorithm Create(); public static SymmetricAlgorithm? Create(string algName); } public abstract class TripleDES : SymmetricAlgorithm { public static new TripleDES Create(); public static new TripleDES? Create(string str); } public sealed class TripleDESCng : TripleDES { public TripleDESCng(); public TripleDESCng(string keyName); public TripleDESCng(string keyName, CngProvider provider); public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions); + protected override bool TryDecryptCbcCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryDecryptCfbCore(ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryDecryptEcbCore(ReadOnlySpan<byte> ciphertext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCbcCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); + protected override bool TryEncryptCfbCore(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> iv, Span<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, out int bytesWritten); + protected override bool TryEncryptEcbCore(ReadOnlySpan<byte> plaintext, Span<byte> destination, PaddingMode paddingMode, out int bytesWritten); } }","title":"System.Security.Cryptography"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Policy/","text":"System.Security.Policy namespace System.Security.Policy { public sealed class Evidence : ICollection, IEnumerable { public Evidence(object[] hostEvidence, object[] assemblyEvidence); public int Count { get; } public void AddAssembly(object id); public void AddHost(object id); public void CopyTo(Array array, int index); public IEnumerator GetEnumerator(); } }","title":"System.Security.Policy"},{"location":"Microsoft.NETCore.App/7.0_System.Security.Policy/#systemsecuritypolicy","text":"namespace System.Security.Policy { public sealed class Evidence : ICollection, IEnumerable { public Evidence(object[] hostEvidence, object[] assemblyEvidence); public int Count { get; } public void AddAssembly(object id); public void AddHost(object id); public void CopyTo(Array array, int index); public IEnumerator GetEnumerator(); } }","title":"System.Security.Policy"},{"location":"Microsoft.NETCore.App/7.0_System.Security/","text":"System.Security namespace System.Security { public sealed class SecurityTreatAsSafeAttribute : Attribute }","title":"System.Security"},{"location":"Microsoft.NETCore.App/7.0_System.Security/#systemsecurity","text":"namespace System.Security { public sealed class SecurityTreatAsSafeAttribute : Attribute }","title":"System.Security"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json.Nodes/","text":"System.Text.Json.Nodes namespace System.Text.Json.Nodes { public sealed class JsonArray : JsonNode, ICollection<JsonNode?>, IEnumerable, IEnumerable<JsonNode?>, IList<JsonNode?> { public void Add<T>(T value); } public abstract class JsonNode { public static JsonNode? Parse(string json, JsonNodeOptions? nodeOptions = default(JsonNodeOptions?), JsonDocumentOptions documentOptions = default(JsonDocumentOptions)); } public abstract class JsonValue : JsonNode { public static JsonValue Create<T>(T value, JsonNodeOptions? options = default(JsonNodeOptions?)); } }","title":"System.Text.Json.Nodes"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json.Nodes/#systemtextjsonnodes","text":"namespace System.Text.Json.Nodes { public sealed class JsonArray : JsonNode, ICollection<JsonNode?>, IEnumerable, IEnumerable<JsonNode?>, IList<JsonNode?> { public void Add<T>(T value); } public abstract class JsonNode { public static JsonNode? Parse(string json, JsonNodeOptions? nodeOptions = default(JsonNodeOptions?), JsonDocumentOptions documentOptions = default(JsonDocumentOptions)); } public abstract class JsonValue : JsonNode { public static JsonValue Create<T>(T value, JsonNodeOptions? options = default(JsonNodeOptions?)); } }","title":"System.Text.Json.Nodes"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json.Serialization.Metadata/","text":"System.Text.Json.Serialization.Metadata namespace System.Text.Json.Serialization.Metadata { + public class DefaultJsonTypeInfoResolver : IJsonTypeInfoResolver { + public DefaultJsonTypeInfoResolver(); + public IList<Action<JsonTypeInfo>> Modifiers { get; } + public virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options); + } + public interface IJsonTypeInfoResolver { + JsonTypeInfo? GetTypeInfo(Type type, JsonSerializerOptions options); + } public sealed class JsonCollectionInfoValues<TCollection> + public readonly struct JsonDerivedType { + public JsonDerivedType(Type derivedType); + public JsonDerivedType(Type derivedType, int typeDiscriminator); + public JsonDerivedType(Type derivedType, string typeDiscriminator); + public Type DerivedType { get; } + public object? TypeDiscriminator { get; } + } public static class JsonMetadataServices { + public static JsonConverter<DateOnly> DateOnlyConverter { get; } + public static JsonConverter<JsonDocument> JsonDocumentConverter { get; } - public static JsonConverter<object> ObjectConverter { get; } + public static JsonConverter<object?> ObjectConverter { get; } + public static JsonConverter<TimeOnly> TimeOnlyConverter { get; } + public static JsonTypeInfo<TCollection> CreateIAsyncEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IAsyncEnumerable<TElement>; + public static JsonConverter<T?> GetNullableConverter<T>(JsonSerializerOptions options) where T : struct; } public sealed class JsonObjectInfoValues<T> public sealed class JsonParameterInfoValues + public class JsonPolymorphismOptions { + public JsonPolymorphismOptions(); + public IList<JsonDerivedType> DerivedTypes { get; } + public bool IgnoreUnrecognizedTypeDiscriminators { get; set; } + public string TypeDiscriminatorPropertyName { get; set; } + public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; set; } + } public abstract class JsonPropertyInfo { + public ICustomAttributeProvider? AttributeProvider { get; set; } + public JsonConverter? CustomConverter { get; set; } + public Func<object, object?>? Get { get; set; } + public bool IsExtensionData { get; set; } + public bool IsRequired { get; set; } + public string Name { get; set; } + public JsonNumberHandling? NumberHandling { get; set; } + public JsonSerializerOptions Options { get; } + public int Order { get; set; } + public Type PropertyType { get; } + public Action<object, object?>? Set { get; set; } + public Func<object, object?, bool>? ShouldSerialize { get; set; } } public sealed class JsonPropertyInfoValues<T> - public class JsonTypeInfo { + public abstract class JsonTypeInfo { + public JsonConverter Converter { get; } + public Func<object>? CreateObject { get; set; } + public JsonTypeInfoKind Kind { get; } + public JsonNumberHandling? NumberHandling { get; set; } + public Action<object>? OnDeserialized { get; set; } + public Action<object>? OnDeserializing { get; set; } + public Action<object>? OnSerialized { get; set; } + public Action<object>? OnSerializing { get; set; } + public JsonSerializerOptions Options { get; } + public JsonPolymorphismOptions? PolymorphismOptions { get; set; } + public IList<JsonPropertyInfo> Properties { get; } + public Type Type { get; } + public JsonPropertyInfo CreateJsonPropertyInfo(Type propertyType, string name); + public static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options); + public static JsonTypeInfo<T> CreateJsonTypeInfo<T>(JsonSerializerOptions options); } public abstract class JsonTypeInfo<T> : JsonTypeInfo { + public new Func<T>? CreateObject { get; set; } public Action<Utf8JsonWriter, T>? SerializeHandler { get; } } + public enum JsonTypeInfoKind { + Dictionary = 3, + Enumerable = 2, + None = 0, + Object = 1, + } + public static class JsonTypeInfoResolver { + public static IJsonTypeInfoResolver Combine(params IJsonTypeInfoResolver[] resolvers); + } }","title":"System.Text.Json.Serialization.Metadata"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json.Serialization.Metadata/#systemtextjsonserializationmetadata","text":"namespace System.Text.Json.Serialization.Metadata { + public class DefaultJsonTypeInfoResolver : IJsonTypeInfoResolver { + public DefaultJsonTypeInfoResolver(); + public IList<Action<JsonTypeInfo>> Modifiers { get; } + public virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options); + } + public interface IJsonTypeInfoResolver { + JsonTypeInfo? GetTypeInfo(Type type, JsonSerializerOptions options); + } public sealed class JsonCollectionInfoValues<TCollection> + public readonly struct JsonDerivedType { + public JsonDerivedType(Type derivedType); + public JsonDerivedType(Type derivedType, int typeDiscriminator); + public JsonDerivedType(Type derivedType, string typeDiscriminator); + public Type DerivedType { get; } + public object? TypeDiscriminator { get; } + } public static class JsonMetadataServices { + public static JsonConverter<DateOnly> DateOnlyConverter { get; } + public static JsonConverter<JsonDocument> JsonDocumentConverter { get; } - public static JsonConverter<object> ObjectConverter { get; } + public static JsonConverter<object?> ObjectConverter { get; } + public static JsonConverter<TimeOnly> TimeOnlyConverter { get; } + public static JsonTypeInfo<TCollection> CreateIAsyncEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IAsyncEnumerable<TElement>; + public static JsonConverter<T?> GetNullableConverter<T>(JsonSerializerOptions options) where T : struct; } public sealed class JsonObjectInfoValues<T> public sealed class JsonParameterInfoValues + public class JsonPolymorphismOptions { + public JsonPolymorphismOptions(); + public IList<JsonDerivedType> DerivedTypes { get; } + public bool IgnoreUnrecognizedTypeDiscriminators { get; set; } + public string TypeDiscriminatorPropertyName { get; set; } + public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; set; } + } public abstract class JsonPropertyInfo { + public ICustomAttributeProvider? AttributeProvider { get; set; } + public JsonConverter? CustomConverter { get; set; } + public Func<object, object?>? Get { get; set; } + public bool IsExtensionData { get; set; } + public bool IsRequired { get; set; } + public string Name { get; set; } + public JsonNumberHandling? NumberHandling { get; set; } + public JsonSerializerOptions Options { get; } + public int Order { get; set; } + public Type PropertyType { get; } + public Action<object, object?>? Set { get; set; } + public Func<object, object?, bool>? ShouldSerialize { get; set; } } public sealed class JsonPropertyInfoValues<T> - public class JsonTypeInfo { + public abstract class JsonTypeInfo { + public JsonConverter Converter { get; } + public Func<object>? CreateObject { get; set; } + public JsonTypeInfoKind Kind { get; } + public JsonNumberHandling? NumberHandling { get; set; } + public Action<object>? OnDeserialized { get; set; } + public Action<object>? OnDeserializing { get; set; } + public Action<object>? OnSerialized { get; set; } + public Action<object>? OnSerializing { get; set; } + public JsonSerializerOptions Options { get; } + public JsonPolymorphismOptions? PolymorphismOptions { get; set; } + public IList<JsonPropertyInfo> Properties { get; } + public Type Type { get; } + public JsonPropertyInfo CreateJsonPropertyInfo(Type propertyType, string name); + public static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options); + public static JsonTypeInfo<T> CreateJsonTypeInfo<T>(JsonSerializerOptions options); } public abstract class JsonTypeInfo<T> : JsonTypeInfo { + public new Func<T>? CreateObject { get; set; } public Action<Utf8JsonWriter, T>? SerializeHandler { get; } } + public enum JsonTypeInfoKind { + Dictionary = 3, + Enumerable = 2, + None = 0, + Object = 1, + } + public static class JsonTypeInfoResolver { + public static IJsonTypeInfoResolver Combine(params IJsonTypeInfoResolver[] resolvers); + } }","title":"System.Text.Json.Serialization.Metadata"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json.Serialization/","text":"System.Text.Json.Serialization namespace System.Text.Json.Serialization { + public class JsonDerivedTypeAttribute : JsonAttribute { + public JsonDerivedTypeAttribute(Type derivedType); + public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator); + public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator); + public Type DerivedType { get; } + public object? TypeDiscriminator { get; } + } + public sealed class JsonPolymorphicAttribute : JsonAttribute { + public JsonPolymorphicAttribute(); + public bool IgnoreUnrecognizedTypeDiscriminators { get; set; } + public string TypeDiscriminatorPropertyName { get; set; } + public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; set; } + } + public sealed class JsonRequiredAttribute : JsonAttribute { + public JsonRequiredAttribute(); + } - public abstract class JsonSerializerContext { + public abstract class JsonSerializerContext : IJsonTypeInfoResolver { + JsonTypeInfo IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options); } public class JsonStringEnumConverter : JsonConverterFactory + public enum JsonUnknownDerivedTypeHandling { + FailSerialization = 0, + FallBackToBaseType = 1, + FallBackToNearestAncestor = 2, + } }","title":"System.Text.Json.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json.Serialization/#systemtextjsonserialization","text":"namespace System.Text.Json.Serialization { + public class JsonDerivedTypeAttribute : JsonAttribute { + public JsonDerivedTypeAttribute(Type derivedType); + public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator); + public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator); + public Type DerivedType { get; } + public object? TypeDiscriminator { get; } + } + public sealed class JsonPolymorphicAttribute : JsonAttribute { + public JsonPolymorphicAttribute(); + public bool IgnoreUnrecognizedTypeDiscriminators { get; set; } + public string TypeDiscriminatorPropertyName { get; set; } + public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; set; } + } + public sealed class JsonRequiredAttribute : JsonAttribute { + public JsonRequiredAttribute(); + } - public abstract class JsonSerializerContext { + public abstract class JsonSerializerContext : IJsonTypeInfoResolver { + JsonTypeInfo IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options); } public class JsonStringEnumConverter : JsonConverterFactory + public enum JsonUnknownDerivedTypeHandling { + FailSerialization = 0, + FallBackToBaseType = 1, + FallBackToNearestAncestor = 2, + } }","title":"System.Text.Json.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json/","text":"System.Text.Json namespace System.Text.Json { public sealed class JsonDocument : IDisposable { public static JsonDocument Parse(ReadOnlyMemory<char> json, JsonDocumentOptions options = default(JsonDocumentOptions)); public static JsonDocument Parse(string json, JsonDocumentOptions options = default(JsonDocumentOptions)); } public static class JsonSerializer { public static object? Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ReadOnlySpan<char> json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ReadOnlySpan<char> json, Type returnType, JsonSerializerContext context); public static object? Deserialize(string json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(string json, Type returnType, JsonSerializerContext context); public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(this JsonNode? node, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ref Utf8JsonReader reader, Type returnType, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(Stream utf8Json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ReadOnlySpan<char> json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ReadOnlySpan<char> json, JsonTypeInfo<TValue> jsonTypeInfo); public static TValue? Deserialize<TValue>(string json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(string json, JsonTypeInfo<TValue> jsonTypeInfo); public static TValue? Deserialize<TValue>(this JsonDocument document, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(this JsonElement element, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(this JsonNode? node, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ref Utf8JsonReader reader, JsonSerializerOptions? options = null); public static ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); + public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static void Serialize(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null); public static string Serialize(object? value, Type inputType, JsonSerializerOptions? options = null); public static void Serialize(Utf8JsonWriter writer, object? value, Type inputType, JsonSerializerOptions? options = null); public static void Serialize<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null); public static void Serialize<TValue>(Utf8JsonWriter writer, TValue value, JsonSerializerOptions? options = null); public static string Serialize<TValue>(TValue value, JsonSerializerOptions? options = null); public static Task SerializeAsync(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task SerializeAsync<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerOptions? options = null); public static JsonDocument SerializeToDocument<TValue>(TValue value, JsonSerializerOptions? options = null); public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerOptions? options = null); public static JsonElement SerializeToElement<TValue>(TValue value, JsonSerializerOptions? options = null); public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerOptions? options = null); public static JsonNode? SerializeToNode<TValue>(TValue value, JsonSerializerOptions? options = null); public static byte[] SerializeToUtf8Bytes(object? value, Type inputType, JsonSerializerOptions? options = null); public static byte[] SerializeToUtf8Bytes<TValue>(TValue value, JsonSerializerOptions? options = null); } public sealed class JsonSerializerOptions { + public static JsonSerializerOptions Default { get; } + public IJsonTypeInfoResolver TypeInfoResolver { get; set; } public JsonConverter GetConverter(Type typeToConvert); + public JsonTypeInfo GetTypeInfo(Type type); } public struct JsonWriterOptions { + public int MaxDepth { get; set; } } public ref struct Utf8JsonReader { + public bool ValueIsEscaped { get; } + public int CopyString(Span<byte> utf8Destination); + public int CopyString(Span<char> destination); } public sealed class Utf8JsonWriter : IAsyncDisposable, IDisposable { public void WriteRawValue(ReadOnlySpan<char> json, bool skipInputValidation = false); public void WriteRawValue(string json, bool skipInputValidation = false); } }","title":"System.Text.Json"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Json/#systemtextjson","text":"namespace System.Text.Json { public sealed class JsonDocument : IDisposable { public static JsonDocument Parse(ReadOnlyMemory<char> json, JsonDocumentOptions options = default(JsonDocumentOptions)); public static JsonDocument Parse(string json, JsonDocumentOptions options = default(JsonDocumentOptions)); } public static class JsonSerializer { public static object? Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ReadOnlySpan<char> json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ReadOnlySpan<char> json, Type returnType, JsonSerializerContext context); public static object? Deserialize(string json, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(string json, Type returnType, JsonSerializerContext context); public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(this JsonNode? node, Type returnType, JsonSerializerOptions? options = null); public static object? Deserialize(ref Utf8JsonReader reader, Type returnType, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(Stream utf8Json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ReadOnlySpan<char> json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ReadOnlySpan<char> json, JsonTypeInfo<TValue> jsonTypeInfo); public static TValue? Deserialize<TValue>(string json, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(string json, JsonTypeInfo<TValue> jsonTypeInfo); public static TValue? Deserialize<TValue>(this JsonDocument document, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(this JsonElement element, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(this JsonNode? node, JsonSerializerOptions? options = null); public static TValue? Deserialize<TValue>(ref Utf8JsonReader reader, JsonSerializerOptions? options = null); public static ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); + public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken)); public static void Serialize(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null); public static string Serialize(object? value, Type inputType, JsonSerializerOptions? options = null); public static void Serialize(Utf8JsonWriter writer, object? value, Type inputType, JsonSerializerOptions? options = null); public static void Serialize<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null); public static void Serialize<TValue>(Utf8JsonWriter writer, TValue value, JsonSerializerOptions? options = null); public static string Serialize<TValue>(TValue value, JsonSerializerOptions? options = null); public static Task SerializeAsync(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static Task SerializeAsync<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken)); public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerOptions? options = null); public static JsonDocument SerializeToDocument<TValue>(TValue value, JsonSerializerOptions? options = null); public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerOptions? options = null); public static JsonElement SerializeToElement<TValue>(TValue value, JsonSerializerOptions? options = null); public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerOptions? options = null); public static JsonNode? SerializeToNode<TValue>(TValue value, JsonSerializerOptions? options = null); public static byte[] SerializeToUtf8Bytes(object? value, Type inputType, JsonSerializerOptions? options = null); public static byte[] SerializeToUtf8Bytes<TValue>(TValue value, JsonSerializerOptions? options = null); } public sealed class JsonSerializerOptions { + public static JsonSerializerOptions Default { get; } + public IJsonTypeInfoResolver TypeInfoResolver { get; set; } public JsonConverter GetConverter(Type typeToConvert); + public JsonTypeInfo GetTypeInfo(Type type); } public struct JsonWriterOptions { + public int MaxDepth { get; set; } } public ref struct Utf8JsonReader { + public bool ValueIsEscaped { get; } + public int CopyString(Span<byte> utf8Destination); + public int CopyString(Span<char> destination); } public sealed class Utf8JsonWriter : IAsyncDisposable, IDisposable { public void WriteRawValue(ReadOnlySpan<char> json, bool skipInputValidation = false); public void WriteRawValue(string json, bool skipInputValidation = false); } }","title":"System.Text.Json"},{"location":"Microsoft.NETCore.App/7.0_System.Text.RegularExpressions/","text":"System.Text.RegularExpressions namespace System.Text.RegularExpressions { + public sealed class GeneratedRegexAttribute : Attribute { + public GeneratedRegexAttribute(string pattern); + public GeneratedRegexAttribute(string pattern, RegexOptions options); + public GeneratedRegexAttribute(string pattern, RegexOptions options, int matchTimeoutMilliseconds); + public GeneratedRegexAttribute(string pattern, RegexOptions options, int matchTimeoutMilliseconds, string cultureName); + public GeneratedRegexAttribute(string pattern, RegexOptions options, string cultureName); + public string CultureName { get; } + public int MatchTimeoutMilliseconds { get; } + public RegexOptions Options { get; } + public string Pattern { get; } + } public class Regex : ISerializable { protected internal string? pattern; public Regex(string pattern); public Regex(string pattern, RegexOptions options); public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout); public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname); public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[]? attributes); public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[]? attributes, string? resourceFile); + public int Count(ReadOnlySpan<char> input); + public int Count(ReadOnlySpan<char> input, int startat); + public static int Count(ReadOnlySpan<char> input, string pattern); + public static int Count(ReadOnlySpan<char> input, string pattern, RegexOptions options); + public static int Count(ReadOnlySpan<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public int Count(string input); + public static int Count(string input, string pattern); + public static int Count(string input, string pattern, RegexOptions options); + public static int Count(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input); + public Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, int startat); + public static Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, string pattern); + public static Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, string pattern, RegexOptions options); + public static Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public bool IsMatch(ReadOnlySpan<char> input); + public bool IsMatch(ReadOnlySpan<char> input, int startat); + public static bool IsMatch(ReadOnlySpan<char> input, string pattern); + public static bool IsMatch(ReadOnlySpan<char> input, string pattern, RegexOptions options); + public static bool IsMatch(ReadOnlySpan<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static bool IsMatch(string input, string pattern); public static bool IsMatch(string input, string pattern, RegexOptions options); public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static Match Match(string input, string pattern); public static Match Match(string input, string pattern, RegexOptions options); public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static MatchCollection Matches(string input, string pattern); public static MatchCollection Matches(string input, string pattern, RegexOptions options); public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static string Replace(string input, string pattern, string replacement); public static string Replace(string input, string pattern, string replacement, RegexOptions options); public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout); public static string Replace(string input, string pattern, MatchEvaluator evaluator); public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options); public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout); public static string[] Split(string input, string pattern); public static string[] Split(string input, string pattern, RegexOptions options); public static string[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public ref struct ValueMatchEnumerator { + public ValueMatch Current { get; } + public Regex.ValueMatchEnumerator GetEnumerator(); + public bool MoveNext(); + } } public class RegexCompilationInfo public enum RegexOptions { + NonBacktracking = 1024, } public abstract class RegexRunner { - protected abstract bool FindFirstChar(); + protected virtual bool FindFirstChar(); - protected abstract void Go(); + protected virtual void Go(); - protected abstract void InitTrackCount(); + protected virtual void InitTrackCount(); + protected internal virtual void Scan(ReadOnlySpan<char> text); } + public readonly ref struct ValueMatch { + public int Index { get; } + public int Length { get; } + } }","title":"System.Text.RegularExpressions"},{"location":"Microsoft.NETCore.App/7.0_System.Text.RegularExpressions/#systemtextregularexpressions","text":"namespace System.Text.RegularExpressions { + public sealed class GeneratedRegexAttribute : Attribute { + public GeneratedRegexAttribute(string pattern); + public GeneratedRegexAttribute(string pattern, RegexOptions options); + public GeneratedRegexAttribute(string pattern, RegexOptions options, int matchTimeoutMilliseconds); + public GeneratedRegexAttribute(string pattern, RegexOptions options, int matchTimeoutMilliseconds, string cultureName); + public GeneratedRegexAttribute(string pattern, RegexOptions options, string cultureName); + public string CultureName { get; } + public int MatchTimeoutMilliseconds { get; } + public RegexOptions Options { get; } + public string Pattern { get; } + } public class Regex : ISerializable { protected internal string? pattern; public Regex(string pattern); public Regex(string pattern, RegexOptions options); public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout); public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname); public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[]? attributes); public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[]? attributes, string? resourceFile); + public int Count(ReadOnlySpan<char> input); + public int Count(ReadOnlySpan<char> input, int startat); + public static int Count(ReadOnlySpan<char> input, string pattern); + public static int Count(ReadOnlySpan<char> input, string pattern, RegexOptions options); + public static int Count(ReadOnlySpan<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public int Count(string input); + public static int Count(string input, string pattern); + public static int Count(string input, string pattern, RegexOptions options); + public static int Count(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input); + public Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, int startat); + public static Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, string pattern); + public static Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, string pattern, RegexOptions options); + public static Regex.ValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public bool IsMatch(ReadOnlySpan<char> input); + public bool IsMatch(ReadOnlySpan<char> input, int startat); + public static bool IsMatch(ReadOnlySpan<char> input, string pattern); + public static bool IsMatch(ReadOnlySpan<char> input, string pattern, RegexOptions options); + public static bool IsMatch(ReadOnlySpan<char> input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static bool IsMatch(string input, string pattern); public static bool IsMatch(string input, string pattern, RegexOptions options); public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static Match Match(string input, string pattern); public static Match Match(string input, string pattern, RegexOptions options); public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static MatchCollection Matches(string input, string pattern); public static MatchCollection Matches(string input, string pattern, RegexOptions options); public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); public static string Replace(string input, string pattern, string replacement); public static string Replace(string input, string pattern, string replacement, RegexOptions options); public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout); public static string Replace(string input, string pattern, MatchEvaluator evaluator); public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options); public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout); public static string[] Split(string input, string pattern); public static string[] Split(string input, string pattern, RegexOptions options); public static string[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout); + public ref struct ValueMatchEnumerator { + public ValueMatch Current { get; } + public Regex.ValueMatchEnumerator GetEnumerator(); + public bool MoveNext(); + } } public class RegexCompilationInfo public enum RegexOptions { + NonBacktracking = 1024, } public abstract class RegexRunner { - protected abstract bool FindFirstChar(); + protected virtual bool FindFirstChar(); - protected abstract void Go(); + protected virtual void Go(); - protected abstract void InitTrackCount(); + protected virtual void InitTrackCount(); + protected internal virtual void Scan(ReadOnlySpan<char> text); } + public readonly ref struct ValueMatch { + public int Index { get; } + public int Length { get; } + } }","title":"System.Text.RegularExpressions"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Unicode/","text":"System.Text.Unicode namespace System.Text.Unicode { public static class UnicodeRanges { + public static UnicodeRange ArabicExtendedB { get; } } }","title":"System.Text.Unicode"},{"location":"Microsoft.NETCore.App/7.0_System.Text.Unicode/#systemtextunicode","text":"namespace System.Text.Unicode { public static class UnicodeRanges { + public static UnicodeRange ArabicExtendedB { get; } } }","title":"System.Text.Unicode"},{"location":"Microsoft.NETCore.App/7.0_System.Text/","text":"System.Text namespace System.Text { public sealed class StringBuilder : ISerializable { public StringBuilder AppendFormat(IFormatProvider? provider, string format, object? arg0); public StringBuilder AppendFormat(IFormatProvider? provider, string format, object? arg0, object? arg1); public StringBuilder AppendFormat(IFormatProvider? provider, string format, object? arg0, object? arg1, object? arg2); public StringBuilder AppendFormat(IFormatProvider? provider, string format, params object?[] args); public StringBuilder AppendFormat(string format, object? arg0); public StringBuilder AppendFormat(string format, object? arg0, object? arg1); public StringBuilder AppendFormat(string format, object? arg0, object? arg1, object? arg2); public StringBuilder AppendFormat(string format, params object?[] args); } }","title":"System.Text"},{"location":"Microsoft.NETCore.App/7.0_System.Text/#systemtext","text":"namespace System.Text { public sealed class StringBuilder : ISerializable { public StringBuilder AppendFormat(IFormatProvider? provider, string format, object? arg0); public StringBuilder AppendFormat(IFormatProvider? provider, string format, object? arg0, object? arg1); public StringBuilder AppendFormat(IFormatProvider? provider, string format, object? arg0, object? arg1, object? arg2); public StringBuilder AppendFormat(IFormatProvider? provider, string format, params object?[] args); public StringBuilder AppendFormat(string format, object? arg0); public StringBuilder AppendFormat(string format, object? arg0, object? arg1); public StringBuilder AppendFormat(string format, object? arg0, object? arg1, object? arg2); public StringBuilder AppendFormat(string format, params object?[] args); } }","title":"System.Text"},{"location":"Microsoft.NETCore.App/7.0_System.Threading.Tasks.Dataflow/","text":"System.Threading.Tasks.Dataflow namespace System.Threading.Tasks.Dataflow { public sealed class TransformManyBlock<TInput, TOutput> : IDataflowBlock, IPropagatorBlock<TInput, TOutput>, IReceivableSourceBlock<TOutput>, ISourceBlock<TOutput>, ITargetBlock<TInput> { + public TransformManyBlock(Func<TInput, IAsyncEnumerable<TOutput>> transform); + public TransformManyBlock(Func<TInput, IAsyncEnumerable<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions); } }","title":"System.Threading.Tasks.Dataflow"},{"location":"Microsoft.NETCore.App/7.0_System.Threading.Tasks.Dataflow/#systemthreadingtasksdataflow","text":"namespace System.Threading.Tasks.Dataflow { public sealed class TransformManyBlock<TInput, TOutput> : IDataflowBlock, IPropagatorBlock<TInput, TOutput>, IReceivableSourceBlock<TOutput>, ISourceBlock<TOutput>, ITargetBlock<TInput> { + public TransformManyBlock(Func<TInput, IAsyncEnumerable<TOutput>> transform); + public TransformManyBlock(Func<TInput, IAsyncEnumerable<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions); } }","title":"System.Threading.Tasks.Dataflow"},{"location":"Microsoft.NETCore.App/7.0_System.Threading.Tasks/","text":"System.Threading.Tasks namespace System.Threading.Tasks { public class Task : IAsyncResult, IDisposable { + public bool Wait(TimeSpan timeout, CancellationToken cancellationToken); } public static class TaskAsyncEnumerableExtensions { + public static IEnumerable<T> ToBlockingEnumerable<T>(this IAsyncEnumerable<T> source, CancellationToken cancellationToken = default(CancellationToken)); } }","title":"System.Threading.Tasks"},{"location":"Microsoft.NETCore.App/7.0_System.Threading.Tasks/#systemthreadingtasks","text":"namespace System.Threading.Tasks { public class Task : IAsyncResult, IDisposable { + public bool Wait(TimeSpan timeout, CancellationToken cancellationToken); } public static class TaskAsyncEnumerableExtensions { + public static IEnumerable<T> ToBlockingEnumerable<T>(this IAsyncEnumerable<T> source, CancellationToken cancellationToken = default(CancellationToken)); } }","title":"System.Threading.Tasks"},{"location":"Microsoft.NETCore.App/7.0_System.Threading/","text":"System.Threading namespace System.Threading { - public readonly struct CancellationToken + public readonly struct CancellationToken : IEquatable<CancellationToken> public static class Interlocked { + public static UIntPtr CompareExchange(ref UIntPtr location1, UIntPtr value, UIntPtr comparand); + public static UIntPtr Exchange(ref UIntPtr location1, UIntPtr value); } - public struct LockCookie + public struct LockCookie : IEquatable<LockCookie> public sealed class PeriodicTimer : IDisposable { + ~PeriodicTimer(); } }","title":"System.Threading"},{"location":"Microsoft.NETCore.App/7.0_System.Threading/#systemthreading","text":"namespace System.Threading { - public readonly struct CancellationToken + public readonly struct CancellationToken : IEquatable<CancellationToken> public static class Interlocked { + public static UIntPtr CompareExchange(ref UIntPtr location1, UIntPtr value, UIntPtr comparand); + public static UIntPtr Exchange(ref UIntPtr location1, UIntPtr value); } - public struct LockCookie + public struct LockCookie : IEquatable<LockCookie> public sealed class PeriodicTimer : IDisposable { + ~PeriodicTimer(); } }","title":"System.Threading"},{"location":"Microsoft.NETCore.App/7.0_System.Timers/","text":"System.Timers namespace System.Timers { public class Timer : Component, ISupportInitialize { + public Timer(TimeSpan interval); } }","title":"System.Timers"},{"location":"Microsoft.NETCore.App/7.0_System.Timers/#systemtimers","text":"namespace System.Timers { public class Timer : Component, ISupportInitialize { + public Timer(TimeSpan interval); } }","title":"System.Timers"},{"location":"Microsoft.NETCore.App/7.0_System.Transactions/","text":"System.Transactions namespace System.Transactions { public static class TransactionManager { - public static TimeSpan DefaultTimeout { get; } + public static TimeSpan DefaultTimeout { get; set; } - public static TimeSpan MaximumTimeout { get; } + public static TimeSpan MaximumTimeout { get; set; } } - public struct TransactionOptions { + public struct TransactionOptions : IEquatable<TransactionOptions> { + public bool Equals(TransactionOptions other); } }","title":"System.Transactions"},{"location":"Microsoft.NETCore.App/7.0_System.Transactions/#systemtransactions","text":"namespace System.Transactions { public static class TransactionManager { - public static TimeSpan DefaultTimeout { get; } + public static TimeSpan DefaultTimeout { get; set; } - public static TimeSpan MaximumTimeout { get; } + public static TimeSpan MaximumTimeout { get; set; } } - public struct TransactionOptions { + public struct TransactionOptions : IEquatable<TransactionOptions> { + public bool Equals(TransactionOptions other); } }","title":"System.Transactions"},{"location":"Microsoft.NETCore.App/7.0_System.Web/","text":"System.Web namespace System.Web { public sealed class HttpUtility { public static string UrlEncodeUnicode(string str); public static byte[] UrlEncodeUnicodeToBytes(string str); } }","title":"System.Web"},{"location":"Microsoft.NETCore.App/7.0_System.Web/#systemweb","text":"namespace System.Web { public sealed class HttpUtility { public static string UrlEncodeUnicode(string str); public static byte[] UrlEncodeUnicodeToBytes(string str); } }","title":"System.Web"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Linq/","text":"System.Xml.Linq namespace System.Xml.Linq { public class XDocument : XContainer { public static XDocument Load(string uri); public static XDocument Load(string uri, LoadOptions options); } public class XElement : XContainer, IXmlSerializable { public static XElement Load(string uri); public static XElement Load(string uri, LoadOptions options); } }","title":"System.Xml.Linq"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Linq/#systemxmllinq","text":"namespace System.Xml.Linq { public class XDocument : XContainer { public static XDocument Load(string uri); public static XDocument Load(string uri, LoadOptions options); } public class XElement : XContainer, IXmlSerializable { public static XElement Load(string uri); public static XElement Load(string uri, LoadOptions options); } }","title":"System.Xml.Linq"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Schema/","text":"System.Xml.Schema namespace System.Xml.Schema { public sealed class XmlSchemaCollection : ICollection, IEnumerable { public XmlSchema? Add(string? ns, string uri); } }","title":"System.Xml.Schema"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Schema/#systemxmlschema","text":"namespace System.Xml.Schema { public sealed class XmlSchemaCollection : ICollection, IEnumerable { public XmlSchema? Add(string? ns, string uri); } }","title":"System.Xml.Schema"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Serialization/","text":"System.Xml.Serialization namespace System.Xml.Serialization { public class XmlSerializer { - public static XmlSerializer[] FromMappings(XmlMapping[]? mappings); + public static XmlSerializer?[] FromMappings(XmlMapping[]? mappings); - public static XmlSerializer[] FromMappings(XmlMapping[]? mappings, Type? type); + public static XmlSerializer?[] FromMappings(XmlMapping[]? mappings, Type? type); - public static XmlSerializer[] FromTypes(Type[]? types); + public static XmlSerializer?[] FromTypes(Type[]? types); } }","title":"System.Xml.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Serialization/#systemxmlserialization","text":"namespace System.Xml.Serialization { public class XmlSerializer { - public static XmlSerializer[] FromMappings(XmlMapping[]? mappings); + public static XmlSerializer?[] FromMappings(XmlMapping[]? mappings); - public static XmlSerializer[] FromMappings(XmlMapping[]? mappings, Type? type); + public static XmlSerializer?[] FromMappings(XmlMapping[]? mappings, Type? type); - public static XmlSerializer[] FromTypes(Type[]? types); + public static XmlSerializer?[] FromTypes(Type[]? types); } }","title":"System.Xml.Serialization"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.XPath/","text":"System.Xml.XPath namespace System.Xml.XPath { public class XPathDocument : IXPathNavigable { public XPathDocument(string uri); public XPathDocument(string uri, XmlSpace space); } public abstract class XPathNavigator : XPathItem, ICloneable, IXmlNamespaceResolver, IXPathNavigable { - public virtual void AppendChildElement(string prefix, string localName, string namespaceURI, string value); + public virtual void AppendChildElement(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void CreateAttribute(string prefix, string localName, string namespaceURI, string value); + public virtual void CreateAttribute(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void InsertElementAfter(string prefix, string localName, string namespaceURI, string value); + public virtual void InsertElementAfter(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void InsertElementBefore(string prefix, string localName, string namespaceURI, string value); + public virtual void InsertElementBefore(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void PrependChildElement(string prefix, string localName, string namespaceURI, string value); + public virtual void PrependChildElement(string? prefix, string localName, string? namespaceURI, string? value); } }","title":"System.Xml.XPath"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.XPath/#systemxmlxpath","text":"namespace System.Xml.XPath { public class XPathDocument : IXPathNavigable { public XPathDocument(string uri); public XPathDocument(string uri, XmlSpace space); } public abstract class XPathNavigator : XPathItem, ICloneable, IXmlNamespaceResolver, IXPathNavigable { - public virtual void AppendChildElement(string prefix, string localName, string namespaceURI, string value); + public virtual void AppendChildElement(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void CreateAttribute(string prefix, string localName, string namespaceURI, string value); + public virtual void CreateAttribute(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void InsertElementAfter(string prefix, string localName, string namespaceURI, string value); + public virtual void InsertElementAfter(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void InsertElementBefore(string prefix, string localName, string namespaceURI, string value); + public virtual void InsertElementBefore(string? prefix, string localName, string? namespaceURI, string? value); - public virtual void PrependChildElement(string prefix, string localName, string namespaceURI, string value); + public virtual void PrependChildElement(string? prefix, string localName, string? namespaceURI, string? value); } }","title":"System.Xml.XPath"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Xsl/","text":"System.Xml.Xsl namespace System.Xml.Xsl { public sealed class XslTransform { public void Load(string url); public void Load(string url, XmlResolver? resolver); } }","title":"System.Xml.Xsl"},{"location":"Microsoft.NETCore.App/7.0_System.Xml.Xsl/#systemxmlxsl","text":"namespace System.Xml.Xsl { public sealed class XslTransform { public void Load(string url); public void Load(string url, XmlResolver? resolver); } }","title":"System.Xml.Xsl"},{"location":"Microsoft.NETCore.App/7.0_System.Xml/","text":"System.Xml namespace System.Xml { public class XmlConvert { public static DateTime ToDateTime(string s, string format); public static DateTime ToDateTime(string s, string[] formats); public static DateTimeOffset ToDateTimeOffset(string s, string format); public static DateTimeOffset ToDateTimeOffset(string s, string[] formats); public static string ToString(DateTime value, string format); public static string ToString(DateTimeOffset value, string format); } public class XmlDocument : XmlNode { - public virtual XmlProcessingInstruction CreateProcessingInstruction(string target, string data); + public virtual XmlProcessingInstruction CreateProcessingInstruction(string target, string? data); public virtual void LoadXml(string xml); } public class XmlElement : XmlLinkedNode { - protected internal XmlElement(string prefix, string localName, string? namespaceURI, XmlDocument doc); + protected internal XmlElement(string? prefix, string localName, string? namespaceURI, XmlDocument doc); } public class XmlNamespaceManager : IEnumerable, IXmlNamespaceResolver { public virtual void AddNamespace(string prefix, string uri); public virtual string? LookupPrefix(string uri); public virtual void RemoveNamespace(string prefix, string uri); } public class XmlProcessingInstruction : XmlLinkedNode { - protected internal XmlProcessingInstruction(string target, string data, XmlDocument doc); + protected internal XmlProcessingInstruction(string target, string? data, XmlDocument doc); public string Data { get; set; } public override string InnerText { get; set; } - public string? Target { get; } + public string Target { get; } } public class XmlQualifiedName { - public static string ToString(string name, string ns); + public static string ToString(string name, string? ns); } public abstract class XmlResolver { + public static XmlResolver ThrowingResolver { get; } } public class XmlSecureResolver : XmlResolver public class XmlTextReader : XmlReader, IXmlLineInfo, IXmlNamespaceResolver { public XmlTextReader(string url); public XmlTextReader(string url, Stream input); public XmlTextReader(string url, Stream input, XmlNameTable nt); public XmlTextReader(string url, TextReader input); public XmlTextReader(string url, TextReader input, XmlNameTable nt); public XmlTextReader(string url, XmlNameTable nt); public XmlTextReader(string xmlFragment, XmlNodeType fragType, XmlParserContext? context); } public class XmlValidatingReader : XmlReader, IXmlLineInfo, IXmlNamespaceResolver { public XmlValidatingReader(string xmlFragment, XmlNodeType fragType, XmlParserContext context); } }","title":"System.Xml"},{"location":"Microsoft.NETCore.App/7.0_System.Xml/#systemxml","text":"namespace System.Xml { public class XmlConvert { public static DateTime ToDateTime(string s, string format); public static DateTime ToDateTime(string s, string[] formats); public static DateTimeOffset ToDateTimeOffset(string s, string format); public static DateTimeOffset ToDateTimeOffset(string s, string[] formats); public static string ToString(DateTime value, string format); public static string ToString(DateTimeOffset value, string format); } public class XmlDocument : XmlNode { - public virtual XmlProcessingInstruction CreateProcessingInstruction(string target, string data); + public virtual XmlProcessingInstruction CreateProcessingInstruction(string target, string? data); public virtual void LoadXml(string xml); } public class XmlElement : XmlLinkedNode { - protected internal XmlElement(string prefix, string localName, string? namespaceURI, XmlDocument doc); + protected internal XmlElement(string? prefix, string localName, string? namespaceURI, XmlDocument doc); } public class XmlNamespaceManager : IEnumerable, IXmlNamespaceResolver { public virtual void AddNamespace(string prefix, string uri); public virtual string? LookupPrefix(string uri); public virtual void RemoveNamespace(string prefix, string uri); } public class XmlProcessingInstruction : XmlLinkedNode { - protected internal XmlProcessingInstruction(string target, string data, XmlDocument doc); + protected internal XmlProcessingInstruction(string target, string? data, XmlDocument doc); public string Data { get; set; } public override string InnerText { get; set; } - public string? Target { get; } + public string Target { get; } } public class XmlQualifiedName { - public static string ToString(string name, string ns); + public static string ToString(string name, string? ns); } public abstract class XmlResolver { + public static XmlResolver ThrowingResolver { get; } } public class XmlSecureResolver : XmlResolver public class XmlTextReader : XmlReader, IXmlLineInfo, IXmlNamespaceResolver { public XmlTextReader(string url); public XmlTextReader(string url, Stream input); public XmlTextReader(string url, Stream input, XmlNameTable nt); public XmlTextReader(string url, TextReader input); public XmlTextReader(string url, TextReader input, XmlNameTable nt); public XmlTextReader(string url, XmlNameTable nt); public XmlTextReader(string xmlFragment, XmlNodeType fragType, XmlParserContext? context); } public class XmlValidatingReader : XmlReader, IXmlLineInfo, IXmlNamespaceResolver { public XmlValidatingReader(string xmlFragment, XmlNodeType fragType, XmlParserContext context); } }","title":"System.Xml"},{"location":"Microsoft.NETCore.App/7.0_System/","text":"System namespace System { public static class AppContext { + public static void SetData(string name, object? data); } public sealed class AppDomain : MarshalByRefObject { public static int GetCurrentThreadId(); } public class ArgumentException : SystemException { + public static void ThrowIfNullOrEmpty(string argument, string paramName = null); } public class ArgumentNullException : ArgumentException { + public unsafe static void ThrowIfNull(void* argument, string? paramName = null); } public abstract class Array : ICloneable, ICollection, IEnumerable, IList, IStructuralComparable, IStructuralEquatable { public static Array CreateInstance(Type elementType, int length); public static Array CreateInstance(Type elementType, params int[] lengths); public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds); public static Array CreateInstance(Type elementType, params long[] lengths); } - public readonly struct Byte : IComparable, IComparable<byte>, IConvertible, IEquatable<byte>, IFormattable, ISpanFormattable { + public readonly struct Byte : IAdditionOperators<byte, byte, byte>, IAdditiveIdentity<byte, byte>, IBinaryInteger<byte>, IBinaryNumber<byte>, IBitwiseOperators<byte, byte, byte>, IComparable, IComparable<byte>, IComparisonOperators<byte, byte, bool>, IConvertible, IDecrementOperators<byte>, IDivisionOperators<byte, byte, byte>, IEqualityOperators<byte, byte, bool>, IEquatable<byte>, IFormattable, IIncrementOperators<byte>, IMinMaxValue<byte>, IModulusOperators<byte, byte, byte>, IMultiplicativeIdentity<byte, byte>, IMultiplyOperators<byte, byte, byte>, INumber<byte>, INumberBase<byte>, IParsable<byte>, IShiftOperators<byte, int, byte>, ISpanFormattable, ISpanParsable<byte>, ISubtractionOperators<byte, byte, byte>, IUnaryNegationOperators<byte, byte>, IUnaryPlusOperators<byte, byte>, IUnsignedNumber<byte> { + static byte System.Numerics.IAdditiveIdentity<System.Byte,System.Byte>.AdditiveIdentity { get; } + static byte System.Numerics.IBinaryNumber<System.Byte>.AllBitsSet { get; } + static byte System.Numerics.IMinMaxValue<System.Byte>.MaxValue { get; } + static byte System.Numerics.IMinMaxValue<System.Byte>.MinValue { get; } + static byte System.Numerics.IMultiplicativeIdentity<System.Byte,System.Byte>.MultiplicativeIdentity { get; } + static byte System.Numerics.INumberBase<System.Byte>.One { get; } + static int System.Numerics.INumberBase<System.Byte>.Radix { get; } + static byte System.Numerics.INumberBase<System.Byte>.Zero { get; } + public static byte Clamp(byte value, byte min, byte max); + public static byte CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static byte CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static byte CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (byte Quotient, byte Remainder) DivRem(byte left, byte right); + public static bool IsEvenInteger(byte value); + public static bool IsOddInteger(byte value); + public static bool IsPow2(byte value); + public static byte LeadingZeroCount(byte value); + public static byte Log2(byte value); + public static byte Max(byte x, byte y); + public static byte Min(byte x, byte y); + public static byte Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static byte PopCount(byte value); + public static byte RotateLeft(byte value, int rotateAmount); + public static byte RotateRight(byte value, int rotateAmount); + public static int Sign(byte value); + static byte IAdditionOperators<byte, byte, byte>.operator +(byte left, byte right); + static byte IAdditionOperators<byte, byte, byte>.operator checked +(byte left, byte right); + int IBinaryInteger<byte>.GetByteCount(); + int IBinaryInteger<byte>.GetShortestBitLength(); + static bool IBinaryInteger<byte>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out byte value); + static bool IBinaryInteger<byte>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out byte value); + bool IBinaryInteger<byte>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<byte>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static byte IBitwiseOperators<byte, byte, byte>.operator &(byte left, byte right); + static byte IBitwiseOperators<byte, byte, byte>.operator |(byte left, byte right); + static byte IBitwiseOperators<byte, byte, byte>.operator ^(byte left, byte right); + static byte IBitwiseOperators<byte, byte, byte>.operator ~(byte value); + static bool IComparisonOperators<byte, byte, bool>.operator >(byte left, byte right); + static bool IComparisonOperators<byte, byte, bool>.operator >=(byte left, byte right); + static bool IComparisonOperators<byte, byte, bool>.operator <(byte left, byte right); + static bool IComparisonOperators<byte, byte, bool>.operator <=(byte left, byte right); + static byte IDecrementOperators<byte>.operator checked --(byte value); + static byte IDecrementOperators<byte>.operator --(byte value); + static byte IDivisionOperators<byte, byte, byte>.operator /(byte left, byte right); + static bool IEqualityOperators<byte, byte, bool>.operator ==(byte left, byte right); + static bool IEqualityOperators<byte, byte, bool>.operator !=(byte left, byte right); + static byte IIncrementOperators<byte>.operator checked ++(byte value); + static byte IIncrementOperators<byte>.operator ++(byte value); + static byte IModulusOperators<byte, byte, byte>.operator %(byte left, byte right); + static byte IMultiplyOperators<byte, byte, byte>.operator checked *(byte left, byte right); + static byte IMultiplyOperators<byte, byte, byte>.operator *(byte left, byte right); + static byte INumber<byte>.CopySign(byte value, byte sign); + static byte INumber<byte>.MaxNumber(byte x, byte y); + static byte INumber<byte>.MinNumber(byte x, byte y); + static byte INumberBase<byte>.Abs(byte value); + static bool INumberBase<byte>.IsCanonical(byte value); + static bool INumberBase<byte>.IsComplexNumber(byte value); + static bool INumberBase<byte>.IsFinite(byte value); + static bool INumberBase<byte>.IsImaginaryNumber(byte value); + static bool INumberBase<byte>.IsInfinity(byte value); + static bool INumberBase<byte>.IsInteger(byte value); + static bool INumberBase<byte>.IsNaN(byte value); + static bool INumberBase<byte>.IsNegative(byte value); + static bool INumberBase<byte>.IsNegativeInfinity(byte value); + static bool INumberBase<byte>.IsNormal(byte value); + static bool INumberBase<byte>.IsPositive(byte value); + static bool INumberBase<byte>.IsPositiveInfinity(byte value); + static bool INumberBase<byte>.IsRealNumber(byte value); + static bool INumberBase<byte>.IsSubnormal(byte value); + static bool INumberBase<byte>.IsZero(byte value); + static byte INumberBase<byte>.MaxMagnitude(byte x, byte y); + static byte INumberBase<byte>.MaxMagnitudeNumber(byte x, byte y); + static byte INumberBase<byte>.MinMagnitude(byte x, byte y); + static byte INumberBase<byte>.MinMagnitudeNumber(byte x, byte y); + static bool INumberBase<byte>.TryConvertFromChecked<TOther>(TOther value, out byte result); + static bool INumberBase<byte>.TryConvertFromSaturating<TOther>(TOther value, out byte result); + static bool INumberBase<byte>.TryConvertFromTruncating<TOther>(TOther value, out byte result); + static bool INumberBase<byte>.TryConvertToChecked<TOther>(byte value, out TOther result); + static bool INumberBase<byte>.TryConvertToSaturating<TOther>(byte value, out TOther result); + static bool INumberBase<byte>.TryConvertToTruncating<TOther>(byte value, out TOther result); + static byte IShiftOperators<byte, int, byte>.operator <<(byte value, int shiftAmount); + static byte IShiftOperators<byte, int, byte>.operator >>(byte value, int shiftAmount); + static byte IShiftOperators<byte, int, byte>.operator >>>(byte value, int shiftAmount); + static byte ISubtractionOperators<byte, byte, byte>.operator checked -(byte left, byte right); + static byte ISubtractionOperators<byte, byte, byte>.operator -(byte left, byte right); + static byte IUnaryNegationOperators<byte, byte>.operator checked -(byte value); + static byte IUnaryNegationOperators<byte, byte>.operator -(byte value); + static byte IUnaryPlusOperators<byte, byte>.operator +(byte value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static byte TrailingZeroCount(byte value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out byte result); + public static bool TryParse(string? s, IFormatProvider? provider, out byte result); } - public readonly struct Char : IComparable, IComparable<char>, IConvertible, IEquatable<char>, IFormattable, ISpanFormattable { + public readonly struct Char : IAdditionOperators<char, char, char>, IAdditiveIdentity<char, char>, IBinaryInteger<char>, IBinaryNumber<char>, IBitwiseOperators<char, char, char>, IComparable, IComparable<char>, IComparisonOperators<char, char, bool>, IConvertible, IDecrementOperators<char>, IDivisionOperators<char, char, char>, IEqualityOperators<char, char, bool>, IEquatable<char>, IFormattable, IIncrementOperators<char>, IMinMaxValue<char>, IModulusOperators<char, char, char>, IMultiplicativeIdentity<char, char>, IMultiplyOperators<char, char, char>, INumber<char>, INumberBase<char>, IParsable<char>, IShiftOperators<char, int, char>, ISpanFormattable, ISpanParsable<char>, ISubtractionOperators<char, char, char>, IUnaryNegationOperators<char, char>, IUnaryPlusOperators<char, char>, IUnsignedNumber<char> { + static char System.Numerics.IAdditiveIdentity<System.Char,System.Char>.AdditiveIdentity { get; } + static char System.Numerics.IBinaryNumber<System.Char>.AllBitsSet { get; } + static char System.Numerics.IMinMaxValue<System.Char>.MaxValue { get; } + static char System.Numerics.IMinMaxValue<System.Char>.MinValue { get; } + static char System.Numerics.IMultiplicativeIdentity<System.Char,System.Char>.MultiplicativeIdentity { get; } + static char System.Numerics.INumberBase<System.Char>.One { get; } + static int System.Numerics.INumberBase<System.Char>.Radix { get; } + static char System.Numerics.INumberBase<System.Char>.Zero { get; } + public static bool IsAsciiDigit(char c); + public static bool IsAsciiHexDigit(char c); + public static bool IsAsciiHexDigitLower(char c); + public static bool IsAsciiHexDigitUpper(char c); + public static bool IsAsciiLetter(char c); + public static bool IsAsciiLetterLower(char c); + public static bool IsAsciiLetterOrDigit(char c); + public static bool IsAsciiLetterUpper(char c); + public static bool IsBetween(char c, char minInclusive, char maxInclusive); + static char IParsable<char>.Parse(string s, IFormatProvider provider); + static bool IParsable<char>.TryParse(string s, IFormatProvider provider, out char result); + static char ISpanParsable<char>.Parse(ReadOnlySpan<char> s, IFormatProvider provider); + static bool ISpanParsable<char>.TryParse(ReadOnlySpan<char> s, IFormatProvider provider, out char result); + static char IAdditionOperators<char, char, char>.operator +(char left, char right); + static char IAdditionOperators<char, char, char>.operator checked +(char left, char right); + int IBinaryInteger<char>.GetByteCount(); + int IBinaryInteger<char>.GetShortestBitLength(); + static char IBinaryInteger<char>.LeadingZeroCount(char value); + static char IBinaryInteger<char>.PopCount(char value); + static char IBinaryInteger<char>.RotateLeft(char value, int rotateAmount); + static char IBinaryInteger<char>.RotateRight(char value, int rotateAmount); + static char IBinaryInteger<char>.TrailingZeroCount(char value); + static bool IBinaryInteger<char>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out char value); + static bool IBinaryInteger<char>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out char value); + bool IBinaryInteger<char>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<char>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static bool IBinaryNumber<char>.IsPow2(char value); + static char IBinaryNumber<char>.Log2(char value); + static char IBitwiseOperators<char, char, char>.operator &(char left, char right); + static char IBitwiseOperators<char, char, char>.operator |(char left, char right); + static char IBitwiseOperators<char, char, char>.operator ^(char left, char right); + static char IBitwiseOperators<char, char, char>.operator ~(char value); + static bool IComparisonOperators<char, char, bool>.operator >(char left, char right); + static bool IComparisonOperators<char, char, bool>.operator >=(char left, char right); + static bool IComparisonOperators<char, char, bool>.operator <(char left, char right); + static bool IComparisonOperators<char, char, bool>.operator <=(char left, char right); + static char IDecrementOperators<char>.operator checked --(char value); + static char IDecrementOperators<char>.operator --(char value); + static char IDivisionOperators<char, char, char>.operator /(char left, char right); + static bool IEqualityOperators<char, char, bool>.operator ==(char left, char right); + static bool IEqualityOperators<char, char, bool>.operator !=(char left, char right); + static char IIncrementOperators<char>.operator checked ++(char value); + static char IIncrementOperators<char>.operator ++(char value); + static char IModulusOperators<char, char, char>.operator %(char left, char right); + static char IMultiplyOperators<char, char, char>.operator checked *(char left, char right); + static char IMultiplyOperators<char, char, char>.operator *(char left, char right); + static char INumberBase<char>.Abs(char value); + static bool INumberBase<char>.IsCanonical(char value); + static bool INumberBase<char>.IsComplexNumber(char value); + static bool INumberBase<char>.IsEvenInteger(char value); + static bool INumberBase<char>.IsFinite(char value); + static bool INumberBase<char>.IsImaginaryNumber(char value); + static bool INumberBase<char>.IsInfinity(char value); + static bool INumberBase<char>.IsInteger(char value); + static bool INumberBase<char>.IsNaN(char value); + static bool INumberBase<char>.IsNegative(char value); + static bool INumberBase<char>.IsNegativeInfinity(char value); + static bool INumberBase<char>.IsNormal(char value); + static bool INumberBase<char>.IsOddInteger(char value); + static bool INumberBase<char>.IsPositive(char value); + static bool INumberBase<char>.IsPositiveInfinity(char value); + static bool INumberBase<char>.IsRealNumber(char value); + static bool INumberBase<char>.IsSubnormal(char value); + static bool INumberBase<char>.IsZero(char value); + static char INumberBase<char>.MaxMagnitude(char x, char y); + static char INumberBase<char>.MaxMagnitudeNumber(char x, char y); + static char INumberBase<char>.MinMagnitude(char x, char y); + static char INumberBase<char>.MinMagnitudeNumber(char x, char y); + static char INumberBase<char>.Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider); + static char INumberBase<char>.Parse(string s, NumberStyles style, IFormatProvider provider); + static bool INumberBase<char>.TryConvertFromChecked<TOther>(TOther value, out char result); + static bool INumberBase<char>.TryConvertFromSaturating<TOther>(TOther value, out char result); + static bool INumberBase<char>.TryConvertFromTruncating<TOther>(TOther value, out char result); + static bool INumberBase<char>.TryConvertToChecked<TOther>(char value, out TOther result); + static bool INumberBase<char>.TryConvertToSaturating<TOther>(char value, out TOther result); + static bool INumberBase<char>.TryConvertToTruncating<TOther>(char value, out TOther result); + static bool INumberBase<char>.TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out char result); + static bool INumberBase<char>.TryParse(string s, NumberStyles style, IFormatProvider provider, out char result); + static char IShiftOperators<char, int, char>.operator <<(char value, int shiftAmount); + static char IShiftOperators<char, int, char>.operator >>(char value, int shiftAmount); + static char IShiftOperators<char, int, char>.operator >>>(char value, int shiftAmount); + static char ISubtractionOperators<char, char, char>.operator checked -(char left, char right); + static char ISubtractionOperators<char, char, char>.operator -(char left, char right); + static char IUnaryNegationOperators<char, char>.operator checked -(char value); + static char IUnaryNegationOperators<char, char>.operator -(char value); + static char IUnaryPlusOperators<char, char>.operator +(char value); } public static class Console { public static void Write(string format, object? arg0); public static void Write(string format, object? arg0, object? arg1); public static void Write(string format, object? arg0, object? arg1, object? arg2); public static void Write(string format, params object?[]? arg); public static void WriteLine(string format, object? arg0); public static void WriteLine(string format, object? arg0, object? arg1); public static void WriteLine(string format, object? arg0, object? arg1, object? arg2); public static void WriteLine(string format, params object?[]? arg); } - public readonly struct DateOnly : IComparable, IComparable<DateOnly>, IEquatable<DateOnly>, IFormattable, ISpanFormattable { + public readonly struct DateOnly : IComparable, IComparable<DateOnly>, IEquatable<DateOnly>, IFormattable, IParsable<DateOnly>, ISpanFormattable, ISpanParsable<DateOnly> { + public static DateOnly Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static DateOnly Parse(string s, IFormatProvider? provider); public static DateOnly ParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider = null, DateTimeStyles style = DateTimeStyles.None); public static DateOnly ParseExact(ReadOnlySpan<char> s, string[] formats); public static DateOnly ParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateOnly ParseExact(string s, string format); public static DateOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateOnly ParseExact(string s, string[] formats); public static DateOnly ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DateOnly result); + public static bool TryParse(string? s, IFormatProvider? provider, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); public static bool TryParseExact(string? s, string? format, out DateOnly result); public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); public static bool TryParseExact(string? s, string?[]? formats, out DateOnly result); public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); } - public readonly struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable, IParsable<DateTime>, ISerializable, ISpanFormattable, ISpanParsable<DateTime> { + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond); + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, DateTimeKind kind); + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar); + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, DateTimeKind kind); + public int Microsecond { get; } + public int Nanosecond { get; } + public DateTime AddMicroseconds(double value); + public static DateTime Parse(ReadOnlySpan<char> s, IFormatProvider? provider); public static DateTime ParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateTime ParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateTime ParseExact(string s, string format, IFormatProvider? provider); public static DateTime ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style); public static DateTime ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DateTime result); + public static bool TryParse(string? s, IFormatProvider? provider, out DateTime result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style, out DateTime result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateTime result); public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out DateTime result); public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateTime result); } - public readonly struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, IFormattable, IParsable<DateTimeOffset>, ISerializable, ISpanFormattable, ISpanParsable<DateTimeOffset> { + public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, TimeSpan offset); + public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, TimeSpan offset); + public int Microsecond { get; } + public int Nanosecond { get; } + public DateTimeOffset AddMicroseconds(double microseconds); + public static DateTimeOffset Parse(ReadOnlySpan<char> s, IFormatProvider? provider); public static DateTimeOffset ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, DateTimeStyles styles = DateTimeStyles.None); public static DateTimeOffset ParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider? formatProvider, DateTimeStyles styles = DateTimeStyles.None); public static DateTimeOffset ParseExact(string input, string format, IFormatProvider? formatProvider); public static DateTimeOffset ParseExact(string input, string format, IFormatProvider? formatProvider, DateTimeStyles styles); public static DateTimeOffset ParseExact(string input, string[] formats, IFormatProvider? formatProvider, DateTimeStyles styles); public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? formatProvider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DateTimeOffset result); + public static bool TryParse(string? s, IFormatProvider? provider, out DateTimeOffset result); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); public static bool TryParseExact(ReadOnlySpan<char> input, string?[]? formats, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); } - public readonly struct Decimal : IComparable, IComparable<decimal>, IConvertible, IDeserializationCallback, IEquatable<decimal>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct Decimal : IAdditionOperators<decimal, decimal, decimal>, IAdditiveIdentity<decimal, decimal>, IComparable, IComparable<decimal>, IComparisonOperators<decimal, decimal, bool>, IConvertible, IDecrementOperators<decimal>, IDeserializationCallback, IDivisionOperators<decimal, decimal, decimal>, IEqualityOperators<decimal, decimal, bool>, IEquatable<decimal>, IFloatingPoint<decimal>, IFloatingPointConstants<decimal>, IFormattable, IIncrementOperators<decimal>, IMinMaxValue<decimal>, IModulusOperators<decimal, decimal, decimal>, IMultiplicativeIdentity<decimal, decimal>, IMultiplyOperators<decimal, decimal, decimal>, INumber<decimal>, INumberBase<decimal>, IParsable<decimal>, ISerializable, ISignedNumber<decimal>, ISpanFormattable, ISpanParsable<decimal>, ISubtractionOperators<decimal, decimal, decimal>, IUnaryNegationOperators<decimal, decimal>, IUnaryPlusOperators<decimal, decimal> { + public byte Scale { get; } + static decimal System.Numerics.IAdditiveIdentity<System.Decimal,System.Decimal>.AdditiveIdentity { get; } + static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.E { get; } + static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Pi { get; } + static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Tau { get; } + static decimal System.Numerics.IMinMaxValue<System.Decimal>.MaxValue { get; } + static decimal System.Numerics.IMinMaxValue<System.Decimal>.MinValue { get; } + static decimal System.Numerics.IMultiplicativeIdentity<System.Decimal,System.Decimal>.MultiplicativeIdentity { get; } + static decimal System.Numerics.INumberBase<System.Decimal>.One { get; } + static int System.Numerics.INumberBase<System.Decimal>.Radix { get; } + static decimal System.Numerics.INumberBase<System.Decimal>.Zero { get; } + static decimal System.Numerics.ISignedNumber<System.Decimal>.NegativeOne { get; } + public static decimal Abs(decimal value); + public static decimal Clamp(decimal value, decimal min, decimal max); + public static decimal CopySign(decimal value, decimal sign); + public static decimal CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static decimal CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static decimal CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static bool IsCanonical(decimal value); + public static bool IsEvenInteger(decimal value); + public static bool IsInteger(decimal value); + public static bool IsNegative(decimal value); + public static bool IsOddInteger(decimal value); + public static bool IsPositive(decimal value); + public static decimal Max(decimal x, decimal y); + public static decimal MaxMagnitude(decimal x, decimal y); + public static decimal Min(decimal x, decimal y); + public static decimal MinMagnitude(decimal x, decimal y); + public static decimal Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static int Sign(decimal d); + int IFloatingPoint<decimal>.GetExponentByteCount(); + int IFloatingPoint<decimal>.GetExponentShortestBitLength(); + int IFloatingPoint<decimal>.GetSignificandBitLength(); + int IFloatingPoint<decimal>.GetSignificandByteCount(); + bool IFloatingPoint<decimal>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<decimal>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<decimal>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<decimal>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static decimal INumber<decimal>.MaxNumber(decimal x, decimal y); + static decimal INumber<decimal>.MinNumber(decimal x, decimal y); + static bool INumberBase<decimal>.IsComplexNumber(decimal value); + static bool INumberBase<decimal>.IsFinite(decimal value); + static bool INumberBase<decimal>.IsImaginaryNumber(decimal value); + static bool INumberBase<decimal>.IsInfinity(decimal value); + static bool INumberBase<decimal>.IsNaN(decimal value); + static bool INumberBase<decimal>.IsNegativeInfinity(decimal value); + static bool INumberBase<decimal>.IsNormal(decimal value); + static bool INumberBase<decimal>.IsPositiveInfinity(decimal value); + static bool INumberBase<decimal>.IsRealNumber(decimal value); + static bool INumberBase<decimal>.IsSubnormal(decimal value); + static bool INumberBase<decimal>.IsZero(decimal value); + static decimal INumberBase<decimal>.MaxMagnitudeNumber(decimal x, decimal y); + static decimal INumberBase<decimal>.MinMagnitudeNumber(decimal x, decimal y); + static bool INumberBase<decimal>.TryConvertFromChecked<TOther>(TOther value, out decimal result); + static bool INumberBase<decimal>.TryConvertFromSaturating<TOther>(TOther value, out decimal result); + static bool INumberBase<decimal>.TryConvertFromTruncating<TOther>(TOther value, out decimal result); + static bool INumberBase<decimal>.TryConvertToChecked<TOther>(decimal value, out TOther result); + static bool INumberBase<decimal>.TryConvertToSaturating<TOther>(decimal value, out TOther result); + static bool INumberBase<decimal>.TryConvertToTruncating<TOther>(decimal value, out TOther result); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out decimal result); + public static bool TryParse(string? s, IFormatProvider? provider, out decimal result); } - public readonly struct Double : IComparable, IComparable<double>, IConvertible, IEquatable<double>, IFormattable, ISpanFormattable { + public readonly struct Double : IAdditionOperators<double, double, double>, IAdditiveIdentity<double, double>, IBinaryFloatingPointIeee754<double>, IBinaryNumber<double>, IBitwiseOperators<double, double, double>, IComparable, IComparable<double>, IComparisonOperators<double, double, bool>, IConvertible, IDecrementOperators<double>, IDivisionOperators<double, double, double>, IEqualityOperators<double, double, bool>, IEquatable<double>, IExponentialFunctions<double>, IFloatingPoint<double>, IFloatingPointConstants<double>, IFloatingPointIeee754<double>, IFormattable, IHyperbolicFunctions<double>, IIncrementOperators<double>, ILogarithmicFunctions<double>, IMinMaxValue<double>, IModulusOperators<double, double, double>, IMultiplicativeIdentity<double, double>, IMultiplyOperators<double, double, double>, INumber<double>, INumberBase<double>, IParsable<double>, IPowerFunctions<double>, IRootFunctions<double>, ISignedNumber<double>, ISpanFormattable, ISpanParsable<double>, ISubtractionOperators<double, double, double>, ITrigonometricFunctions<double>, IUnaryNegationOperators<double, double>, IUnaryPlusOperators<double, double> { + public const double E = 2.718281828459045; + public const double NegativeZero = 0; + public const double Pi = 3.141592653589793; + public const double Tau = 6.283185307179586; + static double System.Numerics.IAdditiveIdentity<System.Double,System.Double>.AdditiveIdentity { get; } + static double System.Numerics.IBinaryNumber<System.Double>.AllBitsSet { get; } + static double System.Numerics.IFloatingPointConstants<System.Double>.E { get; } + static double System.Numerics.IFloatingPointConstants<System.Double>.Pi { get; } + static double System.Numerics.IFloatingPointConstants<System.Double>.Tau { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.Epsilon { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.NaN { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeInfinity { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeZero { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.PositiveInfinity { get; } + static double System.Numerics.IMinMaxValue<System.Double>.MaxValue { get; } + static double System.Numerics.IMinMaxValue<System.Double>.MinValue { get; } + static double System.Numerics.IMultiplicativeIdentity<System.Double,System.Double>.MultiplicativeIdentity { get; } + static double System.Numerics.INumberBase<System.Double>.One { get; } + static int System.Numerics.INumberBase<System.Double>.Radix { get; } + static double System.Numerics.INumberBase<System.Double>.Zero { get; } + static double System.Numerics.ISignedNumber<System.Double>.NegativeOne { get; } + public static double Abs(double value); + public static double Acos(double x); + public static double Acosh(double x); + public static double AcosPi(double x); + public static double Asin(double x); + public static double Asinh(double x); + public static double AsinPi(double x); + public static double Atan(double x); + public static double Atan2(double y, double x); + public static double Atan2Pi(double y, double x); + public static double Atanh(double x); + public static double AtanPi(double x); + public static double BitDecrement(double x); + public static double BitIncrement(double x); + public static double Cbrt(double x); + public static double Ceiling(double x); + public static double Clamp(double value, double min, double max); + public static double CopySign(double value, double sign); + public static double Cos(double x); + public static double Cosh(double x); + public static double CosPi(double x); + public static double CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static double CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static double CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static double Exp(double x); + public static double Exp10(double x); + public static double Exp10M1(double x); + public static double Exp2(double x); + public static double Exp2M1(double x); + public static double ExpM1(double x); + public static double Floor(double x); + public static double FusedMultiplyAdd(double left, double right, double addend); + public static double Hypot(double x, double y); + public static double Ieee754Remainder(double left, double right); + public static int ILogB(double x); + public static bool IsEvenInteger(double value); + public static bool IsInteger(double value); + public static bool IsOddInteger(double value); + public static bool IsPositive(double value); + public static bool IsPow2(double value); + public static bool IsRealNumber(double value); + public static double Log(double x); + public static double Log(double x, double newBase); + public static double Log10(double x); + public static double Log10P1(double x); + public static double Log2(double value); + public static double Log2P1(double x); + public static double LogP1(double x); + public static double Max(double x, double y); + public static double MaxMagnitude(double x, double y); + public static double MaxMagnitudeNumber(double x, double y); + public static double MaxNumber(double x, double y); + public static double Min(double x, double y); + public static double MinMagnitude(double x, double y); + public static double MinMagnitudeNumber(double x, double y); + public static double MinNumber(double x, double y); + public static double Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static double Pow(double x, double y); + public static double ReciprocalEstimate(double x); + public static double ReciprocalSqrtEstimate(double x); + public static double RootN(double x, int n); + public static double Round(double x); + public static double Round(double x, int digits); + public static double Round(double x, int digits, MidpointRounding mode); + public static double Round(double x, MidpointRounding mode); + public static double ScaleB(double x, int n); + public static int Sign(double value); + public static double Sin(double x); + public static (double Sin, double Cos) SinCos(double x); + public static (double SinPi, double CosPi) SinCosPi(double x); + public static double Sinh(double x); + public static double SinPi(double x); + public static double Sqrt(double x); + static double IAdditionOperators<double, double, double>.operator +(double left, double right); + static double IBitwiseOperators<double, double, double>.operator &(double left, double right); + static double IBitwiseOperators<double, double, double>.operator |(double left, double right); + static double IBitwiseOperators<double, double, double>.operator ^(double left, double right); + static double IBitwiseOperators<double, double, double>.operator ~(double value); + static double IDecrementOperators<double>.operator --(double value); + static double IDivisionOperators<double, double, double>.operator /(double left, double right); + int IFloatingPoint<double>.GetExponentByteCount(); + int IFloatingPoint<double>.GetExponentShortestBitLength(); + int IFloatingPoint<double>.GetSignificandBitLength(); + int IFloatingPoint<double>.GetSignificandByteCount(); + bool IFloatingPoint<double>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<double>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<double>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<double>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static double IIncrementOperators<double>.operator ++(double value); + static double IModulusOperators<double, double, double>.operator %(double left, double right); + static double IMultiplyOperators<double, double, double>.operator *(double left, double right); + static bool INumberBase<double>.IsCanonical(double value); + static bool INumberBase<double>.IsComplexNumber(double value); + static bool INumberBase<double>.IsImaginaryNumber(double value); + static bool INumberBase<double>.IsZero(double value); + static bool INumberBase<double>.TryConvertFromChecked<TOther>(TOther value, out double result); + static bool INumberBase<double>.TryConvertFromSaturating<TOther>(TOther value, out double result); + static bool INumberBase<double>.TryConvertFromTruncating<TOther>(TOther value, out double result); + static bool INumberBase<double>.TryConvertToChecked<TOther>(double value, out TOther result); + static bool INumberBase<double>.TryConvertToSaturating<TOther>(double value, out TOther result); + static bool INumberBase<double>.TryConvertToTruncating<TOther>(double value, out TOther result); + static double ISubtractionOperators<double, double, double>.operator -(double left, double right); + static double IUnaryNegationOperators<double, double>.operator -(double value); + static double IUnaryPlusOperators<double, double>.operator +(double value); + public static double Tan(double x); + public static double Tanh(double x); + public static double TanPi(double x); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static double Truncate(double x); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out double result); + public static bool TryParse(string? s, IFormatProvider? provider, out double result); } public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable { public static string Format(Type enumType, object value, string format); public static Array GetValues(Type enumType); + public static Array GetValuesAsUnderlyingType(Type enumType); + public static Array GetValuesAsUnderlyingType<TEnum>() where TEnum : struct; public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public static bool TryParse(Type enumType, ReadOnlySpan<char> value, bool ignoreCase, out object? result); public static bool TryParse(Type enumType, ReadOnlySpan<char> value, out object? result); public static bool TryParse(Type enumType, string? value, bool ignoreCase, out object? result); public static bool TryParse(Type enumType, string? value, out object? result); } public class Exception : ISerializable { public MethodBase TargetSite { get; } } public abstract class FormattableString : IFormattable { public abstract string Format { get; } } public static class GC { + public static IReadOnlyDictionary<string, object> GetConfigurationVariables(); + public static TimeSpan GetTotalPauseDuration(); + public static GCNotificationStatus WaitForFullGCApproach(TimeSpan timeout); + public static GCNotificationStatus WaitForFullGCComplete(TimeSpan timeout); } public enum GCCollectionMode { + Aggressive = 3, } - public readonly struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable, ISpanFormattable { + public readonly struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable, IParsable<Guid>, ISpanFormattable, ISpanParsable<Guid> { + public static bool operator >(Guid left, Guid right); + public static bool operator >=(Guid left, Guid right); + public static bool operator <(Guid left, Guid right); + public static bool operator <=(Guid left, Guid right); + public static Guid Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Guid Parse(string s, IFormatProvider? provider); public static Guid ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format); public static Guid ParseExact(string input, string format); bool ISpanFormattable.TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider provider); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>)); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Guid result); + public static bool TryParse(string? s, IFormatProvider? provider, out Guid result); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, out Guid result); public static bool TryParseExact(string? input, string? format, out Guid result); } - public readonly struct Half : IComparable, IComparable<Half>, IEquatable<Half>, IFormattable, ISpanFormattable { + public readonly struct Half : IAdditionOperators<Half, Half, Half>, IAdditiveIdentity<Half, Half>, IBinaryFloatingPointIeee754<Half>, IBinaryNumber<Half>, IBitwiseOperators<Half, Half, Half>, IComparable, IComparable<Half>, IComparisonOperators<Half, Half, bool>, IDecrementOperators<Half>, IDivisionOperators<Half, Half, Half>, IEqualityOperators<Half, Half, bool>, IEquatable<Half>, IExponentialFunctions<Half>, IFloatingPoint<Half>, IFloatingPointConstants<Half>, IFloatingPointIeee754<Half>, IFormattable, IHyperbolicFunctions<Half>, IIncrementOperators<Half>, ILogarithmicFunctions<Half>, IMinMaxValue<Half>, IModulusOperators<Half, Half, Half>, IMultiplicativeIdentity<Half, Half>, IMultiplyOperators<Half, Half, Half>, INumber<Half>, INumberBase<Half>, IParsable<Half>, IPowerFunctions<Half>, IRootFunctions<Half>, ISignedNumber<Half>, ISpanFormattable, ISpanParsable<Half>, ISubtractionOperators<Half, Half, Half>, ITrigonometricFunctions<Half>, IUnaryNegationOperators<Half, Half>, IUnaryPlusOperators<Half, Half> { + public static Half E { get; } + public static Half MultiplicativeIdentity { get; } + public static Half NegativeOne { get; } + public static Half NegativeZero { get; } + public static Half One { get; } + public static Half Pi { get; } + static Half System.Numerics.IAdditiveIdentity<System.Half,System.Half>.AdditiveIdentity { get; } + static Half System.Numerics.IBinaryNumber<System.Half>.AllBitsSet { get; } + static int System.Numerics.INumberBase<System.Half>.Radix { get; } + public static Half Tau { get; } + public static Half Zero { get; } + public static Half Abs(Half value); + public static Half Acos(Half x); + public static Half Acosh(Half x); + public static Half AcosPi(Half x); + public static Half Asin(Half x); + public static Half Asinh(Half x); + public static Half AsinPi(Half x); + public static Half Atan(Half x); + public static Half Atan2(Half y, Half x); + public static Half Atan2Pi(Half y, Half x); + public static Half Atanh(Half x); + public static Half AtanPi(Half x); + public static Half BitDecrement(Half x); + public static Half BitIncrement(Half x); + public static Half Cbrt(Half x); + public static Half Ceiling(Half x); + public static Half Clamp(Half value, Half min, Half max); + public static Half CopySign(Half value, Half sign); + public static Half Cos(Half x); + public static Half Cosh(Half x); + public static Half CosPi(Half x); + public static Half CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Half CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Half CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Half Exp(Half x); + public static Half Exp10(Half x); + public static Half Exp10M1(Half x); + public static Half Exp2(Half x); + public static Half Exp2M1(Half x); + public static Half ExpM1(Half x); + public static Half Floor(Half x); + public static Half FusedMultiplyAdd(Half left, Half right, Half addend); + public static Half Hypot(Half x, Half y); + public static Half Ieee754Remainder(Half left, Half right); + public static int ILogB(Half x); + public static bool IsEvenInteger(Half value); + public static bool IsInteger(Half value); + public static bool IsOddInteger(Half value); + public static bool IsPositive(Half value); + public static bool IsPow2(Half value); + public static bool IsRealNumber(Half value); + public static Half Log(Half x); + public static Half Log(Half x, Half newBase); + public static Half Log10(Half x); + public static Half Log10P1(Half x); + public static Half Log2(Half value); + public static Half Log2P1(Half x); + public static Half LogP1(Half x); + public static Half Max(Half x, Half y); + public static Half MaxMagnitude(Half x, Half y); + public static Half MaxMagnitudeNumber(Half x, Half y); + public static Half MaxNumber(Half x, Half y); + public static Half Min(Half x, Half y); + public static Half MinMagnitude(Half x, Half y); + public static Half MinMagnitudeNumber(Half x, Half y); + public static Half MinNumber(Half x, Half y); + public static Half operator +(Half left, Half right); + public static explicit operator checked byte (Half value); + public static explicit operator checked char (Half value); + public static explicit operator checked short (Half value); + public static explicit operator checked int (Half value); + public static explicit operator checked long (Half value); + public static explicit operator checked Int128 (Half value); + public static explicit operator checked IntPtr (Half value); + public static explicit operator checked sbyte (Half value); + public static explicit operator checked ushort (Half value); + public static explicit operator checked uint (Half value); + public static explicit operator checked ulong (Half value); + public static explicit operator checked UInt128 (Half value); + public static explicit operator checked UIntPtr (Half value); + public static Half operator --(Half value); + public static Half operator /(Half left, Half right); + public static explicit operator Half (char value); + public static explicit operator Half (decimal value); + public static explicit operator byte (Half value); + public static explicit operator char (Half value); + public static explicit operator decimal (Half value); + public static explicit operator Int128 (Half value); + public static explicit operator short (Half value); + public static explicit operator int (Half value); + public static explicit operator long (Half value); + public static explicit operator IntPtr (Half value); + public static explicit operator sbyte (Half value); + public static explicit operator UInt128 (Half value); + public static explicit operator ushort (Half value); + public static explicit operator uint (Half value); + public static explicit operator ulong (Half value); + public static explicit operator UIntPtr (Half value); + public static explicit operator Half (short value); + public static explicit operator Half (int value); + public static explicit operator Half (long value); + public static explicit operator Half (IntPtr value); + public static explicit operator Half (ushort value); + public static explicit operator Half (uint value); + public static explicit operator Half (ulong value); + public static explicit operator Half (UIntPtr value); + public static implicit operator Half (byte value); + public static implicit operator Half (sbyte value); + public static Half operator ++(Half value); + public static Half operator %(Half left, Half right); + public static Half operator *(Half left, Half right); + public static Half operator -(Half left, Half right); + public static Half operator -(Half value); + public static Half operator +(Half value); + public static Half Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Half Pow(Half x, Half y); + public static Half ReciprocalEstimate(Half x); + public static Half ReciprocalSqrtEstimate(Half x); + public static Half RootN(Half x, int n); + public static Half Round(Half x); + public static Half Round(Half x, int digits); + public static Half Round(Half x, int digits, MidpointRounding mode); + public static Half Round(Half x, MidpointRounding mode); + public static Half ScaleB(Half x, int n); + public static int Sign(Half value); + public static Half Sin(Half x); + public static (Half Sin, Half Cos) SinCos(Half x); + public static (Half SinPi, Half CosPi) SinCosPi(Half x); + public static Half Sinh(Half x); + public static Half SinPi(Half x); + public static Half Sqrt(Half x); + static Half IBitwiseOperators<Half, Half, Half>.operator &(Half left, Half right); + static Half IBitwiseOperators<Half, Half, Half>.operator |(Half left, Half right); + static Half IBitwiseOperators<Half, Half, Half>.operator ^(Half left, Half right); + static Half IBitwiseOperators<Half, Half, Half>.operator ~(Half value); + int IFloatingPoint<Half>.GetExponentByteCount(); + int IFloatingPoint<Half>.GetExponentShortestBitLength(); + int IFloatingPoint<Half>.GetSignificandBitLength(); + int IFloatingPoint<Half>.GetSignificandByteCount(); + bool IFloatingPoint<Half>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<Half>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<Half>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<Half>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static bool INumberBase<Half>.IsCanonical(Half value); + static bool INumberBase<Half>.IsComplexNumber(Half value); + static bool INumberBase<Half>.IsImaginaryNumber(Half value); + static bool INumberBase<Half>.IsZero(Half value); + static bool INumberBase<Half>.TryConvertFromChecked<TOther>(TOther value, out Half result); + static bool INumberBase<Half>.TryConvertFromSaturating<TOther>(TOther value, out Half result); + static bool INumberBase<Half>.TryConvertFromTruncating<TOther>(TOther value, out Half result); + static bool INumberBase<Half>.TryConvertToChecked<TOther>(Half value, out TOther result); + static bool INumberBase<Half>.TryConvertToSaturating<TOther>(Half value, out TOther result); + static bool INumberBase<Half>.TryConvertToTruncating<TOther>(Half value, out TOther result); + public static Half Tan(Half x); + public static Half Tanh(Half x); + public static Half TanPi(Half x); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static Half Truncate(Half x); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Half result); + public static bool TryParse(string? s, IFormatProvider? provider, out Half result); } + public readonly struct Int128 : IAdditionOperators<Int128, Int128, Int128>, IAdditiveIdentity<Int128, Int128>, IBinaryInteger<Int128>, IBinaryNumber<Int128>, IBitwiseOperators<Int128, Int128, Int128>, IComparable, IComparable<Int128>, IComparisonOperators<Int128, Int128, bool>, IDecrementOperators<Int128>, IDivisionOperators<Int128, Int128, Int128>, IEqualityOperators<Int128, Int128, bool>, IEquatable<Int128>, IFormattable, IIncrementOperators<Int128>, IMinMaxValue<Int128>, IModulusOperators<Int128, Int128, Int128>, IMultiplicativeIdentity<Int128, Int128>, IMultiplyOperators<Int128, Int128, Int128>, INumber<Int128>, INumberBase<Int128>, IParsable<Int128>, IShiftOperators<Int128, int, Int128>, ISignedNumber<Int128>, ISpanFormattable, ISpanParsable<Int128>, ISubtractionOperators<Int128, Int128, Int128>, IUnaryNegationOperators<Int128, Int128>, IUnaryPlusOperators<Int128, Int128> { + public Int128(ulong upper, ulong lower); + public static Int128 MaxValue { get; } + public static Int128 MinValue { get; } + public static Int128 NegativeOne { get; } + public static Int128 One { get; } + static Int128 System.Numerics.IAdditiveIdentity<System.Int128,System.Int128>.AdditiveIdentity { get; } + static Int128 System.Numerics.IBinaryNumber<System.Int128>.AllBitsSet { get; } + static Int128 System.Numerics.IMultiplicativeIdentity<System.Int128,System.Int128>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.Int128>.Radix { get; } + public static Int128 Zero { get; } + public static Int128 Abs(Int128 value); + public static Int128 Clamp(Int128 value, Int128 min, Int128 max); + public int CompareTo(Int128 value); + public int CompareTo(object? value); + public static Int128 CopySign(Int128 value, Int128 sign); + public static Int128 CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Int128 CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Int128 CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (Int128 Quotient, Int128 Remainder) DivRem(Int128 left, Int128 right); + public bool Equals(Int128 other); + public override bool Equals(object? obj); + public override int GetHashCode(); + public static bool IsEvenInteger(Int128 value); + public static bool IsNegative(Int128 value); + public static bool IsOddInteger(Int128 value); + public static bool IsPositive(Int128 value); + public static bool IsPow2(Int128 value); + public static Int128 LeadingZeroCount(Int128 value); + public static Int128 Log2(Int128 value); + public static Int128 Max(Int128 x, Int128 y); + public static Int128 MaxMagnitude(Int128 x, Int128 y); + public static Int128 Min(Int128 x, Int128 y); + public static Int128 MinMagnitude(Int128 x, Int128 y); + public static Int128 operator +(Int128 left, Int128 right); + public static Int128 operator &(Int128 left, Int128 right); + public static Int128 operator |(Int128 left, Int128 right); + public static Int128 operator checked +(Int128 left, Int128 right); + public static Int128 operator checked --(Int128 value); + public static Int128 operator checked /(Int128 left, Int128 right); + public static explicit operator checked Int128 (double value); + public static explicit operator checked byte (Int128 value); + public static explicit operator checked char (Int128 value); + public static explicit operator checked short (Int128 value); + public static explicit operator checked int (Int128 value); + public static explicit operator checked long (Int128 value); + public static explicit operator checked IntPtr (Int128 value); + public static explicit operator checked sbyte (Int128 value); + public static explicit operator checked ushort (Int128 value); + public static explicit operator checked uint (Int128 value); + public static explicit operator checked ulong (Int128 value); + public static explicit operator checked UInt128 (Int128 value); + public static explicit operator checked UIntPtr (Int128 value); + public static explicit operator checked Int128 (float value); + public static Int128 operator checked ++(Int128 value); + public static Int128 operator checked *(Int128 left, Int128 right); + public static Int128 operator checked -(Int128 left, Int128 right); + public static Int128 operator checked -(Int128 value); + public static Int128 operator --(Int128 value); + public static Int128 operator /(Int128 left, Int128 right); + public static bool operator ==(Int128 left, Int128 right); + public static Int128 operator ^(Int128 left, Int128 right); + public static explicit operator Int128 (decimal value); + public static explicit operator Int128 (double value); + public static explicit operator byte (Int128 value); + public static explicit operator char (Int128 value); + public static explicit operator decimal (Int128 value); + public static explicit operator double (Int128 value); + public static explicit operator Half (Int128 value); + public static explicit operator short (Int128 value); + public static explicit operator int (Int128 value); + public static explicit operator long (Int128 value); + public static explicit operator IntPtr (Int128 value); + public static explicit operator sbyte (Int128 value); + public static explicit operator float (Int128 value); + public static explicit operator UInt128 (Int128 value); + public static explicit operator ushort (Int128 value); + public static explicit operator uint (Int128 value); + public static explicit operator ulong (Int128 value); + public static explicit operator UIntPtr (Int128 value); + public static explicit operator Int128 (float value); + public static bool operator >(Int128 left, Int128 right); + public static bool operator >=(Int128 left, Int128 right); + public static implicit operator Int128 (byte value); + public static implicit operator Int128 (char value); + public static implicit operator Int128 (short value); + public static implicit operator Int128 (int value); + public static implicit operator Int128 (long value); + public static implicit operator Int128 (IntPtr value); + public static implicit operator Int128 (sbyte value); + public static implicit operator Int128 (ushort value); + public static implicit operator Int128 (uint value); + public static implicit operator Int128 (ulong value); + public static implicit operator Int128 (UIntPtr value); + public static Int128 operator ++(Int128 value); + public static bool operator !=(Int128 left, Int128 right); + public static Int128 operator <<(Int128 value, int shiftAmount); + public static bool operator <(Int128 left, Int128 right); + public static bool operator <=(Int128 left, Int128 right); + public static Int128 operator %(Int128 left, Int128 right); + public static Int128 operator *(Int128 left, Int128 right); + public static Int128 operator ~(Int128 value); + public static Int128 operator >>(Int128 value, int shiftAmount); + public static Int128 operator -(Int128 left, Int128 right); + public static Int128 operator -(Int128 value); + public static Int128 operator +(Int128 value); + public static Int128 operator >>>(Int128 value, int shiftAmount); + public static Int128 Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null); + public static Int128 Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Int128 Parse(string s); + public static Int128 Parse(string s, NumberStyles style); + public static Int128 Parse(string s, NumberStyles style, IFormatProvider? provider); + public static Int128 Parse(string s, IFormatProvider? provider); + public static Int128 PopCount(Int128 value); + public static Int128 RotateLeft(Int128 value, int rotateAmount); + public static Int128 RotateRight(Int128 value, int rotateAmount); + public static int Sign(Int128 value); + int IBinaryInteger<Int128>.GetByteCount(); + int IBinaryInteger<Int128>.GetShortestBitLength(); + static bool IBinaryInteger<Int128>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out Int128 value); + static bool IBinaryInteger<Int128>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out Int128 value); + bool IBinaryInteger<Int128>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<Int128>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static Int128 INumber<Int128>.MaxNumber(Int128 x, Int128 y); + static Int128 INumber<Int128>.MinNumber(Int128 x, Int128 y); + static bool INumberBase<Int128>.IsCanonical(Int128 value); + static bool INumberBase<Int128>.IsComplexNumber(Int128 value); + static bool INumberBase<Int128>.IsFinite(Int128 value); + static bool INumberBase<Int128>.IsImaginaryNumber(Int128 value); + static bool INumberBase<Int128>.IsInfinity(Int128 value); + static bool INumberBase<Int128>.IsInteger(Int128 value); + static bool INumberBase<Int128>.IsNaN(Int128 value); + static bool INumberBase<Int128>.IsNegativeInfinity(Int128 value); + static bool INumberBase<Int128>.IsNormal(Int128 value); + static bool INumberBase<Int128>.IsPositiveInfinity(Int128 value); + static bool INumberBase<Int128>.IsRealNumber(Int128 value); + static bool INumberBase<Int128>.IsSubnormal(Int128 value); + static bool INumberBase<Int128>.IsZero(Int128 value); + static Int128 INumberBase<Int128>.MaxMagnitudeNumber(Int128 x, Int128 y); + static Int128 INumberBase<Int128>.MinMagnitudeNumber(Int128 x, Int128 y); + static bool INumberBase<Int128>.TryConvertFromChecked<TOther>(TOther value, out Int128 result); + static bool INumberBase<Int128>.TryConvertFromSaturating<TOther>(TOther value, out Int128 result); + static bool INumberBase<Int128>.TryConvertFromTruncating<TOther>(TOther value, out Int128 result); + static bool INumberBase<Int128>.TryConvertToChecked<TOther>(Int128 value, out TOther result); + static bool INumberBase<Int128>.TryConvertToSaturating<TOther>(Int128 value, out TOther result); + static bool INumberBase<Int128>.TryConvertToTruncating<TOther>(Int128 value, out TOther result); + public override string ToString(); + public string ToString(IFormatProvider? provider); + public string ToString(string? format); + public string ToString(string? format, IFormatProvider? provider); + public static Int128 TrailingZeroCount(Int128 value); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out Int128 result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Int128 result); + public static bool TryParse(ReadOnlySpan<char> s, out Int128 result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out Int128 result); + public static bool TryParse(string? s, IFormatProvider? provider, out Int128 result); + public static bool TryParse(string? s, out Int128 result); + } - public readonly struct Int16 : IComparable, IComparable<short>, IConvertible, IEquatable<short>, IFormattable, ISpanFormattable { + public readonly struct Int16 : IAdditionOperators<short, short, short>, IAdditiveIdentity<short, short>, IBinaryInteger<short>, IBinaryNumber<short>, IBitwiseOperators<short, short, short>, IComparable, IComparable<short>, IComparisonOperators<short, short, bool>, IConvertible, IDecrementOperators<short>, IDivisionOperators<short, short, short>, IEqualityOperators<short, short, bool>, IEquatable<short>, IFormattable, IIncrementOperators<short>, IMinMaxValue<short>, IModulusOperators<short, short, short>, IMultiplicativeIdentity<short, short>, IMultiplyOperators<short, short, short>, INumber<short>, INumberBase<short>, IParsable<short>, IShiftOperators<short, int, short>, ISignedNumber<short>, ISpanFormattable, ISpanParsable<short>, ISubtractionOperators<short, short, short>, IUnaryNegationOperators<short, short>, IUnaryPlusOperators<short, short> { + static short System.Numerics.IAdditiveIdentity<System.Int16,System.Int16>.AdditiveIdentity { get; } + static short System.Numerics.IBinaryNumber<System.Int16>.AllBitsSet { get; } + static short System.Numerics.IMinMaxValue<System.Int16>.MaxValue { get; } + static short System.Numerics.IMinMaxValue<System.Int16>.MinValue { get; } + static short System.Numerics.IMultiplicativeIdentity<System.Int16,System.Int16>.MultiplicativeIdentity { get; } + static short System.Numerics.INumberBase<System.Int16>.One { get; } + static int System.Numerics.INumberBase<System.Int16>.Radix { get; } + static short System.Numerics.INumberBase<System.Int16>.Zero { get; } + static short System.Numerics.ISignedNumber<System.Int16>.NegativeOne { get; } + public static short Abs(short value); + public static short Clamp(short value, short min, short max); + public static short CopySign(short value, short sign); + public static short CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static short CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static short CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (short Quotient, short Remainder) DivRem(short left, short right); + public static bool IsEvenInteger(short value); + public static bool IsNegative(short value); + public static bool IsOddInteger(short value); + public static bool IsPositive(short value); + public static bool IsPow2(short value); + public static short LeadingZeroCount(short value); + public static short Log2(short value); + public static short Max(short x, short y); + public static short MaxMagnitude(short x, short y); + public static short Min(short x, short y); + public static short MinMagnitude(short x, short y); + public static short Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static short PopCount(short value); + public static short RotateLeft(short value, int rotateAmount); + public static short RotateRight(short value, int rotateAmount); + public static int Sign(short value); + static short IAdditionOperators<short, short, short>.operator +(short left, short right); + static short IAdditionOperators<short, short, short>.operator checked +(short left, short right); + int IBinaryInteger<short>.GetByteCount(); + int IBinaryInteger<short>.GetShortestBitLength(); + static bool IBinaryInteger<short>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out short value); + static bool IBinaryInteger<short>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out short value); + bool IBinaryInteger<short>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<short>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static short IBitwiseOperators<short, short, short>.operator &(short left, short right); + static short IBitwiseOperators<short, short, short>.operator |(short left, short right); + static short IBitwiseOperators<short, short, short>.operator ^(short left, short right); + static short IBitwiseOperators<short, short, short>.operator ~(short value); + static bool IComparisonOperators<short, short, bool>.operator >(short left, short right); + static bool IComparisonOperators<short, short, bool>.operator >=(short left, short right); + static bool IComparisonOperators<short, short, bool>.operator <(short left, short right); + static bool IComparisonOperators<short, short, bool>.operator <=(short left, short right); + static short IDecrementOperators<short>.operator checked --(short value); + static short IDecrementOperators<short>.operator --(short value); + static short IDivisionOperators<short, short, short>.operator /(short left, short right); + static bool IEqualityOperators<short, short, bool>.operator ==(short left, short right); + static bool IEqualityOperators<short, short, bool>.operator !=(short left, short right); + static short IIncrementOperators<short>.operator checked ++(short value); + static short IIncrementOperators<short>.operator ++(short value); + static short IModulusOperators<short, short, short>.operator %(short left, short right); + static short IMultiplyOperators<short, short, short>.operator checked *(short left, short right); + static short IMultiplyOperators<short, short, short>.operator *(short left, short right); + static short INumber<short>.MaxNumber(short x, short y); + static short INumber<short>.MinNumber(short x, short y); + static bool INumberBase<short>.IsCanonical(short value); + static bool INumberBase<short>.IsComplexNumber(short value); + static bool INumberBase<short>.IsFinite(short value); + static bool INumberBase<short>.IsImaginaryNumber(short value); + static bool INumberBase<short>.IsInfinity(short value); + static bool INumberBase<short>.IsInteger(short value); + static bool INumberBase<short>.IsNaN(short value); + static bool INumberBase<short>.IsNegativeInfinity(short value); + static bool INumberBase<short>.IsNormal(short value); + static bool INumberBase<short>.IsPositiveInfinity(short value); + static bool INumberBase<short>.IsRealNumber(short value); + static bool INumberBase<short>.IsSubnormal(short value); + static bool INumberBase<short>.IsZero(short value); + static short INumberBase<short>.MaxMagnitudeNumber(short x, short y); + static short INumberBase<short>.MinMagnitudeNumber(short x, short y); + static bool INumberBase<short>.TryConvertFromChecked<TOther>(TOther value, out short result); + static bool INumberBase<short>.TryConvertFromSaturating<TOther>(TOther value, out short result); + static bool INumberBase<short>.TryConvertFromTruncating<TOther>(TOther value, out short result); + static bool INumberBase<short>.TryConvertToChecked<TOther>(short value, out TOther result); + static bool INumberBase<short>.TryConvertToSaturating<TOther>(short value, out TOther result); + static bool INumberBase<short>.TryConvertToTruncating<TOther>(short value, out TOther result); + static short IShiftOperators<short, int, short>.operator <<(short value, int shiftAmount); + static short IShiftOperators<short, int, short>.operator >>(short value, int shiftAmount); + static short IShiftOperators<short, int, short>.operator >>>(short value, int shiftAmount); + static short ISubtractionOperators<short, short, short>.operator checked -(short left, short right); + static short ISubtractionOperators<short, short, short>.operator -(short left, short right); + static short IUnaryNegationOperators<short, short>.operator checked -(short value); + static short IUnaryNegationOperators<short, short>.operator -(short value); + static short IUnaryPlusOperators<short, short>.operator +(short value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static short TrailingZeroCount(short value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out short result); + public static bool TryParse(string? s, IFormatProvider? provider, out short result); } - public readonly struct Int32 : IComparable, IComparable<int>, IConvertible, IEquatable<int>, IFormattable, ISpanFormattable { + public readonly struct Int32 : IAdditionOperators<int, int, int>, IAdditiveIdentity<int, int>, IBinaryInteger<int>, IBinaryNumber<int>, IBitwiseOperators<int, int, int>, IComparable, IComparable<int>, IComparisonOperators<int, int, bool>, IConvertible, IDecrementOperators<int>, IDivisionOperators<int, int, int>, IEqualityOperators<int, int, bool>, IEquatable<int>, IFormattable, IIncrementOperators<int>, IMinMaxValue<int>, IModulusOperators<int, int, int>, IMultiplicativeIdentity<int, int>, IMultiplyOperators<int, int, int>, INumber<int>, INumberBase<int>, IParsable<int>, IShiftOperators<int, int, int>, ISignedNumber<int>, ISpanFormattable, ISpanParsable<int>, ISubtractionOperators<int, int, int>, IUnaryNegationOperators<int, int>, IUnaryPlusOperators<int, int> { + static int System.Numerics.IAdditiveIdentity<System.Int32,System.Int32>.AdditiveIdentity { get; } + static int System.Numerics.IBinaryNumber<System.Int32>.AllBitsSet { get; } + static int System.Numerics.IMinMaxValue<System.Int32>.MaxValue { get; } + static int System.Numerics.IMinMaxValue<System.Int32>.MinValue { get; } + static int System.Numerics.IMultiplicativeIdentity<System.Int32,System.Int32>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.Int32>.One { get; } + static int System.Numerics.INumberBase<System.Int32>.Radix { get; } + static int System.Numerics.INumberBase<System.Int32>.Zero { get; } + static int System.Numerics.ISignedNumber<System.Int32>.NegativeOne { get; } + public static int Abs(int value); + public static int Clamp(int value, int min, int max); + public static int CopySign(int value, int sign); + public static int CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static int CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static int CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (int Quotient, int Remainder) DivRem(int left, int right); + public static bool IsEvenInteger(int value); + public static bool IsNegative(int value); + public static bool IsOddInteger(int value); + public static bool IsPositive(int value); + public static bool IsPow2(int value); + public static int LeadingZeroCount(int value); + public static int Log2(int value); + public static int Max(int x, int y); + public static int MaxMagnitude(int x, int y); + public static int Min(int x, int y); + public static int MinMagnitude(int x, int y); + public static int Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static int PopCount(int value); + public static int RotateLeft(int value, int rotateAmount); + public static int RotateRight(int value, int rotateAmount); + public static int Sign(int value); + static int IAdditionOperators<int, int, int>.operator +(int left, int right); + static int IAdditionOperators<int, int, int>.operator checked +(int left, int right); + int IBinaryInteger<int>.GetByteCount(); + int IBinaryInteger<int>.GetShortestBitLength(); + static bool IBinaryInteger<int>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out int value); + static bool IBinaryInteger<int>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out int value); + bool IBinaryInteger<int>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<int>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static int IBitwiseOperators<int, int, int>.operator &(int left, int right); + static int IBitwiseOperators<int, int, int>.operator |(int left, int right); + static int IBitwiseOperators<int, int, int>.operator ^(int left, int right); + static int IBitwiseOperators<int, int, int>.operator ~(int value); + static bool IComparisonOperators<int, int, bool>.operator >(int left, int right); + static bool IComparisonOperators<int, int, bool>.operator >=(int left, int right); + static bool IComparisonOperators<int, int, bool>.operator <(int left, int right); + static bool IComparisonOperators<int, int, bool>.operator <=(int left, int right); + static int IDecrementOperators<int>.operator checked --(int value); + static int IDecrementOperators<int>.operator --(int value); + static int IDivisionOperators<int, int, int>.operator /(int left, int right); + static bool IEqualityOperators<int, int, bool>.operator ==(int left, int right); + static bool IEqualityOperators<int, int, bool>.operator !=(int left, int right); + static int IIncrementOperators<int>.operator checked ++(int value); + static int IIncrementOperators<int>.operator ++(int value); + static int IModulusOperators<int, int, int>.operator %(int left, int right); + static int IMultiplyOperators<int, int, int>.operator checked *(int left, int right); + static int IMultiplyOperators<int, int, int>.operator *(int left, int right); + static int INumber<int>.MaxNumber(int x, int y); + static int INumber<int>.MinNumber(int x, int y); + static bool INumberBase<int>.IsCanonical(int value); + static bool INumberBase<int>.IsComplexNumber(int value); + static bool INumberBase<int>.IsFinite(int value); + static bool INumberBase<int>.IsImaginaryNumber(int value); + static bool INumberBase<int>.IsInfinity(int value); + static bool INumberBase<int>.IsInteger(int value); + static bool INumberBase<int>.IsNaN(int value); + static bool INumberBase<int>.IsNegativeInfinity(int value); + static bool INumberBase<int>.IsNormal(int value); + static bool INumberBase<int>.IsPositiveInfinity(int value); + static bool INumberBase<int>.IsRealNumber(int value); + static bool INumberBase<int>.IsSubnormal(int value); + static bool INumberBase<int>.IsZero(int value); + static int INumberBase<int>.MaxMagnitudeNumber(int x, int y); + static int INumberBase<int>.MinMagnitudeNumber(int x, int y); + static bool INumberBase<int>.TryConvertFromChecked<TOther>(TOther value, out int result); + static bool INumberBase<int>.TryConvertFromSaturating<TOther>(TOther value, out int result); + static bool INumberBase<int>.TryConvertFromTruncating<TOther>(TOther value, out int result); + static bool INumberBase<int>.TryConvertToChecked<TOther>(int value, out TOther result); + static bool INumberBase<int>.TryConvertToSaturating<TOther>(int value, out TOther result); + static bool INumberBase<int>.TryConvertToTruncating<TOther>(int value, out TOther result); + static int IShiftOperators<int, int, int>.operator <<(int value, int shiftAmount); + static int IShiftOperators<int, int, int>.operator >>(int value, int shiftAmount); + static int IShiftOperators<int, int, int>.operator >>>(int value, int shiftAmount); + static int ISubtractionOperators<int, int, int>.operator checked -(int left, int right); + static int ISubtractionOperators<int, int, int>.operator -(int left, int right); + static int IUnaryNegationOperators<int, int>.operator checked -(int value); + static int IUnaryNegationOperators<int, int>.operator -(int value); + static int IUnaryPlusOperators<int, int>.operator +(int value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static int TrailingZeroCount(int value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out int result); + public static bool TryParse(string? s, IFormatProvider? provider, out int result); } - public readonly struct Int64 : IComparable, IComparable<long>, IConvertible, IEquatable<long>, IFormattable, ISpanFormattable { + public readonly struct Int64 : IAdditionOperators<long, long, long>, IAdditiveIdentity<long, long>, IBinaryInteger<long>, IBinaryNumber<long>, IBitwiseOperators<long, long, long>, IComparable, IComparable<long>, IComparisonOperators<long, long, bool>, IConvertible, IDecrementOperators<long>, IDivisionOperators<long, long, long>, IEqualityOperators<long, long, bool>, IEquatable<long>, IFormattable, IIncrementOperators<long>, IMinMaxValue<long>, IModulusOperators<long, long, long>, IMultiplicativeIdentity<long, long>, IMultiplyOperators<long, long, long>, INumber<long>, INumberBase<long>, IParsable<long>, IShiftOperators<long, int, long>, ISignedNumber<long>, ISpanFormattable, ISpanParsable<long>, ISubtractionOperators<long, long, long>, IUnaryNegationOperators<long, long>, IUnaryPlusOperators<long, long> { + static long System.Numerics.IAdditiveIdentity<System.Int64,System.Int64>.AdditiveIdentity { get; } + static long System.Numerics.IBinaryNumber<System.Int64>.AllBitsSet { get; } + static long System.Numerics.IMinMaxValue<System.Int64>.MaxValue { get; } + static long System.Numerics.IMinMaxValue<System.Int64>.MinValue { get; } + static long System.Numerics.IMultiplicativeIdentity<System.Int64,System.Int64>.MultiplicativeIdentity { get; } + static long System.Numerics.INumberBase<System.Int64>.One { get; } + static int System.Numerics.INumberBase<System.Int64>.Radix { get; } + static long System.Numerics.INumberBase<System.Int64>.Zero { get; } + static long System.Numerics.ISignedNumber<System.Int64>.NegativeOne { get; } + public static long Abs(long value); + public static long Clamp(long value, long min, long max); + public static long CopySign(long value, long sign); + public static long CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static long CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static long CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (long Quotient, long Remainder) DivRem(long left, long right); + public static bool IsEvenInteger(long value); + public static bool IsNegative(long value); + public static bool IsOddInteger(long value); + public static bool IsPositive(long value); + public static bool IsPow2(long value); + public static long LeadingZeroCount(long value); + public static long Log2(long value); + public static long Max(long x, long y); + public static long MaxMagnitude(long x, long y); + public static long Min(long x, long y); + public static long MinMagnitude(long x, long y); + public static long Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static long PopCount(long value); + public static long RotateLeft(long value, int rotateAmount); + public static long RotateRight(long value, int rotateAmount); + public static int Sign(long value); + static long IAdditionOperators<long, long, long>.operator +(long left, long right); + static long IAdditionOperators<long, long, long>.operator checked +(long left, long right); + int IBinaryInteger<long>.GetByteCount(); + int IBinaryInteger<long>.GetShortestBitLength(); + static bool IBinaryInteger<long>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out long value); + static bool IBinaryInteger<long>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out long value); + bool IBinaryInteger<long>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<long>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static long IBitwiseOperators<long, long, long>.operator &(long left, long right); + static long IBitwiseOperators<long, long, long>.operator |(long left, long right); + static long IBitwiseOperators<long, long, long>.operator ^(long left, long right); + static long IBitwiseOperators<long, long, long>.operator ~(long value); + static bool IComparisonOperators<long, long, bool>.operator >(long left, long right); + static bool IComparisonOperators<long, long, bool>.operator >=(long left, long right); + static bool IComparisonOperators<long, long, bool>.operator <(long left, long right); + static bool IComparisonOperators<long, long, bool>.operator <=(long left, long right); + static long IDecrementOperators<long>.operator checked --(long value); + static long IDecrementOperators<long>.operator --(long value); + static long IDivisionOperators<long, long, long>.operator /(long left, long right); + static bool IEqualityOperators<long, long, bool>.operator ==(long left, long right); + static bool IEqualityOperators<long, long, bool>.operator !=(long left, long right); + static long IIncrementOperators<long>.operator checked ++(long value); + static long IIncrementOperators<long>.operator ++(long value); + static long IModulusOperators<long, long, long>.operator %(long left, long right); + static long IMultiplyOperators<long, long, long>.operator checked *(long left, long right); + static long IMultiplyOperators<long, long, long>.operator *(long left, long right); + static long INumber<long>.MaxNumber(long x, long y); + static long INumber<long>.MinNumber(long x, long y); + static bool INumberBase<long>.IsCanonical(long value); + static bool INumberBase<long>.IsComplexNumber(long value); + static bool INumberBase<long>.IsFinite(long value); + static bool INumberBase<long>.IsImaginaryNumber(long value); + static bool INumberBase<long>.IsInfinity(long value); + static bool INumberBase<long>.IsInteger(long value); + static bool INumberBase<long>.IsNaN(long value); + static bool INumberBase<long>.IsNegativeInfinity(long value); + static bool INumberBase<long>.IsNormal(long value); + static bool INumberBase<long>.IsPositiveInfinity(long value); + static bool INumberBase<long>.IsRealNumber(long value); + static bool INumberBase<long>.IsSubnormal(long value); + static bool INumberBase<long>.IsZero(long value); + static long INumberBase<long>.MaxMagnitudeNumber(long x, long y); + static long INumberBase<long>.MinMagnitudeNumber(long x, long y); + static bool INumberBase<long>.TryConvertFromChecked<TOther>(TOther value, out long result); + static bool INumberBase<long>.TryConvertFromSaturating<TOther>(TOther value, out long result); + static bool INumberBase<long>.TryConvertFromTruncating<TOther>(TOther value, out long result); + static bool INumberBase<long>.TryConvertToChecked<TOther>(long value, out TOther result); + static bool INumberBase<long>.TryConvertToSaturating<TOther>(long value, out TOther result); + static bool INumberBase<long>.TryConvertToTruncating<TOther>(long value, out TOther result); + static long IShiftOperators<long, int, long>.operator <<(long value, int shiftAmount); + static long IShiftOperators<long, int, long>.operator >>(long value, int shiftAmount); + static long IShiftOperators<long, int, long>.operator >>>(long value, int shiftAmount); + static long ISubtractionOperators<long, long, long>.operator checked -(long left, long right); + static long ISubtractionOperators<long, long, long>.operator -(long left, long right); + static long IUnaryNegationOperators<long, long>.operator checked -(long value); + static long IUnaryNegationOperators<long, long>.operator -(long value); + static long IUnaryPlusOperators<long, long>.operator +(long value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static long TrailingZeroCount(long value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out long result); + public static bool TryParse(string? s, IFormatProvider? provider, out long result); } - public readonly struct IntPtr : IComparable, IComparable<IntPtr>, IEquatable<IntPtr>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct IntPtr : IAdditionOperators<IntPtr, IntPtr, IntPtr>, IAdditiveIdentity<IntPtr, IntPtr>, IBinaryInteger<IntPtr>, IBinaryNumber<IntPtr>, IBitwiseOperators<IntPtr, IntPtr, IntPtr>, IComparable, IComparable<IntPtr>, IComparisonOperators<IntPtr, IntPtr, bool>, IDecrementOperators<IntPtr>, IDivisionOperators<IntPtr, IntPtr, IntPtr>, IEqualityOperators<IntPtr, IntPtr, bool>, IEquatable<IntPtr>, IFormattable, IIncrementOperators<IntPtr>, IMinMaxValue<IntPtr>, IModulusOperators<IntPtr, IntPtr, IntPtr>, IMultiplicativeIdentity<IntPtr, IntPtr>, IMultiplyOperators<IntPtr, IntPtr, IntPtr>, INumber<IntPtr>, INumberBase<IntPtr>, IParsable<IntPtr>, ISerializable, IShiftOperators<IntPtr, int, IntPtr>, ISignedNumber<IntPtr>, ISpanFormattable, ISpanParsable<IntPtr>, ISubtractionOperators<IntPtr, IntPtr, IntPtr>, IUnaryNegationOperators<IntPtr, IntPtr>, IUnaryPlusOperators<IntPtr, IntPtr> { + static IntPtr System.Numerics.IAdditiveIdentity<nint,nint>.AdditiveIdentity { get; } + static IntPtr System.Numerics.IBinaryNumber<nint>.AllBitsSet { get; } + static IntPtr System.Numerics.IMinMaxValue<nint>.MaxValue { get; } + static IntPtr System.Numerics.IMinMaxValue<nint>.MinValue { get; } + static IntPtr System.Numerics.IMultiplicativeIdentity<nint,nint>.MultiplicativeIdentity { get; } + static IntPtr System.Numerics.INumberBase<nint>.One { get; } + static int System.Numerics.INumberBase<nint>.Radix { get; } + static IntPtr System.Numerics.INumberBase<nint>.Zero { get; } + static IntPtr System.Numerics.ISignedNumber<nint>.NegativeOne { get; } + public static IntPtr Abs(IntPtr value); + public static IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max); + public static IntPtr CopySign(IntPtr value, IntPtr sign); + public static IntPtr CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static IntPtr CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static IntPtr CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (IntPtr Quotient, IntPtr Remainder) DivRem(IntPtr left, IntPtr right); + public static bool IsEvenInteger(IntPtr value); + public static bool IsNegative(IntPtr value); + public static bool IsOddInteger(IntPtr value); + public static bool IsPositive(IntPtr value); + public static bool IsPow2(IntPtr value); + public static IntPtr LeadingZeroCount(IntPtr value); + public static IntPtr Log2(IntPtr value); + public static IntPtr Max(IntPtr x, IntPtr y); + public static IntPtr MaxMagnitude(IntPtr x, IntPtr y); + public static IntPtr Min(IntPtr x, IntPtr y); + public static IntPtr MinMagnitude(IntPtr x, IntPtr y); + public static IntPtr Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static IntPtr PopCount(IntPtr value); + public static IntPtr RotateLeft(IntPtr value, int rotateAmount); + public static IntPtr RotateRight(IntPtr value, int rotateAmount); + public static int Sign(IntPtr value); + static IntPtr IAdditionOperators<IntPtr, IntPtr, IntPtr>.operator +(IntPtr left, IntPtr right); + static IntPtr IAdditionOperators<IntPtr, IntPtr, IntPtr>.operator checked +(IntPtr left, IntPtr right); + int IBinaryInteger<IntPtr>.GetByteCount(); + int IBinaryInteger<IntPtr>.GetShortestBitLength(); + static bool IBinaryInteger<IntPtr>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out IntPtr value); + static bool IBinaryInteger<IntPtr>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out IntPtr value); + bool IBinaryInteger<IntPtr>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<IntPtr>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator &(IntPtr left, IntPtr right); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator |(IntPtr left, IntPtr right); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator ^(IntPtr left, IntPtr right); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator ~(IntPtr value); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator >(IntPtr left, IntPtr right); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator >=(IntPtr left, IntPtr right); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator <(IntPtr left, IntPtr right); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator <=(IntPtr left, IntPtr right); + static IntPtr IDecrementOperators<IntPtr>.operator checked --(IntPtr value); + static IntPtr IDecrementOperators<IntPtr>.operator --(IntPtr value); + static IntPtr IDivisionOperators<IntPtr, IntPtr, IntPtr>.operator /(IntPtr left, IntPtr right); + static IntPtr IIncrementOperators<IntPtr>.operator checked ++(IntPtr value); + static IntPtr IIncrementOperators<IntPtr>.operator ++(IntPtr value); + static IntPtr IModulusOperators<IntPtr, IntPtr, IntPtr>.operator %(IntPtr left, IntPtr right); + static IntPtr IMultiplyOperators<IntPtr, IntPtr, IntPtr>.operator checked *(IntPtr left, IntPtr right); + static IntPtr IMultiplyOperators<IntPtr, IntPtr, IntPtr>.operator *(IntPtr left, IntPtr right); + static IntPtr INumber<IntPtr>.MaxNumber(IntPtr x, IntPtr y); + static IntPtr INumber<IntPtr>.MinNumber(IntPtr x, IntPtr y); + static bool INumberBase<IntPtr>.IsCanonical(IntPtr value); + static bool INumberBase<IntPtr>.IsComplexNumber(IntPtr value); + static bool INumberBase<IntPtr>.IsFinite(IntPtr value); + static bool INumberBase<IntPtr>.IsImaginaryNumber(IntPtr value); + static bool INumberBase<IntPtr>.IsInfinity(IntPtr value); + static bool INumberBase<IntPtr>.IsInteger(IntPtr value); + static bool INumberBase<IntPtr>.IsNaN(IntPtr value); + static bool INumberBase<IntPtr>.IsNegativeInfinity(IntPtr value); + static bool INumberBase<IntPtr>.IsNormal(IntPtr value); + static bool INumberBase<IntPtr>.IsPositiveInfinity(IntPtr value); + static bool INumberBase<IntPtr>.IsRealNumber(IntPtr value); + static bool INumberBase<IntPtr>.IsSubnormal(IntPtr value); + static bool INumberBase<IntPtr>.IsZero(IntPtr value); + static IntPtr INumberBase<IntPtr>.MaxMagnitudeNumber(IntPtr x, IntPtr y); + static IntPtr INumberBase<IntPtr>.MinMagnitudeNumber(IntPtr x, IntPtr y); + static bool INumberBase<IntPtr>.TryConvertFromChecked<TOther>(TOther value, out IntPtr result); + static bool INumberBase<IntPtr>.TryConvertFromSaturating<TOther>(TOther value, out IntPtr result); + static bool INumberBase<IntPtr>.TryConvertFromTruncating<TOther>(TOther value, out IntPtr result); + static bool INumberBase<IntPtr>.TryConvertToChecked<TOther>(IntPtr value, out TOther result); + static bool INumberBase<IntPtr>.TryConvertToSaturating<TOther>(IntPtr value, out TOther result); + static bool INumberBase<IntPtr>.TryConvertToTruncating<TOther>(IntPtr value, out TOther result); + static IntPtr IShiftOperators<IntPtr, int, IntPtr>.operator <<(IntPtr value, int shiftAmount); + static IntPtr IShiftOperators<IntPtr, int, IntPtr>.operator >>(IntPtr value, int shiftAmount); + static IntPtr IShiftOperators<IntPtr, int, IntPtr>.operator >>>(IntPtr value, int shiftAmount); + static IntPtr ISubtractionOperators<IntPtr, IntPtr, IntPtr>.operator checked -(IntPtr left, IntPtr right); + static IntPtr ISubtractionOperators<IntPtr, IntPtr, IntPtr>.operator -(IntPtr left, IntPtr right); + static IntPtr IUnaryNegationOperators<IntPtr, IntPtr>.operator checked -(IntPtr value); + static IntPtr IUnaryNegationOperators<IntPtr, IntPtr>.operator -(IntPtr value); + static IntPtr IUnaryPlusOperators<IntPtr, IntPtr>.operator +(IntPtr value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static IntPtr TrailingZeroCount(IntPtr value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out IntPtr result); + public static bool TryParse(string? s, IFormatProvider? provider, out IntPtr result); } + public interface IParsable<TSelf> where TSelf : IParsable<TSelf>? { + static abstract TSelf Parse(string s, IFormatProvider? provider); + static abstract bool TryParse(string? s, IFormatProvider? provider, out TSelf result); + } + public interface ISpanParsable<TSelf> : IParsable<TSelf> where TSelf : ISpanParsable<TSelf>? { + static abstract TSelf Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + static abstract bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TSelf result); + } public static class MemoryExtensions { + public static int CommonPrefixLength<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other); + public static int CommonPrefixLength<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other, IEqualityComparer<T>? comparer); + public static int CommonPrefixLength<T>(this Span<T> span, ReadOnlySpan<T> other); + public static int CommonPrefixLength<T>(this Span<T> span, ReadOnlySpan<T> other, IEqualityComparer<T>? comparer); - public static bool Contains<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>; + public static bool Contains<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; - public static bool Contains<T>(this Span<T> span, T value) where T : IEquatable<T>; + public static bool Contains<T>(this Span<T> span, T value) where T : IEquatable<T>?; - public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>; + public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; - public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>; + public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>; + public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>; + public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, T value) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; - public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T?>; - public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int SequenceCompareTo<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IComparable<T>; + public static int SequenceCompareTo<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IComparable<T>?; - public static int SequenceCompareTo<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IComparable<T>; + public static int SequenceCompareTo<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IComparable<T>?; - public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>; + public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>?; - public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>; + public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>?; - public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static Memory<T> Trim<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Memory<T> Trim<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Memory<T> Trim<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>; + public static Memory<T> Trim<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>; + public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>; + public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>?; - public static Span<T> Trim<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Span<T> Trim<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Span<T> Trim<T>(this Span<T> span, T trimElement) where T : IEquatable<T>; + public static Span<T> Trim<T>(this Span<T> span, T trimElement) where T : IEquatable<T>?; - public static Memory<T> TrimEnd<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Memory<T> TrimEnd<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Memory<T> TrimEnd<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>; + public static Memory<T> TrimEnd<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>?; - public static Span<T> TrimEnd<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Span<T> TrimEnd<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Span<T> TrimEnd<T>(this Span<T> span, T trimElement) where T : IEquatable<T>; + public static Span<T> TrimEnd<T>(this Span<T> span, T trimElement) where T : IEquatable<T>?; - public static Memory<T> TrimStart<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Memory<T> TrimStart<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Memory<T> TrimStart<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>; + public static Memory<T> TrimStart<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>?; - public static Span<T> TrimStart<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Span<T> TrimStart<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Span<T> TrimStart<T>(this Span<T> span, T trimElement) where T : IEquatable<T>; + public static Span<T> TrimStart<T>(this Span<T> span, T trimElement) where T : IEquatable<T>?; } - public struct ModuleHandle + public struct ModuleHandle : IEquatable<ModuleHandle> public static class Nullable { + public static ref readonly T GetValueRefOrDefaultRef<T>(in T? nullable) where T : struct; } public class ObjectDisposedException : InvalidOperationException { + public static void ThrowIf(bool condition, object instance); + public static void ThrowIf(bool condition, Type type); } public readonly ref struct ReadOnlySpan<T> { + public ReadOnlySpan(in T reference); } - public struct RuntimeFieldHandle : ISerializable { + public struct RuntimeFieldHandle : IEquatable<RuntimeFieldHandle>, ISerializable { + public static RuntimeFieldHandle FromIntPtr(IntPtr value); + public static IntPtr ToIntPtr(RuntimeFieldHandle value); } - public struct RuntimeMethodHandle : ISerializable { + public struct RuntimeMethodHandle : IEquatable<RuntimeMethodHandle>, ISerializable { + public static RuntimeMethodHandle FromIntPtr(IntPtr value); + public static IntPtr ToIntPtr(RuntimeMethodHandle value); } - public struct RuntimeTypeHandle : ISerializable { + public struct RuntimeTypeHandle : IEquatable<RuntimeTypeHandle>, ISerializable { + public static RuntimeTypeHandle FromIntPtr(IntPtr value); + public static IntPtr ToIntPtr(RuntimeTypeHandle value); } - public readonly struct SByte : IComparable, IComparable<sbyte>, IConvertible, IEquatable<sbyte>, IFormattable, ISpanFormattable { + public readonly struct SByte : IAdditionOperators<sbyte, sbyte, sbyte>, IAdditiveIdentity<sbyte, sbyte>, IBinaryInteger<sbyte>, IBinaryNumber<sbyte>, IBitwiseOperators<sbyte, sbyte, sbyte>, IComparable, IComparable<sbyte>, IComparisonOperators<sbyte, sbyte, bool>, IConvertible, IDecrementOperators<sbyte>, IDivisionOperators<sbyte, sbyte, sbyte>, IEqualityOperators<sbyte, sbyte, bool>, IEquatable<sbyte>, IFormattable, IIncrementOperators<sbyte>, IMinMaxValue<sbyte>, IModulusOperators<sbyte, sbyte, sbyte>, IMultiplicativeIdentity<sbyte, sbyte>, IMultiplyOperators<sbyte, sbyte, sbyte>, INumber<sbyte>, INumberBase<sbyte>, IParsable<sbyte>, IShiftOperators<sbyte, int, sbyte>, ISignedNumber<sbyte>, ISpanFormattable, ISpanParsable<sbyte>, ISubtractionOperators<sbyte, sbyte, sbyte>, IUnaryNegationOperators<sbyte, sbyte>, IUnaryPlusOperators<sbyte, sbyte> { + static sbyte System.Numerics.IAdditiveIdentity<System.SByte,System.SByte>.AdditiveIdentity { get; } + static sbyte System.Numerics.IBinaryNumber<System.SByte>.AllBitsSet { get; } + static sbyte System.Numerics.IMinMaxValue<System.SByte>.MaxValue { get; } + static sbyte System.Numerics.IMinMaxValue<System.SByte>.MinValue { get; } + static sbyte System.Numerics.IMultiplicativeIdentity<System.SByte,System.SByte>.MultiplicativeIdentity { get; } + static sbyte System.Numerics.INumberBase<System.SByte>.One { get; } + static int System.Numerics.INumberBase<System.SByte>.Radix { get; } + static sbyte System.Numerics.INumberBase<System.SByte>.Zero { get; } + static sbyte System.Numerics.ISignedNumber<System.SByte>.NegativeOne { get; } + public static sbyte Abs(sbyte value); + public static sbyte Clamp(sbyte value, sbyte min, sbyte max); + public static sbyte CopySign(sbyte value, sbyte sign); + public static sbyte CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static sbyte CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static sbyte CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (sbyte Quotient, sbyte Remainder) DivRem(sbyte left, sbyte right); + public static bool IsEvenInteger(sbyte value); + public static bool IsNegative(sbyte value); + public static bool IsOddInteger(sbyte value); + public static bool IsPositive(sbyte value); + public static bool IsPow2(sbyte value); + public static sbyte LeadingZeroCount(sbyte value); + public static sbyte Log2(sbyte value); + public static sbyte Max(sbyte x, sbyte y); + public static sbyte MaxMagnitude(sbyte x, sbyte y); + public static sbyte Min(sbyte x, sbyte y); + public static sbyte MinMagnitude(sbyte x, sbyte y); + public static sbyte Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static sbyte PopCount(sbyte value); + public static sbyte RotateLeft(sbyte value, int rotateAmount); + public static sbyte RotateRight(sbyte value, int rotateAmount); + public static int Sign(sbyte value); + static sbyte IAdditionOperators<sbyte, sbyte, sbyte>.operator +(sbyte left, sbyte right); + static sbyte IAdditionOperators<sbyte, sbyte, sbyte>.operator checked +(sbyte left, sbyte right); + int IBinaryInteger<sbyte>.GetByteCount(); + int IBinaryInteger<sbyte>.GetShortestBitLength(); + static bool IBinaryInteger<sbyte>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out sbyte value); + static bool IBinaryInteger<sbyte>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out sbyte value); + bool IBinaryInteger<sbyte>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<sbyte>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator &(sbyte left, sbyte right); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator |(sbyte left, sbyte right); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator ^(sbyte left, sbyte right); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator ~(sbyte value); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator >(sbyte left, sbyte right); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator >=(sbyte left, sbyte right); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator <(sbyte left, sbyte right); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator <=(sbyte left, sbyte right); + static sbyte IDecrementOperators<sbyte>.operator checked --(sbyte value); + static sbyte IDecrementOperators<sbyte>.operator --(sbyte value); + static sbyte IDivisionOperators<sbyte, sbyte, sbyte>.operator /(sbyte left, sbyte right); + static bool IEqualityOperators<sbyte, sbyte, bool>.operator ==(sbyte left, sbyte right); + static bool IEqualityOperators<sbyte, sbyte, bool>.operator !=(sbyte left, sbyte right); + static sbyte IIncrementOperators<sbyte>.operator checked ++(sbyte value); + static sbyte IIncrementOperators<sbyte>.operator ++(sbyte value); + static sbyte IModulusOperators<sbyte, sbyte, sbyte>.operator %(sbyte left, sbyte right); + static sbyte IMultiplyOperators<sbyte, sbyte, sbyte>.operator checked *(sbyte left, sbyte right); + static sbyte IMultiplyOperators<sbyte, sbyte, sbyte>.operator *(sbyte left, sbyte right); + static sbyte INumber<sbyte>.MaxNumber(sbyte x, sbyte y); + static sbyte INumber<sbyte>.MinNumber(sbyte x, sbyte y); + static bool INumberBase<sbyte>.IsCanonical(sbyte value); + static bool INumberBase<sbyte>.IsComplexNumber(sbyte value); + static bool INumberBase<sbyte>.IsFinite(sbyte value); + static bool INumberBase<sbyte>.IsImaginaryNumber(sbyte value); + static bool INumberBase<sbyte>.IsInfinity(sbyte value); + static bool INumberBase<sbyte>.IsInteger(sbyte value); + static bool INumberBase<sbyte>.IsNaN(sbyte value); + static bool INumberBase<sbyte>.IsNegativeInfinity(sbyte value); + static bool INumberBase<sbyte>.IsNormal(sbyte value); + static bool INumberBase<sbyte>.IsPositiveInfinity(sbyte value); + static bool INumberBase<sbyte>.IsRealNumber(sbyte value); + static bool INumberBase<sbyte>.IsSubnormal(sbyte value); + static bool INumberBase<sbyte>.IsZero(sbyte value); + static sbyte INumberBase<sbyte>.MaxMagnitudeNumber(sbyte x, sbyte y); + static sbyte INumberBase<sbyte>.MinMagnitudeNumber(sbyte x, sbyte y); + static bool INumberBase<sbyte>.TryConvertFromChecked<TOther>(TOther value, out sbyte result); + static bool INumberBase<sbyte>.TryConvertFromSaturating<TOther>(TOther value, out sbyte result); + static bool INumberBase<sbyte>.TryConvertFromTruncating<TOther>(TOther value, out sbyte result); + static bool INumberBase<sbyte>.TryConvertToChecked<TOther>(sbyte value, out TOther result); + static bool INumberBase<sbyte>.TryConvertToSaturating<TOther>(sbyte value, out TOther result); + static bool INumberBase<sbyte>.TryConvertToTruncating<TOther>(sbyte value, out TOther result); + static sbyte IShiftOperators<sbyte, int, sbyte>.operator <<(sbyte value, int shiftAmount); + static sbyte IShiftOperators<sbyte, int, sbyte>.operator >>(sbyte value, int shiftAmount); + static sbyte IShiftOperators<sbyte, int, sbyte>.operator >>>(sbyte value, int shiftAmount); + static sbyte ISubtractionOperators<sbyte, sbyte, sbyte>.operator checked -(sbyte left, sbyte right); + static sbyte ISubtractionOperators<sbyte, sbyte, sbyte>.operator -(sbyte left, sbyte right); + static sbyte IUnaryNegationOperators<sbyte, sbyte>.operator checked -(sbyte value); + static sbyte IUnaryNegationOperators<sbyte, sbyte>.operator -(sbyte value); + static sbyte IUnaryPlusOperators<sbyte, sbyte>.operator +(sbyte value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static sbyte TrailingZeroCount(sbyte value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out sbyte result); + public static bool TryParse(string? s, IFormatProvider? provider, out sbyte result); } - public readonly struct Single : IComparable, IComparable<float>, IConvertible, IEquatable<float>, IFormattable, ISpanFormattable { + public readonly struct Single : IAdditionOperators<float, float, float>, IAdditiveIdentity<float, float>, IBinaryFloatingPointIeee754<float>, IBinaryNumber<float>, IBitwiseOperators<float, float, float>, IComparable, IComparable<float>, IComparisonOperators<float, float, bool>, IConvertible, IDecrementOperators<float>, IDivisionOperators<float, float, float>, IEqualityOperators<float, float, bool>, IEquatable<float>, IExponentialFunctions<float>, IFloatingPoint<float>, IFloatingPointConstants<float>, IFloatingPointIeee754<float>, IFormattable, IHyperbolicFunctions<float>, IIncrementOperators<float>, ILogarithmicFunctions<float>, IMinMaxValue<float>, IModulusOperators<float, float, float>, IMultiplicativeIdentity<float, float>, IMultiplyOperators<float, float, float>, INumber<float>, INumberBase<float>, IParsable<float>, IPowerFunctions<float>, IRootFunctions<float>, ISignedNumber<float>, ISpanFormattable, ISpanParsable<float>, ISubtractionOperators<float, float, float>, ITrigonometricFunctions<float>, IUnaryNegationOperators<float, float>, IUnaryPlusOperators<float, float> { + public const float E = 2.7182817f; + public const float NegativeZero = -0f; + public const float Pi = 3.1415927f; + public const float Tau = 6.2831855f; + static float System.Numerics.IAdditiveIdentity<System.Single,System.Single>.AdditiveIdentity { get; } + static float System.Numerics.IBinaryNumber<System.Single>.AllBitsSet { get; } + static float System.Numerics.IFloatingPointConstants<System.Single>.E { get; } + static float System.Numerics.IFloatingPointConstants<System.Single>.Pi { get; } + static float System.Numerics.IFloatingPointConstants<System.Single>.Tau { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.Epsilon { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.NaN { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeInfinity { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeZero { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.PositiveInfinity { get; } + static float System.Numerics.IMinMaxValue<System.Single>.MaxValue { get; } + static float System.Numerics.IMinMaxValue<System.Single>.MinValue { get; } + static float System.Numerics.IMultiplicativeIdentity<System.Single,System.Single>.MultiplicativeIdentity { get; } + static float System.Numerics.INumberBase<System.Single>.One { get; } + static int System.Numerics.INumberBase<System.Single>.Radix { get; } + static float System.Numerics.INumberBase<System.Single>.Zero { get; } + static float System.Numerics.ISignedNumber<System.Single>.NegativeOne { get; } + public static float Abs(float value); + public static float Acos(float x); + public static float Acosh(float x); + public static float AcosPi(float x); + public static float Asin(float x); + public static float Asinh(float x); + public static float AsinPi(float x); + public static float Atan(float x); + public static float Atan2(float y, float x); + public static float Atan2Pi(float y, float x); + public static float Atanh(float x); + public static float AtanPi(float x); + public static float BitDecrement(float x); + public static float BitIncrement(float x); + public static float Cbrt(float x); + public static float Ceiling(float x); + public static float Clamp(float value, float min, float max); + public static float CopySign(float value, float sign); + public static float Cos(float x); + public static float Cosh(float x); + public static float CosPi(float x); + public static float CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static float CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static float CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static float Exp(float x); + public static float Exp10(float x); + public static float Exp10M1(float x); + public static float Exp2(float x); + public static float Exp2M1(float x); + public static float ExpM1(float x); + public static float Floor(float x); + public static float FusedMultiplyAdd(float left, float right, float addend); + public static float Hypot(float x, float y); + public static float Ieee754Remainder(float left, float right); + public static int ILogB(float x); + public static bool IsEvenInteger(float value); + public static bool IsInteger(float value); + public static bool IsOddInteger(float value); + public static bool IsPositive(float value); + public static bool IsPow2(float value); + public static bool IsRealNumber(float value); + public static float Log(float x); + public static float Log(float x, float newBase); + public static float Log10(float x); + public static float Log10P1(float x); + public static float Log2(float value); + public static float Log2P1(float x); + public static float LogP1(float x); + public static float Max(float x, float y); + public static float MaxMagnitude(float x, float y); + public static float MaxMagnitudeNumber(float x, float y); + public static float MaxNumber(float x, float y); + public static float Min(float x, float y); + public static float MinMagnitude(float x, float y); + public static float MinMagnitudeNumber(float x, float y); + public static float MinNumber(float x, float y); + public static float Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static float Pow(float x, float y); + public static float ReciprocalEstimate(float x); + public static float ReciprocalSqrtEstimate(float x); + public static float RootN(float x, int n); + public static float Round(float x); + public static float Round(float x, int digits); + public static float Round(float x, int digits, MidpointRounding mode); + public static float Round(float x, MidpointRounding mode); + public static float ScaleB(float x, int n); + public static int Sign(float value); + public static float Sin(float x); + public static (float Sin, float Cos) SinCos(float x); + public static (float SinPi, float CosPi) SinCosPi(float x); + public static float Sinh(float x); + public static float SinPi(float x); + public static float Sqrt(float x); + static float IAdditionOperators<float, float, float>.operator +(float left, float right); + static float IBitwiseOperators<float, float, float>.operator &(float left, float right); + static float IBitwiseOperators<float, float, float>.operator |(float left, float right); + static float IBitwiseOperators<float, float, float>.operator ^(float left, float right); + static float IBitwiseOperators<float, float, float>.operator ~(float value); + static float IDecrementOperators<float>.operator --(float value); + static float IDivisionOperators<float, float, float>.operator /(float left, float right); + int IFloatingPoint<float>.GetExponentByteCount(); + int IFloatingPoint<float>.GetExponentShortestBitLength(); + int IFloatingPoint<float>.GetSignificandBitLength(); + int IFloatingPoint<float>.GetSignificandByteCount(); + bool IFloatingPoint<float>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<float>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<float>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<float>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static float IIncrementOperators<float>.operator ++(float value); + static float IModulusOperators<float, float, float>.operator %(float left, float right); + static float IMultiplyOperators<float, float, float>.operator *(float left, float right); + static bool INumberBase<float>.IsCanonical(float value); + static bool INumberBase<float>.IsComplexNumber(float value); + static bool INumberBase<float>.IsImaginaryNumber(float value); + static bool INumberBase<float>.IsZero(float value); + static bool INumberBase<float>.TryConvertFromChecked<TOther>(TOther value, out float result); + static bool INumberBase<float>.TryConvertFromSaturating<TOther>(TOther value, out float result); + static bool INumberBase<float>.TryConvertFromTruncating<TOther>(TOther value, out float result); + static bool INumberBase<float>.TryConvertToChecked<TOther>(float value, out TOther result); + static bool INumberBase<float>.TryConvertToSaturating<TOther>(float value, out TOther result); + static bool INumberBase<float>.TryConvertToTruncating<TOther>(float value, out TOther result); + static float ISubtractionOperators<float, float, float>.operator -(float left, float right); + static float IUnaryNegationOperators<float, float>.operator -(float value); + static float IUnaryPlusOperators<float, float>.operator +(float value); + public static float Tan(float x); + public static float Tanh(float x); + public static float TanPi(float x); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static float Truncate(float x); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out float result); + public static bool TryParse(string? s, IFormatProvider? provider, out float result); } public readonly ref struct Span<T> { + public Span(ref T reference); } public sealed class String : ICloneable, IComparable, IComparable<string?>, IConvertible, IEnumerable, IEnumerable<char>, IEquatable<string?> { public static string Format(IFormatProvider? provider, string format, object? arg0); public static string Format(IFormatProvider? provider, string format, object? arg0, object? arg1); public static string Format(IFormatProvider? provider, string format, object? arg0, object? arg1, object? arg2); public static string Format(IFormatProvider? provider, string format, params object?[] args); public static string Format(string format, object? arg0); public static string Format(string format, object? arg0, object? arg1); public static string Format(string format, object? arg0, object? arg1, object? arg2); public static string Format(string format, params object?[] args); } - public readonly struct TimeOnly : IComparable, IComparable<TimeOnly>, IEquatable<TimeOnly>, IFormattable, ISpanFormattable { + public readonly struct TimeOnly : IComparable, IComparable<TimeOnly>, IEquatable<TimeOnly>, IFormattable, IParsable<TimeOnly>, ISpanFormattable, ISpanParsable<TimeOnly> { + public TimeOnly(int hour, int minute, int second, int millisecond, int microsecond); + public int Microsecond { get; } + public int Nanosecond { get; } + public static TimeOnly Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static TimeOnly Parse(string s, IFormatProvider? provider); public static TimeOnly ParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider = null, DateTimeStyles style = DateTimeStyles.None); public static TimeOnly ParseExact(ReadOnlySpan<char> s, string[] formats); public static TimeOnly ParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static TimeOnly ParseExact(string s, string format); public static TimeOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static TimeOnly ParseExact(string s, string[] formats); public static TimeOnly ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TimeOnly result); + public static bool TryParse(string? s, IFormatProvider? provider, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, out TimeOnly result); public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(string? s, string? format, out TimeOnly result); public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(string? s, string?[]? formats, out TimeOnly result); } - public readonly struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable, ISpanFormattable { + public readonly struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable, IParsable<TimeSpan>, ISpanFormattable, ISpanParsable<TimeSpan> { + public const long NanosecondsPerTick = (long)100; + public const long TicksPerMicrosecond = (long)10; + public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds, int microseconds); + public int Microseconds { get; } + public int Nanoseconds { get; } + public double TotalMicroseconds { get; } + public double TotalNanoseconds { get; } + public static TimeSpan FromMicroseconds(double value); public static TimeSpan ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, TimeSpanStyles styles = TimeSpanStyles.None); public static TimeSpan ParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider? formatProvider, TimeSpanStyles styles = TimeSpanStyles.None); public static TimeSpan ParseExact(string input, string format, IFormatProvider? formatProvider); public static TimeSpan ParseExact(string input, string format, IFormatProvider? formatProvider, TimeSpanStyles styles); public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider? formatProvider); public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider? formatProvider, TimeSpanStyles styles); public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? formatProvider = null); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, out TimeSpan result); public static bool TryParseExact(ReadOnlySpan<char> input, string?[]? formats, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(ReadOnlySpan<char> input, string?[]? formats, IFormatProvider? formatProvider, out TimeSpan result); public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, out TimeSpan result); public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, out TimeSpan result); } public sealed class TimeZoneInfo : IDeserializationCallback, IEquatable<TimeZoneInfo?>, ISerializable { public bool HasIanaId { get; } public sealed class AdjustmentRule : IDeserializationCallback, IEquatable<TimeZoneInfo.AdjustmentRule?>, ISerializable { + public override bool Equals(object? obj); } } public abstract class Type : MemberInfo, IReflect { public virtual Array GetEnumValues(); + public virtual Array GetEnumValuesAsUnderlyingType(); - public static Type GetTypeFromHandle(RuntimeTypeHandle handle); + public static Type? GetTypeFromHandle(RuntimeTypeHandle handle); public virtual Type MakeArrayType(); public virtual Type MakeArrayType(int rank); public virtual Type MakeGenericType(params Type[] typeArguments); } + public readonly struct UInt128 : IAdditionOperators<UInt128, UInt128, UInt128>, IAdditiveIdentity<UInt128, UInt128>, IBinaryInteger<UInt128>, IBinaryNumber<UInt128>, IBitwiseOperators<UInt128, UInt128, UInt128>, IComparable, IComparable<UInt128>, IComparisonOperators<UInt128, UInt128, bool>, IDecrementOperators<UInt128>, IDivisionOperators<UInt128, UInt128, UInt128>, IEqualityOperators<UInt128, UInt128, bool>, IEquatable<UInt128>, IFormattable, IIncrementOperators<UInt128>, IMinMaxValue<UInt128>, IModulusOperators<UInt128, UInt128, UInt128>, IMultiplicativeIdentity<UInt128, UInt128>, IMultiplyOperators<UInt128, UInt128, UInt128>, INumber<UInt128>, INumberBase<UInt128>, IParsable<UInt128>, IShiftOperators<UInt128, int, UInt128>, ISpanFormattable, ISpanParsable<UInt128>, ISubtractionOperators<UInt128, UInt128, UInt128>, IUnaryNegationOperators<UInt128, UInt128>, IUnaryPlusOperators<UInt128, UInt128>, IUnsignedNumber<UInt128> { + public UInt128(ulong upper, ulong lower); + public static UInt128 MaxValue { get; } + public static UInt128 MinValue { get; } + public static UInt128 One { get; } + static UInt128 System.Numerics.IAdditiveIdentity<System.UInt128,System.UInt128>.AdditiveIdentity { get; } + static UInt128 System.Numerics.IBinaryNumber<System.UInt128>.AllBitsSet { get; } + static UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128,System.UInt128>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.UInt128>.Radix { get; } + public static UInt128 Zero { get; } + public static UInt128 Clamp(UInt128 value, UInt128 min, UInt128 max); + public int CompareTo(object? value); + public int CompareTo(UInt128 value); + public static UInt128 CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UInt128 CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UInt128 CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (UInt128 Quotient, UInt128 Remainder) DivRem(UInt128 left, UInt128 right); + public override bool Equals(object? obj); + public bool Equals(UInt128 other); + public override int GetHashCode(); + public static bool IsEvenInteger(UInt128 value); + public static bool IsOddInteger(UInt128 value); + public static bool IsPow2(UInt128 value); + public static UInt128 LeadingZeroCount(UInt128 value); + public static UInt128 Log2(UInt128 value); + public static UInt128 Max(UInt128 x, UInt128 y); + public static UInt128 Min(UInt128 x, UInt128 y); + public static UInt128 operator +(UInt128 left, UInt128 right); + public static UInt128 operator &(UInt128 left, UInt128 right); + public static UInt128 operator |(UInt128 left, UInt128 right); + public static UInt128 operator checked +(UInt128 left, UInt128 right); + public static UInt128 operator checked --(UInt128 value); + public static UInt128 operator checked /(UInt128 left, UInt128 right); + public static explicit operator checked UInt128 (double value); + public static explicit operator checked UInt128 (short value); + public static explicit operator checked UInt128 (int value); + public static explicit operator checked UInt128 (long value); + public static explicit operator checked UInt128 (IntPtr value); + public static explicit operator checked UInt128 (sbyte value); + public static explicit operator checked UInt128 (float value); + public static explicit operator checked byte (UInt128 value); + public static explicit operator checked char (UInt128 value); + public static explicit operator checked short (UInt128 value); + public static explicit operator checked int (UInt128 value); + public static explicit operator checked long (UInt128 value); + public static explicit operator checked Int128 (UInt128 value); + public static explicit operator checked IntPtr (UInt128 value); + public static explicit operator checked sbyte (UInt128 value); + public static explicit operator checked ushort (UInt128 value); + public static explicit operator checked uint (UInt128 value); + public static explicit operator checked ulong (UInt128 value); + public static explicit operator checked UIntPtr (UInt128 value); + public static UInt128 operator checked ++(UInt128 value); + public static UInt128 operator checked *(UInt128 left, UInt128 right); + public static UInt128 operator checked -(UInt128 left, UInt128 right); + public static UInt128 operator checked -(UInt128 value); + public static UInt128 operator --(UInt128 value); + public static UInt128 operator /(UInt128 left, UInt128 right); + public static bool operator ==(UInt128 left, UInt128 right); + public static UInt128 operator ^(UInt128 left, UInt128 right); + public static explicit operator UInt128 (decimal value); + public static explicit operator UInt128 (double value); + public static explicit operator UInt128 (short value); + public static explicit operator UInt128 (int value); + public static explicit operator UInt128 (long value); + public static explicit operator UInt128 (IntPtr value); + public static explicit operator UInt128 (sbyte value); + public static explicit operator UInt128 (float value); + public static explicit operator byte (UInt128 value); + public static explicit operator char (UInt128 value); + public static explicit operator decimal (UInt128 value); + public static explicit operator double (UInt128 value); + public static explicit operator Half (UInt128 value); + public static explicit operator Int128 (UInt128 value); + public static explicit operator short (UInt128 value); + public static explicit operator int (UInt128 value); + public static explicit operator long (UInt128 value); + public static explicit operator IntPtr (UInt128 value); + public static explicit operator sbyte (UInt128 value); + public static explicit operator float (UInt128 value); + public static explicit operator ushort (UInt128 value); + public static explicit operator uint (UInt128 value); + public static explicit operator ulong (UInt128 value); + public static explicit operator UIntPtr (UInt128 value); + public static bool operator >(UInt128 left, UInt128 right); + public static bool operator >=(UInt128 left, UInt128 right); + public static implicit operator UInt128 (byte value); + public static implicit operator UInt128 (char value); + public static implicit operator UInt128 (ushort value); + public static implicit operator UInt128 (uint value); + public static implicit operator UInt128 (ulong value); + public static implicit operator UInt128 (UIntPtr value); + public static UInt128 operator ++(UInt128 value); + public static bool operator !=(UInt128 left, UInt128 right); + public static UInt128 operator <<(UInt128 value, int shiftAmount); + public static bool operator <(UInt128 left, UInt128 right); + public static bool operator <=(UInt128 left, UInt128 right); + public static UInt128 operator %(UInt128 left, UInt128 right); + public static UInt128 operator *(UInt128 left, UInt128 right); + public static UInt128 operator ~(UInt128 value); + public static UInt128 operator >>(UInt128 value, int shiftAmount); + public static UInt128 operator -(UInt128 left, UInt128 right); + public static UInt128 operator -(UInt128 value); + public static UInt128 operator +(UInt128 value); + public static UInt128 operator >>>(UInt128 value, int shiftAmount); + public static UInt128 Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null); + public static UInt128 Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static UInt128 Parse(string s); + public static UInt128 Parse(string s, NumberStyles style); + public static UInt128 Parse(string s, NumberStyles style, IFormatProvider? provider); + public static UInt128 Parse(string s, IFormatProvider? provider); + public static UInt128 PopCount(UInt128 value); + public static UInt128 RotateLeft(UInt128 value, int rotateAmount); + public static UInt128 RotateRight(UInt128 value, int rotateAmount); + public static int Sign(UInt128 value); + int IBinaryInteger<UInt128>.GetByteCount(); + int IBinaryInteger<UInt128>.GetShortestBitLength(); + static bool IBinaryInteger<UInt128>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UInt128 value); + static bool IBinaryInteger<UInt128>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UInt128 value); + bool IBinaryInteger<UInt128>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<UInt128>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static UInt128 INumber<UInt128>.CopySign(UInt128 value, UInt128 sign); + static UInt128 INumber<UInt128>.MaxNumber(UInt128 x, UInt128 y); + static UInt128 INumber<UInt128>.MinNumber(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.Abs(UInt128 value); + static bool INumberBase<UInt128>.IsCanonical(UInt128 value); + static bool INumberBase<UInt128>.IsComplexNumber(UInt128 value); + static bool INumberBase<UInt128>.IsFinite(UInt128 value); + static bool INumberBase<UInt128>.IsImaginaryNumber(UInt128 value); + static bool INumberBase<UInt128>.IsInfinity(UInt128 value); + static bool INumberBase<UInt128>.IsInteger(UInt128 value); + static bool INumberBase<UInt128>.IsNaN(UInt128 value); + static bool INumberBase<UInt128>.IsNegative(UInt128 value); + static bool INumberBase<UInt128>.IsNegativeInfinity(UInt128 value); + static bool INumberBase<UInt128>.IsNormal(UInt128 value); + static bool INumberBase<UInt128>.IsPositive(UInt128 value); + static bool INumberBase<UInt128>.IsPositiveInfinity(UInt128 value); + static bool INumberBase<UInt128>.IsRealNumber(UInt128 value); + static bool INumberBase<UInt128>.IsSubnormal(UInt128 value); + static bool INumberBase<UInt128>.IsZero(UInt128 value); + static UInt128 INumberBase<UInt128>.MaxMagnitude(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.MaxMagnitudeNumber(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.MinMagnitude(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.MinMagnitudeNumber(UInt128 x, UInt128 y); + static bool INumberBase<UInt128>.TryConvertFromChecked<TOther>(TOther value, out UInt128 result); + static bool INumberBase<UInt128>.TryConvertFromSaturating<TOther>(TOther value, out UInt128 result); + static bool INumberBase<UInt128>.TryConvertFromTruncating<TOther>(TOther value, out UInt128 result); + static bool INumberBase<UInt128>.TryConvertToChecked<TOther>(UInt128 value, out TOther result); + static bool INumberBase<UInt128>.TryConvertToSaturating<TOther>(UInt128 value, out TOther result); + static bool INumberBase<UInt128>.TryConvertToTruncating<TOther>(UInt128 value, out TOther result); + public override string ToString(); + public string ToString(IFormatProvider? provider); + public string ToString(string? format); + public string ToString(string? format, IFormatProvider? provider); + public static UInt128 TrailingZeroCount(UInt128 value); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(ReadOnlySpan<char> s, out UInt128 result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(string? s, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(string? s, out UInt128 result); + } - public readonly struct UInt16 : IComparable, IComparable<ushort>, IConvertible, IEquatable<ushort>, IFormattable, ISpanFormattable { + public readonly struct UInt16 : IAdditionOperators<ushort, ushort, ushort>, IAdditiveIdentity<ushort, ushort>, IBinaryInteger<ushort>, IBinaryNumber<ushort>, IBitwiseOperators<ushort, ushort, ushort>, IComparable, IComparable<ushort>, IComparisonOperators<ushort, ushort, bool>, IConvertible, IDecrementOperators<ushort>, IDivisionOperators<ushort, ushort, ushort>, IEqualityOperators<ushort, ushort, bool>, IEquatable<ushort>, IFormattable, IIncrementOperators<ushort>, IMinMaxValue<ushort>, IModulusOperators<ushort, ushort, ushort>, IMultiplicativeIdentity<ushort, ushort>, IMultiplyOperators<ushort, ushort, ushort>, INumber<ushort>, INumberBase<ushort>, IParsable<ushort>, IShiftOperators<ushort, int, ushort>, ISpanFormattable, ISpanParsable<ushort>, ISubtractionOperators<ushort, ushort, ushort>, IUnaryNegationOperators<ushort, ushort>, IUnaryPlusOperators<ushort, ushort>, IUnsignedNumber<ushort> { + static ushort System.Numerics.IAdditiveIdentity<System.UInt16,System.UInt16>.AdditiveIdentity { get; } + static ushort System.Numerics.IBinaryNumber<System.UInt16>.AllBitsSet { get; } + static ushort System.Numerics.IMinMaxValue<System.UInt16>.MaxValue { get; } + static ushort System.Numerics.IMinMaxValue<System.UInt16>.MinValue { get; } + static ushort System.Numerics.IMultiplicativeIdentity<System.UInt16,System.UInt16>.MultiplicativeIdentity { get; } + static ushort System.Numerics.INumberBase<System.UInt16>.One { get; } + static int System.Numerics.INumberBase<System.UInt16>.Radix { get; } + static ushort System.Numerics.INumberBase<System.UInt16>.Zero { get; } + public static ushort Clamp(ushort value, ushort min, ushort max); + public static ushort CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ushort CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ushort CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (ushort Quotient, ushort Remainder) DivRem(ushort left, ushort right); + public static bool IsEvenInteger(ushort value); + public static bool IsOddInteger(ushort value); + public static bool IsPow2(ushort value); + public static ushort LeadingZeroCount(ushort value); + public static ushort Log2(ushort value); + public static ushort Max(ushort x, ushort y); + public static ushort Min(ushort x, ushort y); + public static ushort Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static ushort PopCount(ushort value); + public static ushort RotateLeft(ushort value, int rotateAmount); + public static ushort RotateRight(ushort value, int rotateAmount); + public static int Sign(ushort value); + static ushort IAdditionOperators<ushort, ushort, ushort>.operator +(ushort left, ushort right); + static ushort IAdditionOperators<ushort, ushort, ushort>.operator checked +(ushort left, ushort right); + int IBinaryInteger<ushort>.GetByteCount(); + int IBinaryInteger<ushort>.GetShortestBitLength(); + static bool IBinaryInteger<ushort>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ushort value); + static bool IBinaryInteger<ushort>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ushort value); + bool IBinaryInteger<ushort>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<ushort>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator &(ushort left, ushort right); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator |(ushort left, ushort right); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator ^(ushort left, ushort right); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator ~(ushort value); + static bool IComparisonOperators<ushort, ushort, bool>.operator >(ushort left, ushort right); + static bool IComparisonOperators<ushort, ushort, bool>.operator >=(ushort left, ushort right); + static bool IComparisonOperators<ushort, ushort, bool>.operator <(ushort left, ushort right); + static bool IComparisonOperators<ushort, ushort, bool>.operator <=(ushort left, ushort right); + static ushort IDecrementOperators<ushort>.operator checked --(ushort value); + static ushort IDecrementOperators<ushort>.operator --(ushort value); + static ushort IDivisionOperators<ushort, ushort, ushort>.operator /(ushort left, ushort right); + static bool IEqualityOperators<ushort, ushort, bool>.operator ==(ushort left, ushort right); + static bool IEqualityOperators<ushort, ushort, bool>.operator !=(ushort left, ushort right); + static ushort IIncrementOperators<ushort>.operator checked ++(ushort value); + static ushort IIncrementOperators<ushort>.operator ++(ushort value); + static ushort IModulusOperators<ushort, ushort, ushort>.operator %(ushort left, ushort right); + static ushort IMultiplyOperators<ushort, ushort, ushort>.operator checked *(ushort left, ushort right); + static ushort IMultiplyOperators<ushort, ushort, ushort>.operator *(ushort left, ushort right); + static ushort INumber<ushort>.CopySign(ushort value, ushort sign); + static ushort INumber<ushort>.MaxNumber(ushort x, ushort y); + static ushort INumber<ushort>.MinNumber(ushort x, ushort y); + static ushort INumberBase<ushort>.Abs(ushort value); + static bool INumberBase<ushort>.IsCanonical(ushort value); + static bool INumberBase<ushort>.IsComplexNumber(ushort value); + static bool INumberBase<ushort>.IsFinite(ushort value); + static bool INumberBase<ushort>.IsImaginaryNumber(ushort value); + static bool INumberBase<ushort>.IsInfinity(ushort value); + static bool INumberBase<ushort>.IsInteger(ushort value); + static bool INumberBase<ushort>.IsNaN(ushort value); + static bool INumberBase<ushort>.IsNegative(ushort value); + static bool INumberBase<ushort>.IsNegativeInfinity(ushort value); + static bool INumberBase<ushort>.IsNormal(ushort value); + static bool INumberBase<ushort>.IsPositive(ushort value); + static bool INumberBase<ushort>.IsPositiveInfinity(ushort value); + static bool INumberBase<ushort>.IsRealNumber(ushort value); + static bool INumberBase<ushort>.IsSubnormal(ushort value); + static bool INumberBase<ushort>.IsZero(ushort value); + static ushort INumberBase<ushort>.MaxMagnitude(ushort x, ushort y); + static ushort INumberBase<ushort>.MaxMagnitudeNumber(ushort x, ushort y); + static ushort INumberBase<ushort>.MinMagnitude(ushort x, ushort y); + static ushort INumberBase<ushort>.MinMagnitudeNumber(ushort x, ushort y); + static bool INumberBase<ushort>.TryConvertFromChecked<TOther>(TOther value, out ushort result); + static bool INumberBase<ushort>.TryConvertFromSaturating<TOther>(TOther value, out ushort result); + static bool INumberBase<ushort>.TryConvertFromTruncating<TOther>(TOther value, out ushort result); + static bool INumberBase<ushort>.TryConvertToChecked<TOther>(ushort value, out TOther result); + static bool INumberBase<ushort>.TryConvertToSaturating<TOther>(ushort value, out TOther result); + static bool INumberBase<ushort>.TryConvertToTruncating<TOther>(ushort value, out TOther result); + static ushort IShiftOperators<ushort, int, ushort>.operator <<(ushort value, int shiftAmount); + static ushort IShiftOperators<ushort, int, ushort>.operator >>(ushort value, int shiftAmount); + static ushort IShiftOperators<ushort, int, ushort>.operator >>>(ushort value, int shiftAmount); + static ushort ISubtractionOperators<ushort, ushort, ushort>.operator checked -(ushort left, ushort right); + static ushort ISubtractionOperators<ushort, ushort, ushort>.operator -(ushort left, ushort right); + static ushort IUnaryNegationOperators<ushort, ushort>.operator checked -(ushort value); + static ushort IUnaryNegationOperators<ushort, ushort>.operator -(ushort value); + static ushort IUnaryPlusOperators<ushort, ushort>.operator +(ushort value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static ushort TrailingZeroCount(ushort value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out ushort result); + public static bool TryParse(string? s, IFormatProvider? provider, out ushort result); } - public readonly struct UInt32 : IComparable, IComparable<uint>, IConvertible, IEquatable<uint>, IFormattable, ISpanFormattable { + public readonly struct UInt32 : IAdditionOperators<uint, uint, uint>, IAdditiveIdentity<uint, uint>, IBinaryInteger<uint>, IBinaryNumber<uint>, IBitwiseOperators<uint, uint, uint>, IComparable, IComparable<uint>, IComparisonOperators<uint, uint, bool>, IConvertible, IDecrementOperators<uint>, IDivisionOperators<uint, uint, uint>, IEqualityOperators<uint, uint, bool>, IEquatable<uint>, IFormattable, IIncrementOperators<uint>, IMinMaxValue<uint>, IModulusOperators<uint, uint, uint>, IMultiplicativeIdentity<uint, uint>, IMultiplyOperators<uint, uint, uint>, INumber<uint>, INumberBase<uint>, IParsable<uint>, IShiftOperators<uint, int, uint>, ISpanFormattable, ISpanParsable<uint>, ISubtractionOperators<uint, uint, uint>, IUnaryNegationOperators<uint, uint>, IUnaryPlusOperators<uint, uint>, IUnsignedNumber<uint> { + static uint System.Numerics.IAdditiveIdentity<System.UInt32,System.UInt32>.AdditiveIdentity { get; } + static uint System.Numerics.IBinaryNumber<System.UInt32>.AllBitsSet { get; } + static uint System.Numerics.IMinMaxValue<System.UInt32>.MaxValue { get; } + static uint System.Numerics.IMinMaxValue<System.UInt32>.MinValue { get; } + static uint System.Numerics.IMultiplicativeIdentity<System.UInt32,System.UInt32>.MultiplicativeIdentity { get; } + static uint System.Numerics.INumberBase<System.UInt32>.One { get; } + static int System.Numerics.INumberBase<System.UInt32>.Radix { get; } + static uint System.Numerics.INumberBase<System.UInt32>.Zero { get; } + public static uint Clamp(uint value, uint min, uint max); + public static uint CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static uint CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static uint CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (uint Quotient, uint Remainder) DivRem(uint left, uint right); + public static bool IsEvenInteger(uint value); + public static bool IsOddInteger(uint value); + public static bool IsPow2(uint value); + public static uint LeadingZeroCount(uint value); + public static uint Log2(uint value); + public static uint Max(uint x, uint y); + public static uint Min(uint x, uint y); + public static uint Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static uint PopCount(uint value); + public static uint RotateLeft(uint value, int rotateAmount); + public static uint RotateRight(uint value, int rotateAmount); + public static int Sign(uint value); + static uint IAdditionOperators<uint, uint, uint>.operator +(uint left, uint right); + static uint IAdditionOperators<uint, uint, uint>.operator checked +(uint left, uint right); + int IBinaryInteger<uint>.GetByteCount(); + int IBinaryInteger<uint>.GetShortestBitLength(); + static bool IBinaryInteger<uint>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out uint value); + static bool IBinaryInteger<uint>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out uint value); + bool IBinaryInteger<uint>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<uint>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static uint IBitwiseOperators<uint, uint, uint>.operator &(uint left, uint right); + static uint IBitwiseOperators<uint, uint, uint>.operator |(uint left, uint right); + static uint IBitwiseOperators<uint, uint, uint>.operator ^(uint left, uint right); + static uint IBitwiseOperators<uint, uint, uint>.operator ~(uint value); + static bool IComparisonOperators<uint, uint, bool>.operator >(uint left, uint right); + static bool IComparisonOperators<uint, uint, bool>.operator >=(uint left, uint right); + static bool IComparisonOperators<uint, uint, bool>.operator <(uint left, uint right); + static bool IComparisonOperators<uint, uint, bool>.operator <=(uint left, uint right); + static uint IDecrementOperators<uint>.operator checked --(uint value); + static uint IDecrementOperators<uint>.operator --(uint value); + static uint IDivisionOperators<uint, uint, uint>.operator /(uint left, uint right); + static bool IEqualityOperators<uint, uint, bool>.operator ==(uint left, uint right); + static bool IEqualityOperators<uint, uint, bool>.operator !=(uint left, uint right); + static uint IIncrementOperators<uint>.operator checked ++(uint value); + static uint IIncrementOperators<uint>.operator ++(uint value); + static uint IModulusOperators<uint, uint, uint>.operator %(uint left, uint right); + static uint IMultiplyOperators<uint, uint, uint>.operator checked *(uint left, uint right); + static uint IMultiplyOperators<uint, uint, uint>.operator *(uint left, uint right); + static uint INumber<uint>.CopySign(uint value, uint sign); + static uint INumber<uint>.MaxNumber(uint x, uint y); + static uint INumber<uint>.MinNumber(uint x, uint y); + static uint INumberBase<uint>.Abs(uint value); + static bool INumberBase<uint>.IsCanonical(uint value); + static bool INumberBase<uint>.IsComplexNumber(uint value); + static bool INumberBase<uint>.IsFinite(uint value); + static bool INumberBase<uint>.IsImaginaryNumber(uint value); + static bool INumberBase<uint>.IsInfinity(uint value); + static bool INumberBase<uint>.IsInteger(uint value); + static bool INumberBase<uint>.IsNaN(uint value); + static bool INumberBase<uint>.IsNegative(uint value); + static bool INumberBase<uint>.IsNegativeInfinity(uint value); + static bool INumberBase<uint>.IsNormal(uint value); + static bool INumberBase<uint>.IsPositive(uint value); + static bool INumberBase<uint>.IsPositiveInfinity(uint value); + static bool INumberBase<uint>.IsRealNumber(uint value); + static bool INumberBase<uint>.IsSubnormal(uint value); + static bool INumberBase<uint>.IsZero(uint value); + static uint INumberBase<uint>.MaxMagnitude(uint x, uint y); + static uint INumberBase<uint>.MaxMagnitudeNumber(uint x, uint y); + static uint INumberBase<uint>.MinMagnitude(uint x, uint y); + static uint INumberBase<uint>.MinMagnitudeNumber(uint x, uint y); + static bool INumberBase<uint>.TryConvertFromChecked<TOther>(TOther value, out uint result); + static bool INumberBase<uint>.TryConvertFromSaturating<TOther>(TOther value, out uint result); + static bool INumberBase<uint>.TryConvertFromTruncating<TOther>(TOther value, out uint result); + static bool INumberBase<uint>.TryConvertToChecked<TOther>(uint value, out TOther result); + static bool INumberBase<uint>.TryConvertToSaturating<TOther>(uint value, out TOther result); + static bool INumberBase<uint>.TryConvertToTruncating<TOther>(uint value, out TOther result); + static uint IShiftOperators<uint, int, uint>.operator <<(uint value, int shiftAmount); + static uint IShiftOperators<uint, int, uint>.operator >>(uint value, int shiftAmount); + static uint IShiftOperators<uint, int, uint>.operator >>>(uint value, int shiftAmount); + static uint ISubtractionOperators<uint, uint, uint>.operator checked -(uint left, uint right); + static uint ISubtractionOperators<uint, uint, uint>.operator -(uint left, uint right); + static uint IUnaryNegationOperators<uint, uint>.operator checked -(uint value); + static uint IUnaryNegationOperators<uint, uint>.operator -(uint value); + static uint IUnaryPlusOperators<uint, uint>.operator +(uint value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static uint TrailingZeroCount(uint value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out uint result); + public static bool TryParse(string? s, IFormatProvider? provider, out uint result); } - public readonly struct UInt64 : IComparable, IComparable<ulong>, IConvertible, IEquatable<ulong>, IFormattable, ISpanFormattable { + public readonly struct UInt64 : IAdditionOperators<ulong, ulong, ulong>, IAdditiveIdentity<ulong, ulong>, IBinaryInteger<ulong>, IBinaryNumber<ulong>, IBitwiseOperators<ulong, ulong, ulong>, IComparable, IComparable<ulong>, IComparisonOperators<ulong, ulong, bool>, IConvertible, IDecrementOperators<ulong>, IDivisionOperators<ulong, ulong, ulong>, IEqualityOperators<ulong, ulong, bool>, IEquatable<ulong>, IFormattable, IIncrementOperators<ulong>, IMinMaxValue<ulong>, IModulusOperators<ulong, ulong, ulong>, IMultiplicativeIdentity<ulong, ulong>, IMultiplyOperators<ulong, ulong, ulong>, INumber<ulong>, INumberBase<ulong>, IParsable<ulong>, IShiftOperators<ulong, int, ulong>, ISpanFormattable, ISpanParsable<ulong>, ISubtractionOperators<ulong, ulong, ulong>, IUnaryNegationOperators<ulong, ulong>, IUnaryPlusOperators<ulong, ulong>, IUnsignedNumber<ulong> { + static ulong System.Numerics.IAdditiveIdentity<System.UInt64,System.UInt64>.AdditiveIdentity { get; } + static ulong System.Numerics.IBinaryNumber<System.UInt64>.AllBitsSet { get; } + static ulong System.Numerics.IMinMaxValue<System.UInt64>.MaxValue { get; } + static ulong System.Numerics.IMinMaxValue<System.UInt64>.MinValue { get; } + static ulong System.Numerics.IMultiplicativeIdentity<System.UInt64,System.UInt64>.MultiplicativeIdentity { get; } + static ulong System.Numerics.INumberBase<System.UInt64>.One { get; } + static int System.Numerics.INumberBase<System.UInt64>.Radix { get; } + static ulong System.Numerics.INumberBase<System.UInt64>.Zero { get; } + public static ulong Clamp(ulong value, ulong min, ulong max); + public static ulong CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ulong CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ulong CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (ulong Quotient, ulong Remainder) DivRem(ulong left, ulong right); + public static bool IsEvenInteger(ulong value); + public static bool IsOddInteger(ulong value); + public static bool IsPow2(ulong value); + public static ulong LeadingZeroCount(ulong value); + public static ulong Log2(ulong value); + public static ulong Max(ulong x, ulong y); + public static ulong Min(ulong x, ulong y); + public static ulong Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static ulong PopCount(ulong value); + public static ulong RotateLeft(ulong value, int rotateAmount); + public static ulong RotateRight(ulong value, int rotateAmount); + public static int Sign(ulong value); + static ulong IAdditionOperators<ulong, ulong, ulong>.operator +(ulong left, ulong right); + static ulong IAdditionOperators<ulong, ulong, ulong>.operator checked +(ulong left, ulong right); + int IBinaryInteger<ulong>.GetByteCount(); + int IBinaryInteger<ulong>.GetShortestBitLength(); + static bool IBinaryInteger<ulong>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ulong value); + static bool IBinaryInteger<ulong>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ulong value); + bool IBinaryInteger<ulong>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<ulong>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator &(ulong left, ulong right); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator |(ulong left, ulong right); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator ^(ulong left, ulong right); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator ~(ulong value); + static bool IComparisonOperators<ulong, ulong, bool>.operator >(ulong left, ulong right); + static bool IComparisonOperators<ulong, ulong, bool>.operator >=(ulong left, ulong right); + static bool IComparisonOperators<ulong, ulong, bool>.operator <(ulong left, ulong right); + static bool IComparisonOperators<ulong, ulong, bool>.operator <=(ulong left, ulong right); + static ulong IDecrementOperators<ulong>.operator checked --(ulong value); + static ulong IDecrementOperators<ulong>.operator --(ulong value); + static ulong IDivisionOperators<ulong, ulong, ulong>.operator /(ulong left, ulong right); + static bool IEqualityOperators<ulong, ulong, bool>.operator ==(ulong left, ulong right); + static bool IEqualityOperators<ulong, ulong, bool>.operator !=(ulong left, ulong right); + static ulong IIncrementOperators<ulong>.operator checked ++(ulong value); + static ulong IIncrementOperators<ulong>.operator ++(ulong value); + static ulong IModulusOperators<ulong, ulong, ulong>.operator %(ulong left, ulong right); + static ulong IMultiplyOperators<ulong, ulong, ulong>.operator checked *(ulong left, ulong right); + static ulong IMultiplyOperators<ulong, ulong, ulong>.operator *(ulong left, ulong right); + static ulong INumber<ulong>.CopySign(ulong value, ulong sign); + static ulong INumber<ulong>.MaxNumber(ulong x, ulong y); + static ulong INumber<ulong>.MinNumber(ulong x, ulong y); + static ulong INumberBase<ulong>.Abs(ulong value); + static bool INumberBase<ulong>.IsCanonical(ulong value); + static bool INumberBase<ulong>.IsComplexNumber(ulong value); + static bool INumberBase<ulong>.IsFinite(ulong value); + static bool INumberBase<ulong>.IsImaginaryNumber(ulong value); + static bool INumberBase<ulong>.IsInfinity(ulong value); + static bool INumberBase<ulong>.IsInteger(ulong value); + static bool INumberBase<ulong>.IsNaN(ulong value); + static bool INumberBase<ulong>.IsNegative(ulong value); + static bool INumberBase<ulong>.IsNegativeInfinity(ulong value); + static bool INumberBase<ulong>.IsNormal(ulong value); + static bool INumberBase<ulong>.IsPositive(ulong value); + static bool INumberBase<ulong>.IsPositiveInfinity(ulong value); + static bool INumberBase<ulong>.IsRealNumber(ulong value); + static bool INumberBase<ulong>.IsSubnormal(ulong value); + static bool INumberBase<ulong>.IsZero(ulong value); + static ulong INumberBase<ulong>.MaxMagnitude(ulong x, ulong y); + static ulong INumberBase<ulong>.MaxMagnitudeNumber(ulong x, ulong y); + static ulong INumberBase<ulong>.MinMagnitude(ulong x, ulong y); + static ulong INumberBase<ulong>.MinMagnitudeNumber(ulong x, ulong y); + static bool INumberBase<ulong>.TryConvertFromChecked<TOther>(TOther value, out ulong result); + static bool INumberBase<ulong>.TryConvertFromSaturating<TOther>(TOther value, out ulong result); + static bool INumberBase<ulong>.TryConvertFromTruncating<TOther>(TOther value, out ulong result); + static bool INumberBase<ulong>.TryConvertToChecked<TOther>(ulong value, out TOther result); + static bool INumberBase<ulong>.TryConvertToSaturating<TOther>(ulong value, out TOther result); + static bool INumberBase<ulong>.TryConvertToTruncating<TOther>(ulong value, out TOther result); + static ulong IShiftOperators<ulong, int, ulong>.operator <<(ulong value, int shiftAmount); + static ulong IShiftOperators<ulong, int, ulong>.operator >>(ulong value, int shiftAmount); + static ulong IShiftOperators<ulong, int, ulong>.operator >>>(ulong value, int shiftAmount); + static ulong ISubtractionOperators<ulong, ulong, ulong>.operator checked -(ulong left, ulong right); + static ulong ISubtractionOperators<ulong, ulong, ulong>.operator -(ulong left, ulong right); + static ulong IUnaryNegationOperators<ulong, ulong>.operator checked -(ulong value); + static ulong IUnaryNegationOperators<ulong, ulong>.operator -(ulong value); + static ulong IUnaryPlusOperators<ulong, ulong>.operator +(ulong value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static ulong TrailingZeroCount(ulong value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out ulong result); + public static bool TryParse(string? s, IFormatProvider? provider, out ulong result); } - public readonly struct UIntPtr : IComparable, IComparable<UIntPtr>, IEquatable<UIntPtr>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct UIntPtr : IAdditionOperators<UIntPtr, UIntPtr, UIntPtr>, IAdditiveIdentity<UIntPtr, UIntPtr>, IBinaryInteger<UIntPtr>, IBinaryNumber<UIntPtr>, IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>, IComparable, IComparable<UIntPtr>, IComparisonOperators<UIntPtr, UIntPtr, bool>, IDecrementOperators<UIntPtr>, IDivisionOperators<UIntPtr, UIntPtr, UIntPtr>, IEqualityOperators<UIntPtr, UIntPtr, bool>, IEquatable<UIntPtr>, IFormattable, IIncrementOperators<UIntPtr>, IMinMaxValue<UIntPtr>, IModulusOperators<UIntPtr, UIntPtr, UIntPtr>, IMultiplicativeIdentity<UIntPtr, UIntPtr>, IMultiplyOperators<UIntPtr, UIntPtr, UIntPtr>, INumber<UIntPtr>, INumberBase<UIntPtr>, IParsable<UIntPtr>, ISerializable, IShiftOperators<UIntPtr, int, UIntPtr>, ISpanFormattable, ISpanParsable<UIntPtr>, ISubtractionOperators<UIntPtr, UIntPtr, UIntPtr>, IUnaryNegationOperators<UIntPtr, UIntPtr>, IUnaryPlusOperators<UIntPtr, UIntPtr>, IUnsignedNumber<UIntPtr> { + static UIntPtr System.Numerics.IAdditiveIdentity<nuint,nuint>.AdditiveIdentity { get; } + static UIntPtr System.Numerics.IBinaryNumber<nuint>.AllBitsSet { get; } + static UIntPtr System.Numerics.IMinMaxValue<nuint>.MaxValue { get; } + static UIntPtr System.Numerics.IMinMaxValue<nuint>.MinValue { get; } + static UIntPtr System.Numerics.IMultiplicativeIdentity<nuint,nuint>.MultiplicativeIdentity { get; } + static UIntPtr System.Numerics.INumberBase<nuint>.One { get; } + static int System.Numerics.INumberBase<nuint>.Radix { get; } + static UIntPtr System.Numerics.INumberBase<nuint>.Zero { get; } + public static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max); + public static UIntPtr CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UIntPtr CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UIntPtr CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (UIntPtr Quotient, UIntPtr Remainder) DivRem(UIntPtr left, UIntPtr right); + public static bool IsEvenInteger(UIntPtr value); + public static bool IsOddInteger(UIntPtr value); + public static bool IsPow2(UIntPtr value); + public static UIntPtr LeadingZeroCount(UIntPtr value); + public static UIntPtr Log2(UIntPtr value); + public static UIntPtr Max(UIntPtr x, UIntPtr y); + public static UIntPtr Min(UIntPtr x, UIntPtr y); + public static UIntPtr Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static UIntPtr PopCount(UIntPtr value); + public static UIntPtr RotateLeft(UIntPtr value, int rotateAmount); + public static UIntPtr RotateRight(UIntPtr value, int rotateAmount); + public static int Sign(UIntPtr value); + static UIntPtr IAdditionOperators<UIntPtr, UIntPtr, UIntPtr>.operator +(UIntPtr left, UIntPtr right); + static UIntPtr IAdditionOperators<UIntPtr, UIntPtr, UIntPtr>.operator checked +(UIntPtr left, UIntPtr right); + int IBinaryInteger<UIntPtr>.GetByteCount(); + int IBinaryInteger<UIntPtr>.GetShortestBitLength(); + static bool IBinaryInteger<UIntPtr>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UIntPtr value); + static bool IBinaryInteger<UIntPtr>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UIntPtr value); + bool IBinaryInteger<UIntPtr>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<UIntPtr>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator &(UIntPtr left, UIntPtr right); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator |(UIntPtr left, UIntPtr right); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator ^(UIntPtr left, UIntPtr right); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator ~(UIntPtr value); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator >(UIntPtr left, UIntPtr right); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator >=(UIntPtr left, UIntPtr right); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator <(UIntPtr left, UIntPtr right); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator <=(UIntPtr left, UIntPtr right); + static UIntPtr IDecrementOperators<UIntPtr>.operator checked --(UIntPtr value); + static UIntPtr IDecrementOperators<UIntPtr>.operator --(UIntPtr value); + static UIntPtr IDivisionOperators<UIntPtr, UIntPtr, UIntPtr>.operator /(UIntPtr left, UIntPtr right); + static UIntPtr IIncrementOperators<UIntPtr>.operator checked ++(UIntPtr value); + static UIntPtr IIncrementOperators<UIntPtr>.operator ++(UIntPtr value); + static UIntPtr IModulusOperators<UIntPtr, UIntPtr, UIntPtr>.operator %(UIntPtr left, UIntPtr right); + static UIntPtr IMultiplyOperators<UIntPtr, UIntPtr, UIntPtr>.operator checked *(UIntPtr left, UIntPtr right); + static UIntPtr IMultiplyOperators<UIntPtr, UIntPtr, UIntPtr>.operator *(UIntPtr left, UIntPtr right); + static UIntPtr INumber<UIntPtr>.CopySign(UIntPtr value, UIntPtr sign); + static UIntPtr INumber<UIntPtr>.MaxNumber(UIntPtr x, UIntPtr y); + static UIntPtr INumber<UIntPtr>.MinNumber(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.Abs(UIntPtr value); + static bool INumberBase<UIntPtr>.IsCanonical(UIntPtr value); + static bool INumberBase<UIntPtr>.IsComplexNumber(UIntPtr value); + static bool INumberBase<UIntPtr>.IsFinite(UIntPtr value); + static bool INumberBase<UIntPtr>.IsImaginaryNumber(UIntPtr value); + static bool INumberBase<UIntPtr>.IsInfinity(UIntPtr value); + static bool INumberBase<UIntPtr>.IsInteger(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNaN(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNegative(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNegativeInfinity(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNormal(UIntPtr value); + static bool INumberBase<UIntPtr>.IsPositive(UIntPtr value); + static bool INumberBase<UIntPtr>.IsPositiveInfinity(UIntPtr value); + static bool INumberBase<UIntPtr>.IsRealNumber(UIntPtr value); + static bool INumberBase<UIntPtr>.IsSubnormal(UIntPtr value); + static bool INumberBase<UIntPtr>.IsZero(UIntPtr value); + static UIntPtr INumberBase<UIntPtr>.MaxMagnitude(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.MaxMagnitudeNumber(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.MinMagnitude(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.MinMagnitudeNumber(UIntPtr x, UIntPtr y); + static bool INumberBase<UIntPtr>.TryConvertFromChecked<TOther>(TOther value, out UIntPtr result); + static bool INumberBase<UIntPtr>.TryConvertFromSaturating<TOther>(TOther value, out UIntPtr result); + static bool INumberBase<UIntPtr>.TryConvertFromTruncating<TOther>(TOther value, out UIntPtr result); + static bool INumberBase<UIntPtr>.TryConvertToChecked<TOther>(UIntPtr value, out TOther result); + static bool INumberBase<UIntPtr>.TryConvertToSaturating<TOther>(UIntPtr value, out TOther result); + static bool INumberBase<UIntPtr>.TryConvertToTruncating<TOther>(UIntPtr value, out TOther result); + static UIntPtr IShiftOperators<UIntPtr, int, UIntPtr>.operator <<(UIntPtr value, int shiftAmount); + static UIntPtr IShiftOperators<UIntPtr, int, UIntPtr>.operator >>(UIntPtr value, int shiftAmount); + static UIntPtr IShiftOperators<UIntPtr, int, UIntPtr>.operator >>>(UIntPtr value, int shiftAmount); + static UIntPtr ISubtractionOperators<UIntPtr, UIntPtr, UIntPtr>.operator checked -(UIntPtr left, UIntPtr right); + static UIntPtr ISubtractionOperators<UIntPtr, UIntPtr, UIntPtr>.operator -(UIntPtr left, UIntPtr right); + static UIntPtr IUnaryNegationOperators<UIntPtr, UIntPtr>.operator checked -(UIntPtr value); + static UIntPtr IUnaryNegationOperators<UIntPtr, UIntPtr>.operator -(UIntPtr value); + static UIntPtr IUnaryPlusOperators<UIntPtr, UIntPtr>.operator +(UIntPtr value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static UIntPtr TrailingZeroCount(UIntPtr value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out UIntPtr result); + public static bool TryParse(string? s, IFormatProvider? provider, out UIntPtr result); } public class Uri : ISerializable { public Uri(string uriString); public Uri(string uriString, bool dontEscape); public Uri(string uriString, in UriCreationOptions creationOptions); public Uri(string uriString, UriKind uriKind); protected static string EscapeString(string? str); public static string EscapeUriString(string stringToEscape); public static bool IsWellFormedUriString(string? uriString, UriKind uriKind); public string MakeRelative(Uri toUri); public static bool TryCreate(string? uriString, in UriCreationOptions creationOptions, out Uri? result); public static bool TryCreate(string? uriString, UriKind uriKind, out Uri? result); } public class UriBuilder { public UriBuilder(string uri); } public struct UriCreationOptions public class UriTypeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System"},{"location":"Microsoft.NETCore.App/7.0_System/#system","text":"namespace System { public static class AppContext { + public static void SetData(string name, object? data); } public sealed class AppDomain : MarshalByRefObject { public static int GetCurrentThreadId(); } public class ArgumentException : SystemException { + public static void ThrowIfNullOrEmpty(string argument, string paramName = null); } public class ArgumentNullException : ArgumentException { + public unsafe static void ThrowIfNull(void* argument, string? paramName = null); } public abstract class Array : ICloneable, ICollection, IEnumerable, IList, IStructuralComparable, IStructuralEquatable { public static Array CreateInstance(Type elementType, int length); public static Array CreateInstance(Type elementType, params int[] lengths); public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds); public static Array CreateInstance(Type elementType, params long[] lengths); } - public readonly struct Byte : IComparable, IComparable<byte>, IConvertible, IEquatable<byte>, IFormattable, ISpanFormattable { + public readonly struct Byte : IAdditionOperators<byte, byte, byte>, IAdditiveIdentity<byte, byte>, IBinaryInteger<byte>, IBinaryNumber<byte>, IBitwiseOperators<byte, byte, byte>, IComparable, IComparable<byte>, IComparisonOperators<byte, byte, bool>, IConvertible, IDecrementOperators<byte>, IDivisionOperators<byte, byte, byte>, IEqualityOperators<byte, byte, bool>, IEquatable<byte>, IFormattable, IIncrementOperators<byte>, IMinMaxValue<byte>, IModulusOperators<byte, byte, byte>, IMultiplicativeIdentity<byte, byte>, IMultiplyOperators<byte, byte, byte>, INumber<byte>, INumberBase<byte>, IParsable<byte>, IShiftOperators<byte, int, byte>, ISpanFormattable, ISpanParsable<byte>, ISubtractionOperators<byte, byte, byte>, IUnaryNegationOperators<byte, byte>, IUnaryPlusOperators<byte, byte>, IUnsignedNumber<byte> { + static byte System.Numerics.IAdditiveIdentity<System.Byte,System.Byte>.AdditiveIdentity { get; } + static byte System.Numerics.IBinaryNumber<System.Byte>.AllBitsSet { get; } + static byte System.Numerics.IMinMaxValue<System.Byte>.MaxValue { get; } + static byte System.Numerics.IMinMaxValue<System.Byte>.MinValue { get; } + static byte System.Numerics.IMultiplicativeIdentity<System.Byte,System.Byte>.MultiplicativeIdentity { get; } + static byte System.Numerics.INumberBase<System.Byte>.One { get; } + static int System.Numerics.INumberBase<System.Byte>.Radix { get; } + static byte System.Numerics.INumberBase<System.Byte>.Zero { get; } + public static byte Clamp(byte value, byte min, byte max); + public static byte CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static byte CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static byte CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (byte Quotient, byte Remainder) DivRem(byte left, byte right); + public static bool IsEvenInteger(byte value); + public static bool IsOddInteger(byte value); + public static bool IsPow2(byte value); + public static byte LeadingZeroCount(byte value); + public static byte Log2(byte value); + public static byte Max(byte x, byte y); + public static byte Min(byte x, byte y); + public static byte Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static byte PopCount(byte value); + public static byte RotateLeft(byte value, int rotateAmount); + public static byte RotateRight(byte value, int rotateAmount); + public static int Sign(byte value); + static byte IAdditionOperators<byte, byte, byte>.operator +(byte left, byte right); + static byte IAdditionOperators<byte, byte, byte>.operator checked +(byte left, byte right); + int IBinaryInteger<byte>.GetByteCount(); + int IBinaryInteger<byte>.GetShortestBitLength(); + static bool IBinaryInteger<byte>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out byte value); + static bool IBinaryInteger<byte>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out byte value); + bool IBinaryInteger<byte>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<byte>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static byte IBitwiseOperators<byte, byte, byte>.operator &(byte left, byte right); + static byte IBitwiseOperators<byte, byte, byte>.operator |(byte left, byte right); + static byte IBitwiseOperators<byte, byte, byte>.operator ^(byte left, byte right); + static byte IBitwiseOperators<byte, byte, byte>.operator ~(byte value); + static bool IComparisonOperators<byte, byte, bool>.operator >(byte left, byte right); + static bool IComparisonOperators<byte, byte, bool>.operator >=(byte left, byte right); + static bool IComparisonOperators<byte, byte, bool>.operator <(byte left, byte right); + static bool IComparisonOperators<byte, byte, bool>.operator <=(byte left, byte right); + static byte IDecrementOperators<byte>.operator checked --(byte value); + static byte IDecrementOperators<byte>.operator --(byte value); + static byte IDivisionOperators<byte, byte, byte>.operator /(byte left, byte right); + static bool IEqualityOperators<byte, byte, bool>.operator ==(byte left, byte right); + static bool IEqualityOperators<byte, byte, bool>.operator !=(byte left, byte right); + static byte IIncrementOperators<byte>.operator checked ++(byte value); + static byte IIncrementOperators<byte>.operator ++(byte value); + static byte IModulusOperators<byte, byte, byte>.operator %(byte left, byte right); + static byte IMultiplyOperators<byte, byte, byte>.operator checked *(byte left, byte right); + static byte IMultiplyOperators<byte, byte, byte>.operator *(byte left, byte right); + static byte INumber<byte>.CopySign(byte value, byte sign); + static byte INumber<byte>.MaxNumber(byte x, byte y); + static byte INumber<byte>.MinNumber(byte x, byte y); + static byte INumberBase<byte>.Abs(byte value); + static bool INumberBase<byte>.IsCanonical(byte value); + static bool INumberBase<byte>.IsComplexNumber(byte value); + static bool INumberBase<byte>.IsFinite(byte value); + static bool INumberBase<byte>.IsImaginaryNumber(byte value); + static bool INumberBase<byte>.IsInfinity(byte value); + static bool INumberBase<byte>.IsInteger(byte value); + static bool INumberBase<byte>.IsNaN(byte value); + static bool INumberBase<byte>.IsNegative(byte value); + static bool INumberBase<byte>.IsNegativeInfinity(byte value); + static bool INumberBase<byte>.IsNormal(byte value); + static bool INumberBase<byte>.IsPositive(byte value); + static bool INumberBase<byte>.IsPositiveInfinity(byte value); + static bool INumberBase<byte>.IsRealNumber(byte value); + static bool INumberBase<byte>.IsSubnormal(byte value); + static bool INumberBase<byte>.IsZero(byte value); + static byte INumberBase<byte>.MaxMagnitude(byte x, byte y); + static byte INumberBase<byte>.MaxMagnitudeNumber(byte x, byte y); + static byte INumberBase<byte>.MinMagnitude(byte x, byte y); + static byte INumberBase<byte>.MinMagnitudeNumber(byte x, byte y); + static bool INumberBase<byte>.TryConvertFromChecked<TOther>(TOther value, out byte result); + static bool INumberBase<byte>.TryConvertFromSaturating<TOther>(TOther value, out byte result); + static bool INumberBase<byte>.TryConvertFromTruncating<TOther>(TOther value, out byte result); + static bool INumberBase<byte>.TryConvertToChecked<TOther>(byte value, out TOther result); + static bool INumberBase<byte>.TryConvertToSaturating<TOther>(byte value, out TOther result); + static bool INumberBase<byte>.TryConvertToTruncating<TOther>(byte value, out TOther result); + static byte IShiftOperators<byte, int, byte>.operator <<(byte value, int shiftAmount); + static byte IShiftOperators<byte, int, byte>.operator >>(byte value, int shiftAmount); + static byte IShiftOperators<byte, int, byte>.operator >>>(byte value, int shiftAmount); + static byte ISubtractionOperators<byte, byte, byte>.operator checked -(byte left, byte right); + static byte ISubtractionOperators<byte, byte, byte>.operator -(byte left, byte right); + static byte IUnaryNegationOperators<byte, byte>.operator checked -(byte value); + static byte IUnaryNegationOperators<byte, byte>.operator -(byte value); + static byte IUnaryPlusOperators<byte, byte>.operator +(byte value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static byte TrailingZeroCount(byte value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out byte result); + public static bool TryParse(string? s, IFormatProvider? provider, out byte result); } - public readonly struct Char : IComparable, IComparable<char>, IConvertible, IEquatable<char>, IFormattable, ISpanFormattable { + public readonly struct Char : IAdditionOperators<char, char, char>, IAdditiveIdentity<char, char>, IBinaryInteger<char>, IBinaryNumber<char>, IBitwiseOperators<char, char, char>, IComparable, IComparable<char>, IComparisonOperators<char, char, bool>, IConvertible, IDecrementOperators<char>, IDivisionOperators<char, char, char>, IEqualityOperators<char, char, bool>, IEquatable<char>, IFormattable, IIncrementOperators<char>, IMinMaxValue<char>, IModulusOperators<char, char, char>, IMultiplicativeIdentity<char, char>, IMultiplyOperators<char, char, char>, INumber<char>, INumberBase<char>, IParsable<char>, IShiftOperators<char, int, char>, ISpanFormattable, ISpanParsable<char>, ISubtractionOperators<char, char, char>, IUnaryNegationOperators<char, char>, IUnaryPlusOperators<char, char>, IUnsignedNumber<char> { + static char System.Numerics.IAdditiveIdentity<System.Char,System.Char>.AdditiveIdentity { get; } + static char System.Numerics.IBinaryNumber<System.Char>.AllBitsSet { get; } + static char System.Numerics.IMinMaxValue<System.Char>.MaxValue { get; } + static char System.Numerics.IMinMaxValue<System.Char>.MinValue { get; } + static char System.Numerics.IMultiplicativeIdentity<System.Char,System.Char>.MultiplicativeIdentity { get; } + static char System.Numerics.INumberBase<System.Char>.One { get; } + static int System.Numerics.INumberBase<System.Char>.Radix { get; } + static char System.Numerics.INumberBase<System.Char>.Zero { get; } + public static bool IsAsciiDigit(char c); + public static bool IsAsciiHexDigit(char c); + public static bool IsAsciiHexDigitLower(char c); + public static bool IsAsciiHexDigitUpper(char c); + public static bool IsAsciiLetter(char c); + public static bool IsAsciiLetterLower(char c); + public static bool IsAsciiLetterOrDigit(char c); + public static bool IsAsciiLetterUpper(char c); + public static bool IsBetween(char c, char minInclusive, char maxInclusive); + static char IParsable<char>.Parse(string s, IFormatProvider provider); + static bool IParsable<char>.TryParse(string s, IFormatProvider provider, out char result); + static char ISpanParsable<char>.Parse(ReadOnlySpan<char> s, IFormatProvider provider); + static bool ISpanParsable<char>.TryParse(ReadOnlySpan<char> s, IFormatProvider provider, out char result); + static char IAdditionOperators<char, char, char>.operator +(char left, char right); + static char IAdditionOperators<char, char, char>.operator checked +(char left, char right); + int IBinaryInteger<char>.GetByteCount(); + int IBinaryInteger<char>.GetShortestBitLength(); + static char IBinaryInteger<char>.LeadingZeroCount(char value); + static char IBinaryInteger<char>.PopCount(char value); + static char IBinaryInteger<char>.RotateLeft(char value, int rotateAmount); + static char IBinaryInteger<char>.RotateRight(char value, int rotateAmount); + static char IBinaryInteger<char>.TrailingZeroCount(char value); + static bool IBinaryInteger<char>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out char value); + static bool IBinaryInteger<char>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out char value); + bool IBinaryInteger<char>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<char>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static bool IBinaryNumber<char>.IsPow2(char value); + static char IBinaryNumber<char>.Log2(char value); + static char IBitwiseOperators<char, char, char>.operator &(char left, char right); + static char IBitwiseOperators<char, char, char>.operator |(char left, char right); + static char IBitwiseOperators<char, char, char>.operator ^(char left, char right); + static char IBitwiseOperators<char, char, char>.operator ~(char value); + static bool IComparisonOperators<char, char, bool>.operator >(char left, char right); + static bool IComparisonOperators<char, char, bool>.operator >=(char left, char right); + static bool IComparisonOperators<char, char, bool>.operator <(char left, char right); + static bool IComparisonOperators<char, char, bool>.operator <=(char left, char right); + static char IDecrementOperators<char>.operator checked --(char value); + static char IDecrementOperators<char>.operator --(char value); + static char IDivisionOperators<char, char, char>.operator /(char left, char right); + static bool IEqualityOperators<char, char, bool>.operator ==(char left, char right); + static bool IEqualityOperators<char, char, bool>.operator !=(char left, char right); + static char IIncrementOperators<char>.operator checked ++(char value); + static char IIncrementOperators<char>.operator ++(char value); + static char IModulusOperators<char, char, char>.operator %(char left, char right); + static char IMultiplyOperators<char, char, char>.operator checked *(char left, char right); + static char IMultiplyOperators<char, char, char>.operator *(char left, char right); + static char INumberBase<char>.Abs(char value); + static bool INumberBase<char>.IsCanonical(char value); + static bool INumberBase<char>.IsComplexNumber(char value); + static bool INumberBase<char>.IsEvenInteger(char value); + static bool INumberBase<char>.IsFinite(char value); + static bool INumberBase<char>.IsImaginaryNumber(char value); + static bool INumberBase<char>.IsInfinity(char value); + static bool INumberBase<char>.IsInteger(char value); + static bool INumberBase<char>.IsNaN(char value); + static bool INumberBase<char>.IsNegative(char value); + static bool INumberBase<char>.IsNegativeInfinity(char value); + static bool INumberBase<char>.IsNormal(char value); + static bool INumberBase<char>.IsOddInteger(char value); + static bool INumberBase<char>.IsPositive(char value); + static bool INumberBase<char>.IsPositiveInfinity(char value); + static bool INumberBase<char>.IsRealNumber(char value); + static bool INumberBase<char>.IsSubnormal(char value); + static bool INumberBase<char>.IsZero(char value); + static char INumberBase<char>.MaxMagnitude(char x, char y); + static char INumberBase<char>.MaxMagnitudeNumber(char x, char y); + static char INumberBase<char>.MinMagnitude(char x, char y); + static char INumberBase<char>.MinMagnitudeNumber(char x, char y); + static char INumberBase<char>.Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider); + static char INumberBase<char>.Parse(string s, NumberStyles style, IFormatProvider provider); + static bool INumberBase<char>.TryConvertFromChecked<TOther>(TOther value, out char result); + static bool INumberBase<char>.TryConvertFromSaturating<TOther>(TOther value, out char result); + static bool INumberBase<char>.TryConvertFromTruncating<TOther>(TOther value, out char result); + static bool INumberBase<char>.TryConvertToChecked<TOther>(char value, out TOther result); + static bool INumberBase<char>.TryConvertToSaturating<TOther>(char value, out TOther result); + static bool INumberBase<char>.TryConvertToTruncating<TOther>(char value, out TOther result); + static bool INumberBase<char>.TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out char result); + static bool INumberBase<char>.TryParse(string s, NumberStyles style, IFormatProvider provider, out char result); + static char IShiftOperators<char, int, char>.operator <<(char value, int shiftAmount); + static char IShiftOperators<char, int, char>.operator >>(char value, int shiftAmount); + static char IShiftOperators<char, int, char>.operator >>>(char value, int shiftAmount); + static char ISubtractionOperators<char, char, char>.operator checked -(char left, char right); + static char ISubtractionOperators<char, char, char>.operator -(char left, char right); + static char IUnaryNegationOperators<char, char>.operator checked -(char value); + static char IUnaryNegationOperators<char, char>.operator -(char value); + static char IUnaryPlusOperators<char, char>.operator +(char value); } public static class Console { public static void Write(string format, object? arg0); public static void Write(string format, object? arg0, object? arg1); public static void Write(string format, object? arg0, object? arg1, object? arg2); public static void Write(string format, params object?[]? arg); public static void WriteLine(string format, object? arg0); public static void WriteLine(string format, object? arg0, object? arg1); public static void WriteLine(string format, object? arg0, object? arg1, object? arg2); public static void WriteLine(string format, params object?[]? arg); } - public readonly struct DateOnly : IComparable, IComparable<DateOnly>, IEquatable<DateOnly>, IFormattable, ISpanFormattable { + public readonly struct DateOnly : IComparable, IComparable<DateOnly>, IEquatable<DateOnly>, IFormattable, IParsable<DateOnly>, ISpanFormattable, ISpanParsable<DateOnly> { + public static DateOnly Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static DateOnly Parse(string s, IFormatProvider? provider); public static DateOnly ParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider = null, DateTimeStyles style = DateTimeStyles.None); public static DateOnly ParseExact(ReadOnlySpan<char> s, string[] formats); public static DateOnly ParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateOnly ParseExact(string s, string format); public static DateOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateOnly ParseExact(string s, string[] formats); public static DateOnly ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DateOnly result); + public static bool TryParse(string? s, IFormatProvider? provider, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, out DateOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); public static bool TryParseExact(string? s, string? format, out DateOnly result); public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); public static bool TryParseExact(string? s, string?[]? formats, out DateOnly result); public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly result); } - public readonly struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable, IParsable<DateTime>, ISerializable, ISpanFormattable, ISpanParsable<DateTime> { + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond); + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, DateTimeKind kind); + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar); + public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, DateTimeKind kind); + public int Microsecond { get; } + public int Nanosecond { get; } + public DateTime AddMicroseconds(double value); + public static DateTime Parse(ReadOnlySpan<char> s, IFormatProvider? provider); public static DateTime ParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateTime ParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static DateTime ParseExact(string s, string format, IFormatProvider? provider); public static DateTime ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style); public static DateTime ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DateTime result); + public static bool TryParse(string? s, IFormatProvider? provider, out DateTime result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style, out DateTime result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateTime result); public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out DateTime result); public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out DateTime result); } - public readonly struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, IFormattable, IParsable<DateTimeOffset>, ISerializable, ISpanFormattable, ISpanParsable<DateTimeOffset> { + public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, TimeSpan offset); + public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, TimeSpan offset); + public int Microsecond { get; } + public int Nanosecond { get; } + public DateTimeOffset AddMicroseconds(double microseconds); + public static DateTimeOffset Parse(ReadOnlySpan<char> s, IFormatProvider? provider); public static DateTimeOffset ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, DateTimeStyles styles = DateTimeStyles.None); public static DateTimeOffset ParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider? formatProvider, DateTimeStyles styles = DateTimeStyles.None); public static DateTimeOffset ParseExact(string input, string format, IFormatProvider? formatProvider); public static DateTimeOffset ParseExact(string input, string format, IFormatProvider? formatProvider, DateTimeStyles styles); public static DateTimeOffset ParseExact(string input, string[] formats, IFormatProvider? formatProvider, DateTimeStyles styles); public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? formatProvider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DateTimeOffset result); + public static bool TryParse(string? s, IFormatProvider? provider, out DateTimeOffset result); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); public static bool TryParseExact(ReadOnlySpan<char> input, string?[]? formats, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, DateTimeStyles styles, out DateTimeOffset result); } - public readonly struct Decimal : IComparable, IComparable<decimal>, IConvertible, IDeserializationCallback, IEquatable<decimal>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct Decimal : IAdditionOperators<decimal, decimal, decimal>, IAdditiveIdentity<decimal, decimal>, IComparable, IComparable<decimal>, IComparisonOperators<decimal, decimal, bool>, IConvertible, IDecrementOperators<decimal>, IDeserializationCallback, IDivisionOperators<decimal, decimal, decimal>, IEqualityOperators<decimal, decimal, bool>, IEquatable<decimal>, IFloatingPoint<decimal>, IFloatingPointConstants<decimal>, IFormattable, IIncrementOperators<decimal>, IMinMaxValue<decimal>, IModulusOperators<decimal, decimal, decimal>, IMultiplicativeIdentity<decimal, decimal>, IMultiplyOperators<decimal, decimal, decimal>, INumber<decimal>, INumberBase<decimal>, IParsable<decimal>, ISerializable, ISignedNumber<decimal>, ISpanFormattable, ISpanParsable<decimal>, ISubtractionOperators<decimal, decimal, decimal>, IUnaryNegationOperators<decimal, decimal>, IUnaryPlusOperators<decimal, decimal> { + public byte Scale { get; } + static decimal System.Numerics.IAdditiveIdentity<System.Decimal,System.Decimal>.AdditiveIdentity { get; } + static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.E { get; } + static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Pi { get; } + static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Tau { get; } + static decimal System.Numerics.IMinMaxValue<System.Decimal>.MaxValue { get; } + static decimal System.Numerics.IMinMaxValue<System.Decimal>.MinValue { get; } + static decimal System.Numerics.IMultiplicativeIdentity<System.Decimal,System.Decimal>.MultiplicativeIdentity { get; } + static decimal System.Numerics.INumberBase<System.Decimal>.One { get; } + static int System.Numerics.INumberBase<System.Decimal>.Radix { get; } + static decimal System.Numerics.INumberBase<System.Decimal>.Zero { get; } + static decimal System.Numerics.ISignedNumber<System.Decimal>.NegativeOne { get; } + public static decimal Abs(decimal value); + public static decimal Clamp(decimal value, decimal min, decimal max); + public static decimal CopySign(decimal value, decimal sign); + public static decimal CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static decimal CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static decimal CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static bool IsCanonical(decimal value); + public static bool IsEvenInteger(decimal value); + public static bool IsInteger(decimal value); + public static bool IsNegative(decimal value); + public static bool IsOddInteger(decimal value); + public static bool IsPositive(decimal value); + public static decimal Max(decimal x, decimal y); + public static decimal MaxMagnitude(decimal x, decimal y); + public static decimal Min(decimal x, decimal y); + public static decimal MinMagnitude(decimal x, decimal y); + public static decimal Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static int Sign(decimal d); + int IFloatingPoint<decimal>.GetExponentByteCount(); + int IFloatingPoint<decimal>.GetExponentShortestBitLength(); + int IFloatingPoint<decimal>.GetSignificandBitLength(); + int IFloatingPoint<decimal>.GetSignificandByteCount(); + bool IFloatingPoint<decimal>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<decimal>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<decimal>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<decimal>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static decimal INumber<decimal>.MaxNumber(decimal x, decimal y); + static decimal INumber<decimal>.MinNumber(decimal x, decimal y); + static bool INumberBase<decimal>.IsComplexNumber(decimal value); + static bool INumberBase<decimal>.IsFinite(decimal value); + static bool INumberBase<decimal>.IsImaginaryNumber(decimal value); + static bool INumberBase<decimal>.IsInfinity(decimal value); + static bool INumberBase<decimal>.IsNaN(decimal value); + static bool INumberBase<decimal>.IsNegativeInfinity(decimal value); + static bool INumberBase<decimal>.IsNormal(decimal value); + static bool INumberBase<decimal>.IsPositiveInfinity(decimal value); + static bool INumberBase<decimal>.IsRealNumber(decimal value); + static bool INumberBase<decimal>.IsSubnormal(decimal value); + static bool INumberBase<decimal>.IsZero(decimal value); + static decimal INumberBase<decimal>.MaxMagnitudeNumber(decimal x, decimal y); + static decimal INumberBase<decimal>.MinMagnitudeNumber(decimal x, decimal y); + static bool INumberBase<decimal>.TryConvertFromChecked<TOther>(TOther value, out decimal result); + static bool INumberBase<decimal>.TryConvertFromSaturating<TOther>(TOther value, out decimal result); + static bool INumberBase<decimal>.TryConvertFromTruncating<TOther>(TOther value, out decimal result); + static bool INumberBase<decimal>.TryConvertToChecked<TOther>(decimal value, out TOther result); + static bool INumberBase<decimal>.TryConvertToSaturating<TOther>(decimal value, out TOther result); + static bool INumberBase<decimal>.TryConvertToTruncating<TOther>(decimal value, out TOther result); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out decimal result); + public static bool TryParse(string? s, IFormatProvider? provider, out decimal result); } - public readonly struct Double : IComparable, IComparable<double>, IConvertible, IEquatable<double>, IFormattable, ISpanFormattable { + public readonly struct Double : IAdditionOperators<double, double, double>, IAdditiveIdentity<double, double>, IBinaryFloatingPointIeee754<double>, IBinaryNumber<double>, IBitwiseOperators<double, double, double>, IComparable, IComparable<double>, IComparisonOperators<double, double, bool>, IConvertible, IDecrementOperators<double>, IDivisionOperators<double, double, double>, IEqualityOperators<double, double, bool>, IEquatable<double>, IExponentialFunctions<double>, IFloatingPoint<double>, IFloatingPointConstants<double>, IFloatingPointIeee754<double>, IFormattable, IHyperbolicFunctions<double>, IIncrementOperators<double>, ILogarithmicFunctions<double>, IMinMaxValue<double>, IModulusOperators<double, double, double>, IMultiplicativeIdentity<double, double>, IMultiplyOperators<double, double, double>, INumber<double>, INumberBase<double>, IParsable<double>, IPowerFunctions<double>, IRootFunctions<double>, ISignedNumber<double>, ISpanFormattable, ISpanParsable<double>, ISubtractionOperators<double, double, double>, ITrigonometricFunctions<double>, IUnaryNegationOperators<double, double>, IUnaryPlusOperators<double, double> { + public const double E = 2.718281828459045; + public const double NegativeZero = 0; + public const double Pi = 3.141592653589793; + public const double Tau = 6.283185307179586; + static double System.Numerics.IAdditiveIdentity<System.Double,System.Double>.AdditiveIdentity { get; } + static double System.Numerics.IBinaryNumber<System.Double>.AllBitsSet { get; } + static double System.Numerics.IFloatingPointConstants<System.Double>.E { get; } + static double System.Numerics.IFloatingPointConstants<System.Double>.Pi { get; } + static double System.Numerics.IFloatingPointConstants<System.Double>.Tau { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.Epsilon { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.NaN { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeInfinity { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeZero { get; } + static double System.Numerics.IFloatingPointIeee754<System.Double>.PositiveInfinity { get; } + static double System.Numerics.IMinMaxValue<System.Double>.MaxValue { get; } + static double System.Numerics.IMinMaxValue<System.Double>.MinValue { get; } + static double System.Numerics.IMultiplicativeIdentity<System.Double,System.Double>.MultiplicativeIdentity { get; } + static double System.Numerics.INumberBase<System.Double>.One { get; } + static int System.Numerics.INumberBase<System.Double>.Radix { get; } + static double System.Numerics.INumberBase<System.Double>.Zero { get; } + static double System.Numerics.ISignedNumber<System.Double>.NegativeOne { get; } + public static double Abs(double value); + public static double Acos(double x); + public static double Acosh(double x); + public static double AcosPi(double x); + public static double Asin(double x); + public static double Asinh(double x); + public static double AsinPi(double x); + public static double Atan(double x); + public static double Atan2(double y, double x); + public static double Atan2Pi(double y, double x); + public static double Atanh(double x); + public static double AtanPi(double x); + public static double BitDecrement(double x); + public static double BitIncrement(double x); + public static double Cbrt(double x); + public static double Ceiling(double x); + public static double Clamp(double value, double min, double max); + public static double CopySign(double value, double sign); + public static double Cos(double x); + public static double Cosh(double x); + public static double CosPi(double x); + public static double CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static double CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static double CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static double Exp(double x); + public static double Exp10(double x); + public static double Exp10M1(double x); + public static double Exp2(double x); + public static double Exp2M1(double x); + public static double ExpM1(double x); + public static double Floor(double x); + public static double FusedMultiplyAdd(double left, double right, double addend); + public static double Hypot(double x, double y); + public static double Ieee754Remainder(double left, double right); + public static int ILogB(double x); + public static bool IsEvenInteger(double value); + public static bool IsInteger(double value); + public static bool IsOddInteger(double value); + public static bool IsPositive(double value); + public static bool IsPow2(double value); + public static bool IsRealNumber(double value); + public static double Log(double x); + public static double Log(double x, double newBase); + public static double Log10(double x); + public static double Log10P1(double x); + public static double Log2(double value); + public static double Log2P1(double x); + public static double LogP1(double x); + public static double Max(double x, double y); + public static double MaxMagnitude(double x, double y); + public static double MaxMagnitudeNumber(double x, double y); + public static double MaxNumber(double x, double y); + public static double Min(double x, double y); + public static double MinMagnitude(double x, double y); + public static double MinMagnitudeNumber(double x, double y); + public static double MinNumber(double x, double y); + public static double Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static double Pow(double x, double y); + public static double ReciprocalEstimate(double x); + public static double ReciprocalSqrtEstimate(double x); + public static double RootN(double x, int n); + public static double Round(double x); + public static double Round(double x, int digits); + public static double Round(double x, int digits, MidpointRounding mode); + public static double Round(double x, MidpointRounding mode); + public static double ScaleB(double x, int n); + public static int Sign(double value); + public static double Sin(double x); + public static (double Sin, double Cos) SinCos(double x); + public static (double SinPi, double CosPi) SinCosPi(double x); + public static double Sinh(double x); + public static double SinPi(double x); + public static double Sqrt(double x); + static double IAdditionOperators<double, double, double>.operator +(double left, double right); + static double IBitwiseOperators<double, double, double>.operator &(double left, double right); + static double IBitwiseOperators<double, double, double>.operator |(double left, double right); + static double IBitwiseOperators<double, double, double>.operator ^(double left, double right); + static double IBitwiseOperators<double, double, double>.operator ~(double value); + static double IDecrementOperators<double>.operator --(double value); + static double IDivisionOperators<double, double, double>.operator /(double left, double right); + int IFloatingPoint<double>.GetExponentByteCount(); + int IFloatingPoint<double>.GetExponentShortestBitLength(); + int IFloatingPoint<double>.GetSignificandBitLength(); + int IFloatingPoint<double>.GetSignificandByteCount(); + bool IFloatingPoint<double>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<double>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<double>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<double>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static double IIncrementOperators<double>.operator ++(double value); + static double IModulusOperators<double, double, double>.operator %(double left, double right); + static double IMultiplyOperators<double, double, double>.operator *(double left, double right); + static bool INumberBase<double>.IsCanonical(double value); + static bool INumberBase<double>.IsComplexNumber(double value); + static bool INumberBase<double>.IsImaginaryNumber(double value); + static bool INumberBase<double>.IsZero(double value); + static bool INumberBase<double>.TryConvertFromChecked<TOther>(TOther value, out double result); + static bool INumberBase<double>.TryConvertFromSaturating<TOther>(TOther value, out double result); + static bool INumberBase<double>.TryConvertFromTruncating<TOther>(TOther value, out double result); + static bool INumberBase<double>.TryConvertToChecked<TOther>(double value, out TOther result); + static bool INumberBase<double>.TryConvertToSaturating<TOther>(double value, out TOther result); + static bool INumberBase<double>.TryConvertToTruncating<TOther>(double value, out TOther result); + static double ISubtractionOperators<double, double, double>.operator -(double left, double right); + static double IUnaryNegationOperators<double, double>.operator -(double value); + static double IUnaryPlusOperators<double, double>.operator +(double value); + public static double Tan(double x); + public static double Tanh(double x); + public static double TanPi(double x); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static double Truncate(double x); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out double result); + public static bool TryParse(string? s, IFormatProvider? provider, out double result); } public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable { public static string Format(Type enumType, object value, string format); public static Array GetValues(Type enumType); + public static Array GetValuesAsUnderlyingType(Type enumType); + public static Array GetValuesAsUnderlyingType<TEnum>() where TEnum : struct; public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public static bool TryParse(Type enumType, ReadOnlySpan<char> value, bool ignoreCase, out object? result); public static bool TryParse(Type enumType, ReadOnlySpan<char> value, out object? result); public static bool TryParse(Type enumType, string? value, bool ignoreCase, out object? result); public static bool TryParse(Type enumType, string? value, out object? result); } public class Exception : ISerializable { public MethodBase TargetSite { get; } } public abstract class FormattableString : IFormattable { public abstract string Format { get; } } public static class GC { + public static IReadOnlyDictionary<string, object> GetConfigurationVariables(); + public static TimeSpan GetTotalPauseDuration(); + public static GCNotificationStatus WaitForFullGCApproach(TimeSpan timeout); + public static GCNotificationStatus WaitForFullGCComplete(TimeSpan timeout); } public enum GCCollectionMode { + Aggressive = 3, } - public readonly struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable, ISpanFormattable { + public readonly struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable, IParsable<Guid>, ISpanFormattable, ISpanParsable<Guid> { + public static bool operator >(Guid left, Guid right); + public static bool operator >=(Guid left, Guid right); + public static bool operator <(Guid left, Guid right); + public static bool operator <=(Guid left, Guid right); + public static Guid Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Guid Parse(string s, IFormatProvider? provider); public static Guid ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format); public static Guid ParseExact(string input, string format); bool ISpanFormattable.TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider provider); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>)); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Guid result); + public static bool TryParse(string? s, IFormatProvider? provider, out Guid result); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, out Guid result); public static bool TryParseExact(string? input, string? format, out Guid result); } - public readonly struct Half : IComparable, IComparable<Half>, IEquatable<Half>, IFormattable, ISpanFormattable { + public readonly struct Half : IAdditionOperators<Half, Half, Half>, IAdditiveIdentity<Half, Half>, IBinaryFloatingPointIeee754<Half>, IBinaryNumber<Half>, IBitwiseOperators<Half, Half, Half>, IComparable, IComparable<Half>, IComparisonOperators<Half, Half, bool>, IDecrementOperators<Half>, IDivisionOperators<Half, Half, Half>, IEqualityOperators<Half, Half, bool>, IEquatable<Half>, IExponentialFunctions<Half>, IFloatingPoint<Half>, IFloatingPointConstants<Half>, IFloatingPointIeee754<Half>, IFormattable, IHyperbolicFunctions<Half>, IIncrementOperators<Half>, ILogarithmicFunctions<Half>, IMinMaxValue<Half>, IModulusOperators<Half, Half, Half>, IMultiplicativeIdentity<Half, Half>, IMultiplyOperators<Half, Half, Half>, INumber<Half>, INumberBase<Half>, IParsable<Half>, IPowerFunctions<Half>, IRootFunctions<Half>, ISignedNumber<Half>, ISpanFormattable, ISpanParsable<Half>, ISubtractionOperators<Half, Half, Half>, ITrigonometricFunctions<Half>, IUnaryNegationOperators<Half, Half>, IUnaryPlusOperators<Half, Half> { + public static Half E { get; } + public static Half MultiplicativeIdentity { get; } + public static Half NegativeOne { get; } + public static Half NegativeZero { get; } + public static Half One { get; } + public static Half Pi { get; } + static Half System.Numerics.IAdditiveIdentity<System.Half,System.Half>.AdditiveIdentity { get; } + static Half System.Numerics.IBinaryNumber<System.Half>.AllBitsSet { get; } + static int System.Numerics.INumberBase<System.Half>.Radix { get; } + public static Half Tau { get; } + public static Half Zero { get; } + public static Half Abs(Half value); + public static Half Acos(Half x); + public static Half Acosh(Half x); + public static Half AcosPi(Half x); + public static Half Asin(Half x); + public static Half Asinh(Half x); + public static Half AsinPi(Half x); + public static Half Atan(Half x); + public static Half Atan2(Half y, Half x); + public static Half Atan2Pi(Half y, Half x); + public static Half Atanh(Half x); + public static Half AtanPi(Half x); + public static Half BitDecrement(Half x); + public static Half BitIncrement(Half x); + public static Half Cbrt(Half x); + public static Half Ceiling(Half x); + public static Half Clamp(Half value, Half min, Half max); + public static Half CopySign(Half value, Half sign); + public static Half Cos(Half x); + public static Half Cosh(Half x); + public static Half CosPi(Half x); + public static Half CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Half CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Half CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Half Exp(Half x); + public static Half Exp10(Half x); + public static Half Exp10M1(Half x); + public static Half Exp2(Half x); + public static Half Exp2M1(Half x); + public static Half ExpM1(Half x); + public static Half Floor(Half x); + public static Half FusedMultiplyAdd(Half left, Half right, Half addend); + public static Half Hypot(Half x, Half y); + public static Half Ieee754Remainder(Half left, Half right); + public static int ILogB(Half x); + public static bool IsEvenInteger(Half value); + public static bool IsInteger(Half value); + public static bool IsOddInteger(Half value); + public static bool IsPositive(Half value); + public static bool IsPow2(Half value); + public static bool IsRealNumber(Half value); + public static Half Log(Half x); + public static Half Log(Half x, Half newBase); + public static Half Log10(Half x); + public static Half Log10P1(Half x); + public static Half Log2(Half value); + public static Half Log2P1(Half x); + public static Half LogP1(Half x); + public static Half Max(Half x, Half y); + public static Half MaxMagnitude(Half x, Half y); + public static Half MaxMagnitudeNumber(Half x, Half y); + public static Half MaxNumber(Half x, Half y); + public static Half Min(Half x, Half y); + public static Half MinMagnitude(Half x, Half y); + public static Half MinMagnitudeNumber(Half x, Half y); + public static Half MinNumber(Half x, Half y); + public static Half operator +(Half left, Half right); + public static explicit operator checked byte (Half value); + public static explicit operator checked char (Half value); + public static explicit operator checked short (Half value); + public static explicit operator checked int (Half value); + public static explicit operator checked long (Half value); + public static explicit operator checked Int128 (Half value); + public static explicit operator checked IntPtr (Half value); + public static explicit operator checked sbyte (Half value); + public static explicit operator checked ushort (Half value); + public static explicit operator checked uint (Half value); + public static explicit operator checked ulong (Half value); + public static explicit operator checked UInt128 (Half value); + public static explicit operator checked UIntPtr (Half value); + public static Half operator --(Half value); + public static Half operator /(Half left, Half right); + public static explicit operator Half (char value); + public static explicit operator Half (decimal value); + public static explicit operator byte (Half value); + public static explicit operator char (Half value); + public static explicit operator decimal (Half value); + public static explicit operator Int128 (Half value); + public static explicit operator short (Half value); + public static explicit operator int (Half value); + public static explicit operator long (Half value); + public static explicit operator IntPtr (Half value); + public static explicit operator sbyte (Half value); + public static explicit operator UInt128 (Half value); + public static explicit operator ushort (Half value); + public static explicit operator uint (Half value); + public static explicit operator ulong (Half value); + public static explicit operator UIntPtr (Half value); + public static explicit operator Half (short value); + public static explicit operator Half (int value); + public static explicit operator Half (long value); + public static explicit operator Half (IntPtr value); + public static explicit operator Half (ushort value); + public static explicit operator Half (uint value); + public static explicit operator Half (ulong value); + public static explicit operator Half (UIntPtr value); + public static implicit operator Half (byte value); + public static implicit operator Half (sbyte value); + public static Half operator ++(Half value); + public static Half operator %(Half left, Half right); + public static Half operator *(Half left, Half right); + public static Half operator -(Half left, Half right); + public static Half operator -(Half value); + public static Half operator +(Half value); + public static Half Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Half Pow(Half x, Half y); + public static Half ReciprocalEstimate(Half x); + public static Half ReciprocalSqrtEstimate(Half x); + public static Half RootN(Half x, int n); + public static Half Round(Half x); + public static Half Round(Half x, int digits); + public static Half Round(Half x, int digits, MidpointRounding mode); + public static Half Round(Half x, MidpointRounding mode); + public static Half ScaleB(Half x, int n); + public static int Sign(Half value); + public static Half Sin(Half x); + public static (Half Sin, Half Cos) SinCos(Half x); + public static (Half SinPi, Half CosPi) SinCosPi(Half x); + public static Half Sinh(Half x); + public static Half SinPi(Half x); + public static Half Sqrt(Half x); + static Half IBitwiseOperators<Half, Half, Half>.operator &(Half left, Half right); + static Half IBitwiseOperators<Half, Half, Half>.operator |(Half left, Half right); + static Half IBitwiseOperators<Half, Half, Half>.operator ^(Half left, Half right); + static Half IBitwiseOperators<Half, Half, Half>.operator ~(Half value); + int IFloatingPoint<Half>.GetExponentByteCount(); + int IFloatingPoint<Half>.GetExponentShortestBitLength(); + int IFloatingPoint<Half>.GetSignificandBitLength(); + int IFloatingPoint<Half>.GetSignificandByteCount(); + bool IFloatingPoint<Half>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<Half>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<Half>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<Half>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static bool INumberBase<Half>.IsCanonical(Half value); + static bool INumberBase<Half>.IsComplexNumber(Half value); + static bool INumberBase<Half>.IsImaginaryNumber(Half value); + static bool INumberBase<Half>.IsZero(Half value); + static bool INumberBase<Half>.TryConvertFromChecked<TOther>(TOther value, out Half result); + static bool INumberBase<Half>.TryConvertFromSaturating<TOther>(TOther value, out Half result); + static bool INumberBase<Half>.TryConvertFromTruncating<TOther>(TOther value, out Half result); + static bool INumberBase<Half>.TryConvertToChecked<TOther>(Half value, out TOther result); + static bool INumberBase<Half>.TryConvertToSaturating<TOther>(Half value, out TOther result); + static bool INumberBase<Half>.TryConvertToTruncating<TOther>(Half value, out TOther result); + public static Half Tan(Half x); + public static Half Tanh(Half x); + public static Half TanPi(Half x); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static Half Truncate(Half x); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Half result); + public static bool TryParse(string? s, IFormatProvider? provider, out Half result); } + public readonly struct Int128 : IAdditionOperators<Int128, Int128, Int128>, IAdditiveIdentity<Int128, Int128>, IBinaryInteger<Int128>, IBinaryNumber<Int128>, IBitwiseOperators<Int128, Int128, Int128>, IComparable, IComparable<Int128>, IComparisonOperators<Int128, Int128, bool>, IDecrementOperators<Int128>, IDivisionOperators<Int128, Int128, Int128>, IEqualityOperators<Int128, Int128, bool>, IEquatable<Int128>, IFormattable, IIncrementOperators<Int128>, IMinMaxValue<Int128>, IModulusOperators<Int128, Int128, Int128>, IMultiplicativeIdentity<Int128, Int128>, IMultiplyOperators<Int128, Int128, Int128>, INumber<Int128>, INumberBase<Int128>, IParsable<Int128>, IShiftOperators<Int128, int, Int128>, ISignedNumber<Int128>, ISpanFormattable, ISpanParsable<Int128>, ISubtractionOperators<Int128, Int128, Int128>, IUnaryNegationOperators<Int128, Int128>, IUnaryPlusOperators<Int128, Int128> { + public Int128(ulong upper, ulong lower); + public static Int128 MaxValue { get; } + public static Int128 MinValue { get; } + public static Int128 NegativeOne { get; } + public static Int128 One { get; } + static Int128 System.Numerics.IAdditiveIdentity<System.Int128,System.Int128>.AdditiveIdentity { get; } + static Int128 System.Numerics.IBinaryNumber<System.Int128>.AllBitsSet { get; } + static Int128 System.Numerics.IMultiplicativeIdentity<System.Int128,System.Int128>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.Int128>.Radix { get; } + public static Int128 Zero { get; } + public static Int128 Abs(Int128 value); + public static Int128 Clamp(Int128 value, Int128 min, Int128 max); + public int CompareTo(Int128 value); + public int CompareTo(object? value); + public static Int128 CopySign(Int128 value, Int128 sign); + public static Int128 CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Int128 CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static Int128 CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (Int128 Quotient, Int128 Remainder) DivRem(Int128 left, Int128 right); + public bool Equals(Int128 other); + public override bool Equals(object? obj); + public override int GetHashCode(); + public static bool IsEvenInteger(Int128 value); + public static bool IsNegative(Int128 value); + public static bool IsOddInteger(Int128 value); + public static bool IsPositive(Int128 value); + public static bool IsPow2(Int128 value); + public static Int128 LeadingZeroCount(Int128 value); + public static Int128 Log2(Int128 value); + public static Int128 Max(Int128 x, Int128 y); + public static Int128 MaxMagnitude(Int128 x, Int128 y); + public static Int128 Min(Int128 x, Int128 y); + public static Int128 MinMagnitude(Int128 x, Int128 y); + public static Int128 operator +(Int128 left, Int128 right); + public static Int128 operator &(Int128 left, Int128 right); + public static Int128 operator |(Int128 left, Int128 right); + public static Int128 operator checked +(Int128 left, Int128 right); + public static Int128 operator checked --(Int128 value); + public static Int128 operator checked /(Int128 left, Int128 right); + public static explicit operator checked Int128 (double value); + public static explicit operator checked byte (Int128 value); + public static explicit operator checked char (Int128 value); + public static explicit operator checked short (Int128 value); + public static explicit operator checked int (Int128 value); + public static explicit operator checked long (Int128 value); + public static explicit operator checked IntPtr (Int128 value); + public static explicit operator checked sbyte (Int128 value); + public static explicit operator checked ushort (Int128 value); + public static explicit operator checked uint (Int128 value); + public static explicit operator checked ulong (Int128 value); + public static explicit operator checked UInt128 (Int128 value); + public static explicit operator checked UIntPtr (Int128 value); + public static explicit operator checked Int128 (float value); + public static Int128 operator checked ++(Int128 value); + public static Int128 operator checked *(Int128 left, Int128 right); + public static Int128 operator checked -(Int128 left, Int128 right); + public static Int128 operator checked -(Int128 value); + public static Int128 operator --(Int128 value); + public static Int128 operator /(Int128 left, Int128 right); + public static bool operator ==(Int128 left, Int128 right); + public static Int128 operator ^(Int128 left, Int128 right); + public static explicit operator Int128 (decimal value); + public static explicit operator Int128 (double value); + public static explicit operator byte (Int128 value); + public static explicit operator char (Int128 value); + public static explicit operator decimal (Int128 value); + public static explicit operator double (Int128 value); + public static explicit operator Half (Int128 value); + public static explicit operator short (Int128 value); + public static explicit operator int (Int128 value); + public static explicit operator long (Int128 value); + public static explicit operator IntPtr (Int128 value); + public static explicit operator sbyte (Int128 value); + public static explicit operator float (Int128 value); + public static explicit operator UInt128 (Int128 value); + public static explicit operator ushort (Int128 value); + public static explicit operator uint (Int128 value); + public static explicit operator ulong (Int128 value); + public static explicit operator UIntPtr (Int128 value); + public static explicit operator Int128 (float value); + public static bool operator >(Int128 left, Int128 right); + public static bool operator >=(Int128 left, Int128 right); + public static implicit operator Int128 (byte value); + public static implicit operator Int128 (char value); + public static implicit operator Int128 (short value); + public static implicit operator Int128 (int value); + public static implicit operator Int128 (long value); + public static implicit operator Int128 (IntPtr value); + public static implicit operator Int128 (sbyte value); + public static implicit operator Int128 (ushort value); + public static implicit operator Int128 (uint value); + public static implicit operator Int128 (ulong value); + public static implicit operator Int128 (UIntPtr value); + public static Int128 operator ++(Int128 value); + public static bool operator !=(Int128 left, Int128 right); + public static Int128 operator <<(Int128 value, int shiftAmount); + public static bool operator <(Int128 left, Int128 right); + public static bool operator <=(Int128 left, Int128 right); + public static Int128 operator %(Int128 left, Int128 right); + public static Int128 operator *(Int128 left, Int128 right); + public static Int128 operator ~(Int128 value); + public static Int128 operator >>(Int128 value, int shiftAmount); + public static Int128 operator -(Int128 left, Int128 right); + public static Int128 operator -(Int128 value); + public static Int128 operator +(Int128 value); + public static Int128 operator >>>(Int128 value, int shiftAmount); + public static Int128 Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null); + public static Int128 Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static Int128 Parse(string s); + public static Int128 Parse(string s, NumberStyles style); + public static Int128 Parse(string s, NumberStyles style, IFormatProvider? provider); + public static Int128 Parse(string s, IFormatProvider? provider); + public static Int128 PopCount(Int128 value); + public static Int128 RotateLeft(Int128 value, int rotateAmount); + public static Int128 RotateRight(Int128 value, int rotateAmount); + public static int Sign(Int128 value); + int IBinaryInteger<Int128>.GetByteCount(); + int IBinaryInteger<Int128>.GetShortestBitLength(); + static bool IBinaryInteger<Int128>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out Int128 value); + static bool IBinaryInteger<Int128>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out Int128 value); + bool IBinaryInteger<Int128>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<Int128>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static Int128 INumber<Int128>.MaxNumber(Int128 x, Int128 y); + static Int128 INumber<Int128>.MinNumber(Int128 x, Int128 y); + static bool INumberBase<Int128>.IsCanonical(Int128 value); + static bool INumberBase<Int128>.IsComplexNumber(Int128 value); + static bool INumberBase<Int128>.IsFinite(Int128 value); + static bool INumberBase<Int128>.IsImaginaryNumber(Int128 value); + static bool INumberBase<Int128>.IsInfinity(Int128 value); + static bool INumberBase<Int128>.IsInteger(Int128 value); + static bool INumberBase<Int128>.IsNaN(Int128 value); + static bool INumberBase<Int128>.IsNegativeInfinity(Int128 value); + static bool INumberBase<Int128>.IsNormal(Int128 value); + static bool INumberBase<Int128>.IsPositiveInfinity(Int128 value); + static bool INumberBase<Int128>.IsRealNumber(Int128 value); + static bool INumberBase<Int128>.IsSubnormal(Int128 value); + static bool INumberBase<Int128>.IsZero(Int128 value); + static Int128 INumberBase<Int128>.MaxMagnitudeNumber(Int128 x, Int128 y); + static Int128 INumberBase<Int128>.MinMagnitudeNumber(Int128 x, Int128 y); + static bool INumberBase<Int128>.TryConvertFromChecked<TOther>(TOther value, out Int128 result); + static bool INumberBase<Int128>.TryConvertFromSaturating<TOther>(TOther value, out Int128 result); + static bool INumberBase<Int128>.TryConvertFromTruncating<TOther>(TOther value, out Int128 result); + static bool INumberBase<Int128>.TryConvertToChecked<TOther>(Int128 value, out TOther result); + static bool INumberBase<Int128>.TryConvertToSaturating<TOther>(Int128 value, out TOther result); + static bool INumberBase<Int128>.TryConvertToTruncating<TOther>(Int128 value, out TOther result); + public override string ToString(); + public string ToString(IFormatProvider? provider); + public string ToString(string? format); + public string ToString(string? format, IFormatProvider? provider); + public static Int128 TrailingZeroCount(Int128 value); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out Int128 result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Int128 result); + public static bool TryParse(ReadOnlySpan<char> s, out Int128 result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out Int128 result); + public static bool TryParse(string? s, IFormatProvider? provider, out Int128 result); + public static bool TryParse(string? s, out Int128 result); + } - public readonly struct Int16 : IComparable, IComparable<short>, IConvertible, IEquatable<short>, IFormattable, ISpanFormattable { + public readonly struct Int16 : IAdditionOperators<short, short, short>, IAdditiveIdentity<short, short>, IBinaryInteger<short>, IBinaryNumber<short>, IBitwiseOperators<short, short, short>, IComparable, IComparable<short>, IComparisonOperators<short, short, bool>, IConvertible, IDecrementOperators<short>, IDivisionOperators<short, short, short>, IEqualityOperators<short, short, bool>, IEquatable<short>, IFormattable, IIncrementOperators<short>, IMinMaxValue<short>, IModulusOperators<short, short, short>, IMultiplicativeIdentity<short, short>, IMultiplyOperators<short, short, short>, INumber<short>, INumberBase<short>, IParsable<short>, IShiftOperators<short, int, short>, ISignedNumber<short>, ISpanFormattable, ISpanParsable<short>, ISubtractionOperators<short, short, short>, IUnaryNegationOperators<short, short>, IUnaryPlusOperators<short, short> { + static short System.Numerics.IAdditiveIdentity<System.Int16,System.Int16>.AdditiveIdentity { get; } + static short System.Numerics.IBinaryNumber<System.Int16>.AllBitsSet { get; } + static short System.Numerics.IMinMaxValue<System.Int16>.MaxValue { get; } + static short System.Numerics.IMinMaxValue<System.Int16>.MinValue { get; } + static short System.Numerics.IMultiplicativeIdentity<System.Int16,System.Int16>.MultiplicativeIdentity { get; } + static short System.Numerics.INumberBase<System.Int16>.One { get; } + static int System.Numerics.INumberBase<System.Int16>.Radix { get; } + static short System.Numerics.INumberBase<System.Int16>.Zero { get; } + static short System.Numerics.ISignedNumber<System.Int16>.NegativeOne { get; } + public static short Abs(short value); + public static short Clamp(short value, short min, short max); + public static short CopySign(short value, short sign); + public static short CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static short CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static short CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (short Quotient, short Remainder) DivRem(short left, short right); + public static bool IsEvenInteger(short value); + public static bool IsNegative(short value); + public static bool IsOddInteger(short value); + public static bool IsPositive(short value); + public static bool IsPow2(short value); + public static short LeadingZeroCount(short value); + public static short Log2(short value); + public static short Max(short x, short y); + public static short MaxMagnitude(short x, short y); + public static short Min(short x, short y); + public static short MinMagnitude(short x, short y); + public static short Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static short PopCount(short value); + public static short RotateLeft(short value, int rotateAmount); + public static short RotateRight(short value, int rotateAmount); + public static int Sign(short value); + static short IAdditionOperators<short, short, short>.operator +(short left, short right); + static short IAdditionOperators<short, short, short>.operator checked +(short left, short right); + int IBinaryInteger<short>.GetByteCount(); + int IBinaryInteger<short>.GetShortestBitLength(); + static bool IBinaryInteger<short>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out short value); + static bool IBinaryInteger<short>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out short value); + bool IBinaryInteger<short>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<short>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static short IBitwiseOperators<short, short, short>.operator &(short left, short right); + static short IBitwiseOperators<short, short, short>.operator |(short left, short right); + static short IBitwiseOperators<short, short, short>.operator ^(short left, short right); + static short IBitwiseOperators<short, short, short>.operator ~(short value); + static bool IComparisonOperators<short, short, bool>.operator >(short left, short right); + static bool IComparisonOperators<short, short, bool>.operator >=(short left, short right); + static bool IComparisonOperators<short, short, bool>.operator <(short left, short right); + static bool IComparisonOperators<short, short, bool>.operator <=(short left, short right); + static short IDecrementOperators<short>.operator checked --(short value); + static short IDecrementOperators<short>.operator --(short value); + static short IDivisionOperators<short, short, short>.operator /(short left, short right); + static bool IEqualityOperators<short, short, bool>.operator ==(short left, short right); + static bool IEqualityOperators<short, short, bool>.operator !=(short left, short right); + static short IIncrementOperators<short>.operator checked ++(short value); + static short IIncrementOperators<short>.operator ++(short value); + static short IModulusOperators<short, short, short>.operator %(short left, short right); + static short IMultiplyOperators<short, short, short>.operator checked *(short left, short right); + static short IMultiplyOperators<short, short, short>.operator *(short left, short right); + static short INumber<short>.MaxNumber(short x, short y); + static short INumber<short>.MinNumber(short x, short y); + static bool INumberBase<short>.IsCanonical(short value); + static bool INumberBase<short>.IsComplexNumber(short value); + static bool INumberBase<short>.IsFinite(short value); + static bool INumberBase<short>.IsImaginaryNumber(short value); + static bool INumberBase<short>.IsInfinity(short value); + static bool INumberBase<short>.IsInteger(short value); + static bool INumberBase<short>.IsNaN(short value); + static bool INumberBase<short>.IsNegativeInfinity(short value); + static bool INumberBase<short>.IsNormal(short value); + static bool INumberBase<short>.IsPositiveInfinity(short value); + static bool INumberBase<short>.IsRealNumber(short value); + static bool INumberBase<short>.IsSubnormal(short value); + static bool INumberBase<short>.IsZero(short value); + static short INumberBase<short>.MaxMagnitudeNumber(short x, short y); + static short INumberBase<short>.MinMagnitudeNumber(short x, short y); + static bool INumberBase<short>.TryConvertFromChecked<TOther>(TOther value, out short result); + static bool INumberBase<short>.TryConvertFromSaturating<TOther>(TOther value, out short result); + static bool INumberBase<short>.TryConvertFromTruncating<TOther>(TOther value, out short result); + static bool INumberBase<short>.TryConvertToChecked<TOther>(short value, out TOther result); + static bool INumberBase<short>.TryConvertToSaturating<TOther>(short value, out TOther result); + static bool INumberBase<short>.TryConvertToTruncating<TOther>(short value, out TOther result); + static short IShiftOperators<short, int, short>.operator <<(short value, int shiftAmount); + static short IShiftOperators<short, int, short>.operator >>(short value, int shiftAmount); + static short IShiftOperators<short, int, short>.operator >>>(short value, int shiftAmount); + static short ISubtractionOperators<short, short, short>.operator checked -(short left, short right); + static short ISubtractionOperators<short, short, short>.operator -(short left, short right); + static short IUnaryNegationOperators<short, short>.operator checked -(short value); + static short IUnaryNegationOperators<short, short>.operator -(short value); + static short IUnaryPlusOperators<short, short>.operator +(short value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static short TrailingZeroCount(short value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out short result); + public static bool TryParse(string? s, IFormatProvider? provider, out short result); } - public readonly struct Int32 : IComparable, IComparable<int>, IConvertible, IEquatable<int>, IFormattable, ISpanFormattable { + public readonly struct Int32 : IAdditionOperators<int, int, int>, IAdditiveIdentity<int, int>, IBinaryInteger<int>, IBinaryNumber<int>, IBitwiseOperators<int, int, int>, IComparable, IComparable<int>, IComparisonOperators<int, int, bool>, IConvertible, IDecrementOperators<int>, IDivisionOperators<int, int, int>, IEqualityOperators<int, int, bool>, IEquatable<int>, IFormattable, IIncrementOperators<int>, IMinMaxValue<int>, IModulusOperators<int, int, int>, IMultiplicativeIdentity<int, int>, IMultiplyOperators<int, int, int>, INumber<int>, INumberBase<int>, IParsable<int>, IShiftOperators<int, int, int>, ISignedNumber<int>, ISpanFormattable, ISpanParsable<int>, ISubtractionOperators<int, int, int>, IUnaryNegationOperators<int, int>, IUnaryPlusOperators<int, int> { + static int System.Numerics.IAdditiveIdentity<System.Int32,System.Int32>.AdditiveIdentity { get; } + static int System.Numerics.IBinaryNumber<System.Int32>.AllBitsSet { get; } + static int System.Numerics.IMinMaxValue<System.Int32>.MaxValue { get; } + static int System.Numerics.IMinMaxValue<System.Int32>.MinValue { get; } + static int System.Numerics.IMultiplicativeIdentity<System.Int32,System.Int32>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.Int32>.One { get; } + static int System.Numerics.INumberBase<System.Int32>.Radix { get; } + static int System.Numerics.INumberBase<System.Int32>.Zero { get; } + static int System.Numerics.ISignedNumber<System.Int32>.NegativeOne { get; } + public static int Abs(int value); + public static int Clamp(int value, int min, int max); + public static int CopySign(int value, int sign); + public static int CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static int CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static int CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (int Quotient, int Remainder) DivRem(int left, int right); + public static bool IsEvenInteger(int value); + public static bool IsNegative(int value); + public static bool IsOddInteger(int value); + public static bool IsPositive(int value); + public static bool IsPow2(int value); + public static int LeadingZeroCount(int value); + public static int Log2(int value); + public static int Max(int x, int y); + public static int MaxMagnitude(int x, int y); + public static int Min(int x, int y); + public static int MinMagnitude(int x, int y); + public static int Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static int PopCount(int value); + public static int RotateLeft(int value, int rotateAmount); + public static int RotateRight(int value, int rotateAmount); + public static int Sign(int value); + static int IAdditionOperators<int, int, int>.operator +(int left, int right); + static int IAdditionOperators<int, int, int>.operator checked +(int left, int right); + int IBinaryInteger<int>.GetByteCount(); + int IBinaryInteger<int>.GetShortestBitLength(); + static bool IBinaryInteger<int>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out int value); + static bool IBinaryInteger<int>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out int value); + bool IBinaryInteger<int>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<int>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static int IBitwiseOperators<int, int, int>.operator &(int left, int right); + static int IBitwiseOperators<int, int, int>.operator |(int left, int right); + static int IBitwiseOperators<int, int, int>.operator ^(int left, int right); + static int IBitwiseOperators<int, int, int>.operator ~(int value); + static bool IComparisonOperators<int, int, bool>.operator >(int left, int right); + static bool IComparisonOperators<int, int, bool>.operator >=(int left, int right); + static bool IComparisonOperators<int, int, bool>.operator <(int left, int right); + static bool IComparisonOperators<int, int, bool>.operator <=(int left, int right); + static int IDecrementOperators<int>.operator checked --(int value); + static int IDecrementOperators<int>.operator --(int value); + static int IDivisionOperators<int, int, int>.operator /(int left, int right); + static bool IEqualityOperators<int, int, bool>.operator ==(int left, int right); + static bool IEqualityOperators<int, int, bool>.operator !=(int left, int right); + static int IIncrementOperators<int>.operator checked ++(int value); + static int IIncrementOperators<int>.operator ++(int value); + static int IModulusOperators<int, int, int>.operator %(int left, int right); + static int IMultiplyOperators<int, int, int>.operator checked *(int left, int right); + static int IMultiplyOperators<int, int, int>.operator *(int left, int right); + static int INumber<int>.MaxNumber(int x, int y); + static int INumber<int>.MinNumber(int x, int y); + static bool INumberBase<int>.IsCanonical(int value); + static bool INumberBase<int>.IsComplexNumber(int value); + static bool INumberBase<int>.IsFinite(int value); + static bool INumberBase<int>.IsImaginaryNumber(int value); + static bool INumberBase<int>.IsInfinity(int value); + static bool INumberBase<int>.IsInteger(int value); + static bool INumberBase<int>.IsNaN(int value); + static bool INumberBase<int>.IsNegativeInfinity(int value); + static bool INumberBase<int>.IsNormal(int value); + static bool INumberBase<int>.IsPositiveInfinity(int value); + static bool INumberBase<int>.IsRealNumber(int value); + static bool INumberBase<int>.IsSubnormal(int value); + static bool INumberBase<int>.IsZero(int value); + static int INumberBase<int>.MaxMagnitudeNumber(int x, int y); + static int INumberBase<int>.MinMagnitudeNumber(int x, int y); + static bool INumberBase<int>.TryConvertFromChecked<TOther>(TOther value, out int result); + static bool INumberBase<int>.TryConvertFromSaturating<TOther>(TOther value, out int result); + static bool INumberBase<int>.TryConvertFromTruncating<TOther>(TOther value, out int result); + static bool INumberBase<int>.TryConvertToChecked<TOther>(int value, out TOther result); + static bool INumberBase<int>.TryConvertToSaturating<TOther>(int value, out TOther result); + static bool INumberBase<int>.TryConvertToTruncating<TOther>(int value, out TOther result); + static int IShiftOperators<int, int, int>.operator <<(int value, int shiftAmount); + static int IShiftOperators<int, int, int>.operator >>(int value, int shiftAmount); + static int IShiftOperators<int, int, int>.operator >>>(int value, int shiftAmount); + static int ISubtractionOperators<int, int, int>.operator checked -(int left, int right); + static int ISubtractionOperators<int, int, int>.operator -(int left, int right); + static int IUnaryNegationOperators<int, int>.operator checked -(int value); + static int IUnaryNegationOperators<int, int>.operator -(int value); + static int IUnaryPlusOperators<int, int>.operator +(int value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static int TrailingZeroCount(int value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out int result); + public static bool TryParse(string? s, IFormatProvider? provider, out int result); } - public readonly struct Int64 : IComparable, IComparable<long>, IConvertible, IEquatable<long>, IFormattable, ISpanFormattable { + public readonly struct Int64 : IAdditionOperators<long, long, long>, IAdditiveIdentity<long, long>, IBinaryInteger<long>, IBinaryNumber<long>, IBitwiseOperators<long, long, long>, IComparable, IComparable<long>, IComparisonOperators<long, long, bool>, IConvertible, IDecrementOperators<long>, IDivisionOperators<long, long, long>, IEqualityOperators<long, long, bool>, IEquatable<long>, IFormattable, IIncrementOperators<long>, IMinMaxValue<long>, IModulusOperators<long, long, long>, IMultiplicativeIdentity<long, long>, IMultiplyOperators<long, long, long>, INumber<long>, INumberBase<long>, IParsable<long>, IShiftOperators<long, int, long>, ISignedNumber<long>, ISpanFormattable, ISpanParsable<long>, ISubtractionOperators<long, long, long>, IUnaryNegationOperators<long, long>, IUnaryPlusOperators<long, long> { + static long System.Numerics.IAdditiveIdentity<System.Int64,System.Int64>.AdditiveIdentity { get; } + static long System.Numerics.IBinaryNumber<System.Int64>.AllBitsSet { get; } + static long System.Numerics.IMinMaxValue<System.Int64>.MaxValue { get; } + static long System.Numerics.IMinMaxValue<System.Int64>.MinValue { get; } + static long System.Numerics.IMultiplicativeIdentity<System.Int64,System.Int64>.MultiplicativeIdentity { get; } + static long System.Numerics.INumberBase<System.Int64>.One { get; } + static int System.Numerics.INumberBase<System.Int64>.Radix { get; } + static long System.Numerics.INumberBase<System.Int64>.Zero { get; } + static long System.Numerics.ISignedNumber<System.Int64>.NegativeOne { get; } + public static long Abs(long value); + public static long Clamp(long value, long min, long max); + public static long CopySign(long value, long sign); + public static long CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static long CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static long CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (long Quotient, long Remainder) DivRem(long left, long right); + public static bool IsEvenInteger(long value); + public static bool IsNegative(long value); + public static bool IsOddInteger(long value); + public static bool IsPositive(long value); + public static bool IsPow2(long value); + public static long LeadingZeroCount(long value); + public static long Log2(long value); + public static long Max(long x, long y); + public static long MaxMagnitude(long x, long y); + public static long Min(long x, long y); + public static long MinMagnitude(long x, long y); + public static long Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static long PopCount(long value); + public static long RotateLeft(long value, int rotateAmount); + public static long RotateRight(long value, int rotateAmount); + public static int Sign(long value); + static long IAdditionOperators<long, long, long>.operator +(long left, long right); + static long IAdditionOperators<long, long, long>.operator checked +(long left, long right); + int IBinaryInteger<long>.GetByteCount(); + int IBinaryInteger<long>.GetShortestBitLength(); + static bool IBinaryInteger<long>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out long value); + static bool IBinaryInteger<long>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out long value); + bool IBinaryInteger<long>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<long>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static long IBitwiseOperators<long, long, long>.operator &(long left, long right); + static long IBitwiseOperators<long, long, long>.operator |(long left, long right); + static long IBitwiseOperators<long, long, long>.operator ^(long left, long right); + static long IBitwiseOperators<long, long, long>.operator ~(long value); + static bool IComparisonOperators<long, long, bool>.operator >(long left, long right); + static bool IComparisonOperators<long, long, bool>.operator >=(long left, long right); + static bool IComparisonOperators<long, long, bool>.operator <(long left, long right); + static bool IComparisonOperators<long, long, bool>.operator <=(long left, long right); + static long IDecrementOperators<long>.operator checked --(long value); + static long IDecrementOperators<long>.operator --(long value); + static long IDivisionOperators<long, long, long>.operator /(long left, long right); + static bool IEqualityOperators<long, long, bool>.operator ==(long left, long right); + static bool IEqualityOperators<long, long, bool>.operator !=(long left, long right); + static long IIncrementOperators<long>.operator checked ++(long value); + static long IIncrementOperators<long>.operator ++(long value); + static long IModulusOperators<long, long, long>.operator %(long left, long right); + static long IMultiplyOperators<long, long, long>.operator checked *(long left, long right); + static long IMultiplyOperators<long, long, long>.operator *(long left, long right); + static long INumber<long>.MaxNumber(long x, long y); + static long INumber<long>.MinNumber(long x, long y); + static bool INumberBase<long>.IsCanonical(long value); + static bool INumberBase<long>.IsComplexNumber(long value); + static bool INumberBase<long>.IsFinite(long value); + static bool INumberBase<long>.IsImaginaryNumber(long value); + static bool INumberBase<long>.IsInfinity(long value); + static bool INumberBase<long>.IsInteger(long value); + static bool INumberBase<long>.IsNaN(long value); + static bool INumberBase<long>.IsNegativeInfinity(long value); + static bool INumberBase<long>.IsNormal(long value); + static bool INumberBase<long>.IsPositiveInfinity(long value); + static bool INumberBase<long>.IsRealNumber(long value); + static bool INumberBase<long>.IsSubnormal(long value); + static bool INumberBase<long>.IsZero(long value); + static long INumberBase<long>.MaxMagnitudeNumber(long x, long y); + static long INumberBase<long>.MinMagnitudeNumber(long x, long y); + static bool INumberBase<long>.TryConvertFromChecked<TOther>(TOther value, out long result); + static bool INumberBase<long>.TryConvertFromSaturating<TOther>(TOther value, out long result); + static bool INumberBase<long>.TryConvertFromTruncating<TOther>(TOther value, out long result); + static bool INumberBase<long>.TryConvertToChecked<TOther>(long value, out TOther result); + static bool INumberBase<long>.TryConvertToSaturating<TOther>(long value, out TOther result); + static bool INumberBase<long>.TryConvertToTruncating<TOther>(long value, out TOther result); + static long IShiftOperators<long, int, long>.operator <<(long value, int shiftAmount); + static long IShiftOperators<long, int, long>.operator >>(long value, int shiftAmount); + static long IShiftOperators<long, int, long>.operator >>>(long value, int shiftAmount); + static long ISubtractionOperators<long, long, long>.operator checked -(long left, long right); + static long ISubtractionOperators<long, long, long>.operator -(long left, long right); + static long IUnaryNegationOperators<long, long>.operator checked -(long value); + static long IUnaryNegationOperators<long, long>.operator -(long value); + static long IUnaryPlusOperators<long, long>.operator +(long value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static long TrailingZeroCount(long value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out long result); + public static bool TryParse(string? s, IFormatProvider? provider, out long result); } - public readonly struct IntPtr : IComparable, IComparable<IntPtr>, IEquatable<IntPtr>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct IntPtr : IAdditionOperators<IntPtr, IntPtr, IntPtr>, IAdditiveIdentity<IntPtr, IntPtr>, IBinaryInteger<IntPtr>, IBinaryNumber<IntPtr>, IBitwiseOperators<IntPtr, IntPtr, IntPtr>, IComparable, IComparable<IntPtr>, IComparisonOperators<IntPtr, IntPtr, bool>, IDecrementOperators<IntPtr>, IDivisionOperators<IntPtr, IntPtr, IntPtr>, IEqualityOperators<IntPtr, IntPtr, bool>, IEquatable<IntPtr>, IFormattable, IIncrementOperators<IntPtr>, IMinMaxValue<IntPtr>, IModulusOperators<IntPtr, IntPtr, IntPtr>, IMultiplicativeIdentity<IntPtr, IntPtr>, IMultiplyOperators<IntPtr, IntPtr, IntPtr>, INumber<IntPtr>, INumberBase<IntPtr>, IParsable<IntPtr>, ISerializable, IShiftOperators<IntPtr, int, IntPtr>, ISignedNumber<IntPtr>, ISpanFormattable, ISpanParsable<IntPtr>, ISubtractionOperators<IntPtr, IntPtr, IntPtr>, IUnaryNegationOperators<IntPtr, IntPtr>, IUnaryPlusOperators<IntPtr, IntPtr> { + static IntPtr System.Numerics.IAdditiveIdentity<nint,nint>.AdditiveIdentity { get; } + static IntPtr System.Numerics.IBinaryNumber<nint>.AllBitsSet { get; } + static IntPtr System.Numerics.IMinMaxValue<nint>.MaxValue { get; } + static IntPtr System.Numerics.IMinMaxValue<nint>.MinValue { get; } + static IntPtr System.Numerics.IMultiplicativeIdentity<nint,nint>.MultiplicativeIdentity { get; } + static IntPtr System.Numerics.INumberBase<nint>.One { get; } + static int System.Numerics.INumberBase<nint>.Radix { get; } + static IntPtr System.Numerics.INumberBase<nint>.Zero { get; } + static IntPtr System.Numerics.ISignedNumber<nint>.NegativeOne { get; } + public static IntPtr Abs(IntPtr value); + public static IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max); + public static IntPtr CopySign(IntPtr value, IntPtr sign); + public static IntPtr CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static IntPtr CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static IntPtr CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (IntPtr Quotient, IntPtr Remainder) DivRem(IntPtr left, IntPtr right); + public static bool IsEvenInteger(IntPtr value); + public static bool IsNegative(IntPtr value); + public static bool IsOddInteger(IntPtr value); + public static bool IsPositive(IntPtr value); + public static bool IsPow2(IntPtr value); + public static IntPtr LeadingZeroCount(IntPtr value); + public static IntPtr Log2(IntPtr value); + public static IntPtr Max(IntPtr x, IntPtr y); + public static IntPtr MaxMagnitude(IntPtr x, IntPtr y); + public static IntPtr Min(IntPtr x, IntPtr y); + public static IntPtr MinMagnitude(IntPtr x, IntPtr y); + public static IntPtr Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static IntPtr PopCount(IntPtr value); + public static IntPtr RotateLeft(IntPtr value, int rotateAmount); + public static IntPtr RotateRight(IntPtr value, int rotateAmount); + public static int Sign(IntPtr value); + static IntPtr IAdditionOperators<IntPtr, IntPtr, IntPtr>.operator +(IntPtr left, IntPtr right); + static IntPtr IAdditionOperators<IntPtr, IntPtr, IntPtr>.operator checked +(IntPtr left, IntPtr right); + int IBinaryInteger<IntPtr>.GetByteCount(); + int IBinaryInteger<IntPtr>.GetShortestBitLength(); + static bool IBinaryInteger<IntPtr>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out IntPtr value); + static bool IBinaryInteger<IntPtr>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out IntPtr value); + bool IBinaryInteger<IntPtr>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<IntPtr>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator &(IntPtr left, IntPtr right); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator |(IntPtr left, IntPtr right); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator ^(IntPtr left, IntPtr right); + static IntPtr IBitwiseOperators<IntPtr, IntPtr, IntPtr>.operator ~(IntPtr value); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator >(IntPtr left, IntPtr right); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator >=(IntPtr left, IntPtr right); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator <(IntPtr left, IntPtr right); + static bool IComparisonOperators<IntPtr, IntPtr, bool>.operator <=(IntPtr left, IntPtr right); + static IntPtr IDecrementOperators<IntPtr>.operator checked --(IntPtr value); + static IntPtr IDecrementOperators<IntPtr>.operator --(IntPtr value); + static IntPtr IDivisionOperators<IntPtr, IntPtr, IntPtr>.operator /(IntPtr left, IntPtr right); + static IntPtr IIncrementOperators<IntPtr>.operator checked ++(IntPtr value); + static IntPtr IIncrementOperators<IntPtr>.operator ++(IntPtr value); + static IntPtr IModulusOperators<IntPtr, IntPtr, IntPtr>.operator %(IntPtr left, IntPtr right); + static IntPtr IMultiplyOperators<IntPtr, IntPtr, IntPtr>.operator checked *(IntPtr left, IntPtr right); + static IntPtr IMultiplyOperators<IntPtr, IntPtr, IntPtr>.operator *(IntPtr left, IntPtr right); + static IntPtr INumber<IntPtr>.MaxNumber(IntPtr x, IntPtr y); + static IntPtr INumber<IntPtr>.MinNumber(IntPtr x, IntPtr y); + static bool INumberBase<IntPtr>.IsCanonical(IntPtr value); + static bool INumberBase<IntPtr>.IsComplexNumber(IntPtr value); + static bool INumberBase<IntPtr>.IsFinite(IntPtr value); + static bool INumberBase<IntPtr>.IsImaginaryNumber(IntPtr value); + static bool INumberBase<IntPtr>.IsInfinity(IntPtr value); + static bool INumberBase<IntPtr>.IsInteger(IntPtr value); + static bool INumberBase<IntPtr>.IsNaN(IntPtr value); + static bool INumberBase<IntPtr>.IsNegativeInfinity(IntPtr value); + static bool INumberBase<IntPtr>.IsNormal(IntPtr value); + static bool INumberBase<IntPtr>.IsPositiveInfinity(IntPtr value); + static bool INumberBase<IntPtr>.IsRealNumber(IntPtr value); + static bool INumberBase<IntPtr>.IsSubnormal(IntPtr value); + static bool INumberBase<IntPtr>.IsZero(IntPtr value); + static IntPtr INumberBase<IntPtr>.MaxMagnitudeNumber(IntPtr x, IntPtr y); + static IntPtr INumberBase<IntPtr>.MinMagnitudeNumber(IntPtr x, IntPtr y); + static bool INumberBase<IntPtr>.TryConvertFromChecked<TOther>(TOther value, out IntPtr result); + static bool INumberBase<IntPtr>.TryConvertFromSaturating<TOther>(TOther value, out IntPtr result); + static bool INumberBase<IntPtr>.TryConvertFromTruncating<TOther>(TOther value, out IntPtr result); + static bool INumberBase<IntPtr>.TryConvertToChecked<TOther>(IntPtr value, out TOther result); + static bool INumberBase<IntPtr>.TryConvertToSaturating<TOther>(IntPtr value, out TOther result); + static bool INumberBase<IntPtr>.TryConvertToTruncating<TOther>(IntPtr value, out TOther result); + static IntPtr IShiftOperators<IntPtr, int, IntPtr>.operator <<(IntPtr value, int shiftAmount); + static IntPtr IShiftOperators<IntPtr, int, IntPtr>.operator >>(IntPtr value, int shiftAmount); + static IntPtr IShiftOperators<IntPtr, int, IntPtr>.operator >>>(IntPtr value, int shiftAmount); + static IntPtr ISubtractionOperators<IntPtr, IntPtr, IntPtr>.operator checked -(IntPtr left, IntPtr right); + static IntPtr ISubtractionOperators<IntPtr, IntPtr, IntPtr>.operator -(IntPtr left, IntPtr right); + static IntPtr IUnaryNegationOperators<IntPtr, IntPtr>.operator checked -(IntPtr value); + static IntPtr IUnaryNegationOperators<IntPtr, IntPtr>.operator -(IntPtr value); + static IntPtr IUnaryPlusOperators<IntPtr, IntPtr>.operator +(IntPtr value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static IntPtr TrailingZeroCount(IntPtr value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out IntPtr result); + public static bool TryParse(string? s, IFormatProvider? provider, out IntPtr result); } + public interface IParsable<TSelf> where TSelf : IParsable<TSelf>? { + static abstract TSelf Parse(string s, IFormatProvider? provider); + static abstract bool TryParse(string? s, IFormatProvider? provider, out TSelf result); + } + public interface ISpanParsable<TSelf> : IParsable<TSelf> where TSelf : ISpanParsable<TSelf>? { + static abstract TSelf Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + static abstract bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TSelf result); + } public static class MemoryExtensions { + public static int CommonPrefixLength<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other); + public static int CommonPrefixLength<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other, IEqualityComparer<T>? comparer); + public static int CommonPrefixLength<T>(this Span<T> span, ReadOnlySpan<T> other); + public static int CommonPrefixLength<T>(this Span<T> span, ReadOnlySpan<T> other, IEqualityComparer<T>? comparer); - public static bool Contains<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>; + public static bool Contains<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; - public static bool Contains<T>(this Span<T> span, T value) where T : IEquatable<T>; + public static bool Contains<T>(this Span<T> span, T value) where T : IEquatable<T>?; - public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>; + public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; - public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>; + public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>; + public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>; + public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, T value) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int IndexOfAnyExcept<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; - public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T?>; - public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>; + public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; - public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>; + public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>?; + public static int LastIndexOfAnyExcept<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>?; - public static int SequenceCompareTo<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IComparable<T>; + public static int SequenceCompareTo<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IComparable<T>?; - public static int SequenceCompareTo<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IComparable<T>; + public static int SequenceCompareTo<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IComparable<T>?; - public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>; + public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>?; - public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>; + public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>?; - public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>; + public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>?; - public static Memory<T> Trim<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Memory<T> Trim<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Memory<T> Trim<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>; + public static Memory<T> Trim<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>; + public static ReadOnlyMemory<T> Trim<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>; + public static ReadOnlySpan<T> Trim<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>?; - public static Span<T> Trim<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Span<T> Trim<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Span<T> Trim<T>(this Span<T> span, T trimElement) where T : IEquatable<T>; + public static Span<T> Trim<T>(this Span<T> span, T trimElement) where T : IEquatable<T>?; - public static Memory<T> TrimEnd<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Memory<T> TrimEnd<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Memory<T> TrimEnd<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>; + public static Memory<T> TrimEnd<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimEnd<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimEnd<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>?; - public static Span<T> TrimEnd<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Span<T> TrimEnd<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Span<T> TrimEnd<T>(this Span<T> span, T trimElement) where T : IEquatable<T>; + public static Span<T> TrimEnd<T>(this Span<T> span, T trimElement) where T : IEquatable<T>?; - public static Memory<T> TrimStart<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Memory<T> TrimStart<T>(this Memory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Memory<T> TrimStart<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>; + public static Memory<T> TrimStart<T>(this Memory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>; + public static ReadOnlyMemory<T> TrimStart<T>(this ReadOnlyMemory<T> memory, T trimElement) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>; + public static ReadOnlySpan<T> TrimStart<T>(this ReadOnlySpan<T> span, T trimElement) where T : IEquatable<T>?; - public static Span<T> TrimStart<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>; + public static Span<T> TrimStart<T>(this Span<T> span, ReadOnlySpan<T> trimElements) where T : IEquatable<T>?; - public static Span<T> TrimStart<T>(this Span<T> span, T trimElement) where T : IEquatable<T>; + public static Span<T> TrimStart<T>(this Span<T> span, T trimElement) where T : IEquatable<T>?; } - public struct ModuleHandle + public struct ModuleHandle : IEquatable<ModuleHandle> public static class Nullable { + public static ref readonly T GetValueRefOrDefaultRef<T>(in T? nullable) where T : struct; } public class ObjectDisposedException : InvalidOperationException { + public static void ThrowIf(bool condition, object instance); + public static void ThrowIf(bool condition, Type type); } public readonly ref struct ReadOnlySpan<T> { + public ReadOnlySpan(in T reference); } - public struct RuntimeFieldHandle : ISerializable { + public struct RuntimeFieldHandle : IEquatable<RuntimeFieldHandle>, ISerializable { + public static RuntimeFieldHandle FromIntPtr(IntPtr value); + public static IntPtr ToIntPtr(RuntimeFieldHandle value); } - public struct RuntimeMethodHandle : ISerializable { + public struct RuntimeMethodHandle : IEquatable<RuntimeMethodHandle>, ISerializable { + public static RuntimeMethodHandle FromIntPtr(IntPtr value); + public static IntPtr ToIntPtr(RuntimeMethodHandle value); } - public struct RuntimeTypeHandle : ISerializable { + public struct RuntimeTypeHandle : IEquatable<RuntimeTypeHandle>, ISerializable { + public static RuntimeTypeHandle FromIntPtr(IntPtr value); + public static IntPtr ToIntPtr(RuntimeTypeHandle value); } - public readonly struct SByte : IComparable, IComparable<sbyte>, IConvertible, IEquatable<sbyte>, IFormattable, ISpanFormattable { + public readonly struct SByte : IAdditionOperators<sbyte, sbyte, sbyte>, IAdditiveIdentity<sbyte, sbyte>, IBinaryInteger<sbyte>, IBinaryNumber<sbyte>, IBitwiseOperators<sbyte, sbyte, sbyte>, IComparable, IComparable<sbyte>, IComparisonOperators<sbyte, sbyte, bool>, IConvertible, IDecrementOperators<sbyte>, IDivisionOperators<sbyte, sbyte, sbyte>, IEqualityOperators<sbyte, sbyte, bool>, IEquatable<sbyte>, IFormattable, IIncrementOperators<sbyte>, IMinMaxValue<sbyte>, IModulusOperators<sbyte, sbyte, sbyte>, IMultiplicativeIdentity<sbyte, sbyte>, IMultiplyOperators<sbyte, sbyte, sbyte>, INumber<sbyte>, INumberBase<sbyte>, IParsable<sbyte>, IShiftOperators<sbyte, int, sbyte>, ISignedNumber<sbyte>, ISpanFormattable, ISpanParsable<sbyte>, ISubtractionOperators<sbyte, sbyte, sbyte>, IUnaryNegationOperators<sbyte, sbyte>, IUnaryPlusOperators<sbyte, sbyte> { + static sbyte System.Numerics.IAdditiveIdentity<System.SByte,System.SByte>.AdditiveIdentity { get; } + static sbyte System.Numerics.IBinaryNumber<System.SByte>.AllBitsSet { get; } + static sbyte System.Numerics.IMinMaxValue<System.SByte>.MaxValue { get; } + static sbyte System.Numerics.IMinMaxValue<System.SByte>.MinValue { get; } + static sbyte System.Numerics.IMultiplicativeIdentity<System.SByte,System.SByte>.MultiplicativeIdentity { get; } + static sbyte System.Numerics.INumberBase<System.SByte>.One { get; } + static int System.Numerics.INumberBase<System.SByte>.Radix { get; } + static sbyte System.Numerics.INumberBase<System.SByte>.Zero { get; } + static sbyte System.Numerics.ISignedNumber<System.SByte>.NegativeOne { get; } + public static sbyte Abs(sbyte value); + public static sbyte Clamp(sbyte value, sbyte min, sbyte max); + public static sbyte CopySign(sbyte value, sbyte sign); + public static sbyte CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static sbyte CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static sbyte CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (sbyte Quotient, sbyte Remainder) DivRem(sbyte left, sbyte right); + public static bool IsEvenInteger(sbyte value); + public static bool IsNegative(sbyte value); + public static bool IsOddInteger(sbyte value); + public static bool IsPositive(sbyte value); + public static bool IsPow2(sbyte value); + public static sbyte LeadingZeroCount(sbyte value); + public static sbyte Log2(sbyte value); + public static sbyte Max(sbyte x, sbyte y); + public static sbyte MaxMagnitude(sbyte x, sbyte y); + public static sbyte Min(sbyte x, sbyte y); + public static sbyte MinMagnitude(sbyte x, sbyte y); + public static sbyte Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static sbyte PopCount(sbyte value); + public static sbyte RotateLeft(sbyte value, int rotateAmount); + public static sbyte RotateRight(sbyte value, int rotateAmount); + public static int Sign(sbyte value); + static sbyte IAdditionOperators<sbyte, sbyte, sbyte>.operator +(sbyte left, sbyte right); + static sbyte IAdditionOperators<sbyte, sbyte, sbyte>.operator checked +(sbyte left, sbyte right); + int IBinaryInteger<sbyte>.GetByteCount(); + int IBinaryInteger<sbyte>.GetShortestBitLength(); + static bool IBinaryInteger<sbyte>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out sbyte value); + static bool IBinaryInteger<sbyte>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out sbyte value); + bool IBinaryInteger<sbyte>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<sbyte>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator &(sbyte left, sbyte right); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator |(sbyte left, sbyte right); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator ^(sbyte left, sbyte right); + static sbyte IBitwiseOperators<sbyte, sbyte, sbyte>.operator ~(sbyte value); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator >(sbyte left, sbyte right); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator >=(sbyte left, sbyte right); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator <(sbyte left, sbyte right); + static bool IComparisonOperators<sbyte, sbyte, bool>.operator <=(sbyte left, sbyte right); + static sbyte IDecrementOperators<sbyte>.operator checked --(sbyte value); + static sbyte IDecrementOperators<sbyte>.operator --(sbyte value); + static sbyte IDivisionOperators<sbyte, sbyte, sbyte>.operator /(sbyte left, sbyte right); + static bool IEqualityOperators<sbyte, sbyte, bool>.operator ==(sbyte left, sbyte right); + static bool IEqualityOperators<sbyte, sbyte, bool>.operator !=(sbyte left, sbyte right); + static sbyte IIncrementOperators<sbyte>.operator checked ++(sbyte value); + static sbyte IIncrementOperators<sbyte>.operator ++(sbyte value); + static sbyte IModulusOperators<sbyte, sbyte, sbyte>.operator %(sbyte left, sbyte right); + static sbyte IMultiplyOperators<sbyte, sbyte, sbyte>.operator checked *(sbyte left, sbyte right); + static sbyte IMultiplyOperators<sbyte, sbyte, sbyte>.operator *(sbyte left, sbyte right); + static sbyte INumber<sbyte>.MaxNumber(sbyte x, sbyte y); + static sbyte INumber<sbyte>.MinNumber(sbyte x, sbyte y); + static bool INumberBase<sbyte>.IsCanonical(sbyte value); + static bool INumberBase<sbyte>.IsComplexNumber(sbyte value); + static bool INumberBase<sbyte>.IsFinite(sbyte value); + static bool INumberBase<sbyte>.IsImaginaryNumber(sbyte value); + static bool INumberBase<sbyte>.IsInfinity(sbyte value); + static bool INumberBase<sbyte>.IsInteger(sbyte value); + static bool INumberBase<sbyte>.IsNaN(sbyte value); + static bool INumberBase<sbyte>.IsNegativeInfinity(sbyte value); + static bool INumberBase<sbyte>.IsNormal(sbyte value); + static bool INumberBase<sbyte>.IsPositiveInfinity(sbyte value); + static bool INumberBase<sbyte>.IsRealNumber(sbyte value); + static bool INumberBase<sbyte>.IsSubnormal(sbyte value); + static bool INumberBase<sbyte>.IsZero(sbyte value); + static sbyte INumberBase<sbyte>.MaxMagnitudeNumber(sbyte x, sbyte y); + static sbyte INumberBase<sbyte>.MinMagnitudeNumber(sbyte x, sbyte y); + static bool INumberBase<sbyte>.TryConvertFromChecked<TOther>(TOther value, out sbyte result); + static bool INumberBase<sbyte>.TryConvertFromSaturating<TOther>(TOther value, out sbyte result); + static bool INumberBase<sbyte>.TryConvertFromTruncating<TOther>(TOther value, out sbyte result); + static bool INumberBase<sbyte>.TryConvertToChecked<TOther>(sbyte value, out TOther result); + static bool INumberBase<sbyte>.TryConvertToSaturating<TOther>(sbyte value, out TOther result); + static bool INumberBase<sbyte>.TryConvertToTruncating<TOther>(sbyte value, out TOther result); + static sbyte IShiftOperators<sbyte, int, sbyte>.operator <<(sbyte value, int shiftAmount); + static sbyte IShiftOperators<sbyte, int, sbyte>.operator >>(sbyte value, int shiftAmount); + static sbyte IShiftOperators<sbyte, int, sbyte>.operator >>>(sbyte value, int shiftAmount); + static sbyte ISubtractionOperators<sbyte, sbyte, sbyte>.operator checked -(sbyte left, sbyte right); + static sbyte ISubtractionOperators<sbyte, sbyte, sbyte>.operator -(sbyte left, sbyte right); + static sbyte IUnaryNegationOperators<sbyte, sbyte>.operator checked -(sbyte value); + static sbyte IUnaryNegationOperators<sbyte, sbyte>.operator -(sbyte value); + static sbyte IUnaryPlusOperators<sbyte, sbyte>.operator +(sbyte value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static sbyte TrailingZeroCount(sbyte value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out sbyte result); + public static bool TryParse(string? s, IFormatProvider? provider, out sbyte result); } - public readonly struct Single : IComparable, IComparable<float>, IConvertible, IEquatable<float>, IFormattable, ISpanFormattable { + public readonly struct Single : IAdditionOperators<float, float, float>, IAdditiveIdentity<float, float>, IBinaryFloatingPointIeee754<float>, IBinaryNumber<float>, IBitwiseOperators<float, float, float>, IComparable, IComparable<float>, IComparisonOperators<float, float, bool>, IConvertible, IDecrementOperators<float>, IDivisionOperators<float, float, float>, IEqualityOperators<float, float, bool>, IEquatable<float>, IExponentialFunctions<float>, IFloatingPoint<float>, IFloatingPointConstants<float>, IFloatingPointIeee754<float>, IFormattable, IHyperbolicFunctions<float>, IIncrementOperators<float>, ILogarithmicFunctions<float>, IMinMaxValue<float>, IModulusOperators<float, float, float>, IMultiplicativeIdentity<float, float>, IMultiplyOperators<float, float, float>, INumber<float>, INumberBase<float>, IParsable<float>, IPowerFunctions<float>, IRootFunctions<float>, ISignedNumber<float>, ISpanFormattable, ISpanParsable<float>, ISubtractionOperators<float, float, float>, ITrigonometricFunctions<float>, IUnaryNegationOperators<float, float>, IUnaryPlusOperators<float, float> { + public const float E = 2.7182817f; + public const float NegativeZero = -0f; + public const float Pi = 3.1415927f; + public const float Tau = 6.2831855f; + static float System.Numerics.IAdditiveIdentity<System.Single,System.Single>.AdditiveIdentity { get; } + static float System.Numerics.IBinaryNumber<System.Single>.AllBitsSet { get; } + static float System.Numerics.IFloatingPointConstants<System.Single>.E { get; } + static float System.Numerics.IFloatingPointConstants<System.Single>.Pi { get; } + static float System.Numerics.IFloatingPointConstants<System.Single>.Tau { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.Epsilon { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.NaN { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeInfinity { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeZero { get; } + static float System.Numerics.IFloatingPointIeee754<System.Single>.PositiveInfinity { get; } + static float System.Numerics.IMinMaxValue<System.Single>.MaxValue { get; } + static float System.Numerics.IMinMaxValue<System.Single>.MinValue { get; } + static float System.Numerics.IMultiplicativeIdentity<System.Single,System.Single>.MultiplicativeIdentity { get; } + static float System.Numerics.INumberBase<System.Single>.One { get; } + static int System.Numerics.INumberBase<System.Single>.Radix { get; } + static float System.Numerics.INumberBase<System.Single>.Zero { get; } + static float System.Numerics.ISignedNumber<System.Single>.NegativeOne { get; } + public static float Abs(float value); + public static float Acos(float x); + public static float Acosh(float x); + public static float AcosPi(float x); + public static float Asin(float x); + public static float Asinh(float x); + public static float AsinPi(float x); + public static float Atan(float x); + public static float Atan2(float y, float x); + public static float Atan2Pi(float y, float x); + public static float Atanh(float x); + public static float AtanPi(float x); + public static float BitDecrement(float x); + public static float BitIncrement(float x); + public static float Cbrt(float x); + public static float Ceiling(float x); + public static float Clamp(float value, float min, float max); + public static float CopySign(float value, float sign); + public static float Cos(float x); + public static float Cosh(float x); + public static float CosPi(float x); + public static float CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static float CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static float CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static float Exp(float x); + public static float Exp10(float x); + public static float Exp10M1(float x); + public static float Exp2(float x); + public static float Exp2M1(float x); + public static float ExpM1(float x); + public static float Floor(float x); + public static float FusedMultiplyAdd(float left, float right, float addend); + public static float Hypot(float x, float y); + public static float Ieee754Remainder(float left, float right); + public static int ILogB(float x); + public static bool IsEvenInteger(float value); + public static bool IsInteger(float value); + public static bool IsOddInteger(float value); + public static bool IsPositive(float value); + public static bool IsPow2(float value); + public static bool IsRealNumber(float value); + public static float Log(float x); + public static float Log(float x, float newBase); + public static float Log10(float x); + public static float Log10P1(float x); + public static float Log2(float value); + public static float Log2P1(float x); + public static float LogP1(float x); + public static float Max(float x, float y); + public static float MaxMagnitude(float x, float y); + public static float MaxMagnitudeNumber(float x, float y); + public static float MaxNumber(float x, float y); + public static float Min(float x, float y); + public static float MinMagnitude(float x, float y); + public static float MinMagnitudeNumber(float x, float y); + public static float MinNumber(float x, float y); + public static float Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static float Pow(float x, float y); + public static float ReciprocalEstimate(float x); + public static float ReciprocalSqrtEstimate(float x); + public static float RootN(float x, int n); + public static float Round(float x); + public static float Round(float x, int digits); + public static float Round(float x, int digits, MidpointRounding mode); + public static float Round(float x, MidpointRounding mode); + public static float ScaleB(float x, int n); + public static int Sign(float value); + public static float Sin(float x); + public static (float Sin, float Cos) SinCos(float x); + public static (float SinPi, float CosPi) SinCosPi(float x); + public static float Sinh(float x); + public static float SinPi(float x); + public static float Sqrt(float x); + static float IAdditionOperators<float, float, float>.operator +(float left, float right); + static float IBitwiseOperators<float, float, float>.operator &(float left, float right); + static float IBitwiseOperators<float, float, float>.operator |(float left, float right); + static float IBitwiseOperators<float, float, float>.operator ^(float left, float right); + static float IBitwiseOperators<float, float, float>.operator ~(float value); + static float IDecrementOperators<float>.operator --(float value); + static float IDivisionOperators<float, float, float>.operator /(float left, float right); + int IFloatingPoint<float>.GetExponentByteCount(); + int IFloatingPoint<float>.GetExponentShortestBitLength(); + int IFloatingPoint<float>.GetSignificandBitLength(); + int IFloatingPoint<float>.GetSignificandByteCount(); + bool IFloatingPoint<float>.TryWriteExponentBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<float>.TryWriteExponentLittleEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<float>.TryWriteSignificandBigEndian(Span<byte> destination, out int bytesWritten); + bool IFloatingPoint<float>.TryWriteSignificandLittleEndian(Span<byte> destination, out int bytesWritten); + static float IIncrementOperators<float>.operator ++(float value); + static float IModulusOperators<float, float, float>.operator %(float left, float right); + static float IMultiplyOperators<float, float, float>.operator *(float left, float right); + static bool INumberBase<float>.IsCanonical(float value); + static bool INumberBase<float>.IsComplexNumber(float value); + static bool INumberBase<float>.IsImaginaryNumber(float value); + static bool INumberBase<float>.IsZero(float value); + static bool INumberBase<float>.TryConvertFromChecked<TOther>(TOther value, out float result); + static bool INumberBase<float>.TryConvertFromSaturating<TOther>(TOther value, out float result); + static bool INumberBase<float>.TryConvertFromTruncating<TOther>(TOther value, out float result); + static bool INumberBase<float>.TryConvertToChecked<TOther>(float value, out TOther result); + static bool INumberBase<float>.TryConvertToSaturating<TOther>(float value, out TOther result); + static bool INumberBase<float>.TryConvertToTruncating<TOther>(float value, out TOther result); + static float ISubtractionOperators<float, float, float>.operator -(float left, float right); + static float IUnaryNegationOperators<float, float>.operator -(float value); + static float IUnaryPlusOperators<float, float>.operator +(float value); + public static float Tan(float x); + public static float Tanh(float x); + public static float TanPi(float x); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static float Truncate(float x); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out float result); + public static bool TryParse(string? s, IFormatProvider? provider, out float result); } public readonly ref struct Span<T> { + public Span(ref T reference); } public sealed class String : ICloneable, IComparable, IComparable<string?>, IConvertible, IEnumerable, IEnumerable<char>, IEquatable<string?> { public static string Format(IFormatProvider? provider, string format, object? arg0); public static string Format(IFormatProvider? provider, string format, object? arg0, object? arg1); public static string Format(IFormatProvider? provider, string format, object? arg0, object? arg1, object? arg2); public static string Format(IFormatProvider? provider, string format, params object?[] args); public static string Format(string format, object? arg0); public static string Format(string format, object? arg0, object? arg1); public static string Format(string format, object? arg0, object? arg1, object? arg2); public static string Format(string format, params object?[] args); } - public readonly struct TimeOnly : IComparable, IComparable<TimeOnly>, IEquatable<TimeOnly>, IFormattable, ISpanFormattable { + public readonly struct TimeOnly : IComparable, IComparable<TimeOnly>, IEquatable<TimeOnly>, IFormattable, IParsable<TimeOnly>, ISpanFormattable, ISpanParsable<TimeOnly> { + public TimeOnly(int hour, int minute, int second, int millisecond, int microsecond); + public int Microsecond { get; } + public int Nanosecond { get; } + public static TimeOnly Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static TimeOnly Parse(string s, IFormatProvider? provider); public static TimeOnly ParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider = null, DateTimeStyles style = DateTimeStyles.None); public static TimeOnly ParseExact(ReadOnlySpan<char> s, string[] formats); public static TimeOnly ParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static TimeOnly ParseExact(string s, string format); public static TimeOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public static TimeOnly ParseExact(string s, string[] formats); public static TimeOnly ParseExact(string s, string[] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TimeOnly result); + public static bool TryParse(string? s, IFormatProvider? provider, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(ReadOnlySpan<char> s, string?[]? formats, out TimeOnly result); public static bool TryParseExact(string? s, string? format, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(string? s, string? format, out TimeOnly result); public static bool TryParseExact(string? s, string?[]? formats, IFormatProvider? provider, DateTimeStyles style, out TimeOnly result); public static bool TryParseExact(string? s, string?[]? formats, out TimeOnly result); } - public readonly struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable, ISpanFormattable { + public readonly struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable, IParsable<TimeSpan>, ISpanFormattable, ISpanParsable<TimeSpan> { + public const long NanosecondsPerTick = (long)100; + public const long TicksPerMicrosecond = (long)10; + public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds, int microseconds); + public int Microseconds { get; } + public int Nanoseconds { get; } + public double TotalMicroseconds { get; } + public double TotalNanoseconds { get; } + public static TimeSpan FromMicroseconds(double value); public static TimeSpan ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, TimeSpanStyles styles = TimeSpanStyles.None); public static TimeSpan ParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider? formatProvider, TimeSpanStyles styles = TimeSpanStyles.None); public static TimeSpan ParseExact(string input, string format, IFormatProvider? formatProvider); public static TimeSpan ParseExact(string input, string format, IFormatProvider? formatProvider, TimeSpanStyles styles); public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider? formatProvider); public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider? formatProvider, TimeSpanStyles styles); public string ToString(string? format); public string ToString(string? format, IFormatProvider? formatProvider); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? formatProvider = null); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider? formatProvider, out TimeSpan result); public static bool TryParseExact(ReadOnlySpan<char> input, string?[]? formats, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(ReadOnlySpan<char> input, string?[]? formats, IFormatProvider? formatProvider, out TimeSpan result); public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(string? input, string? format, IFormatProvider? formatProvider, out TimeSpan result); public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, TimeSpanStyles styles, out TimeSpan result); public static bool TryParseExact(string? input, string?[]? formats, IFormatProvider? formatProvider, out TimeSpan result); } public sealed class TimeZoneInfo : IDeserializationCallback, IEquatable<TimeZoneInfo?>, ISerializable { public bool HasIanaId { get; } public sealed class AdjustmentRule : IDeserializationCallback, IEquatable<TimeZoneInfo.AdjustmentRule?>, ISerializable { + public override bool Equals(object? obj); } } public abstract class Type : MemberInfo, IReflect { public virtual Array GetEnumValues(); + public virtual Array GetEnumValuesAsUnderlyingType(); - public static Type GetTypeFromHandle(RuntimeTypeHandle handle); + public static Type? GetTypeFromHandle(RuntimeTypeHandle handle); public virtual Type MakeArrayType(); public virtual Type MakeArrayType(int rank); public virtual Type MakeGenericType(params Type[] typeArguments); } + public readonly struct UInt128 : IAdditionOperators<UInt128, UInt128, UInt128>, IAdditiveIdentity<UInt128, UInt128>, IBinaryInteger<UInt128>, IBinaryNumber<UInt128>, IBitwiseOperators<UInt128, UInt128, UInt128>, IComparable, IComparable<UInt128>, IComparisonOperators<UInt128, UInt128, bool>, IDecrementOperators<UInt128>, IDivisionOperators<UInt128, UInt128, UInt128>, IEqualityOperators<UInt128, UInt128, bool>, IEquatable<UInt128>, IFormattable, IIncrementOperators<UInt128>, IMinMaxValue<UInt128>, IModulusOperators<UInt128, UInt128, UInt128>, IMultiplicativeIdentity<UInt128, UInt128>, IMultiplyOperators<UInt128, UInt128, UInt128>, INumber<UInt128>, INumberBase<UInt128>, IParsable<UInt128>, IShiftOperators<UInt128, int, UInt128>, ISpanFormattable, ISpanParsable<UInt128>, ISubtractionOperators<UInt128, UInt128, UInt128>, IUnaryNegationOperators<UInt128, UInt128>, IUnaryPlusOperators<UInt128, UInt128>, IUnsignedNumber<UInt128> { + public UInt128(ulong upper, ulong lower); + public static UInt128 MaxValue { get; } + public static UInt128 MinValue { get; } + public static UInt128 One { get; } + static UInt128 System.Numerics.IAdditiveIdentity<System.UInt128,System.UInt128>.AdditiveIdentity { get; } + static UInt128 System.Numerics.IBinaryNumber<System.UInt128>.AllBitsSet { get; } + static UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128,System.UInt128>.MultiplicativeIdentity { get; } + static int System.Numerics.INumberBase<System.UInt128>.Radix { get; } + public static UInt128 Zero { get; } + public static UInt128 Clamp(UInt128 value, UInt128 min, UInt128 max); + public int CompareTo(object? value); + public int CompareTo(UInt128 value); + public static UInt128 CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UInt128 CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UInt128 CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (UInt128 Quotient, UInt128 Remainder) DivRem(UInt128 left, UInt128 right); + public override bool Equals(object? obj); + public bool Equals(UInt128 other); + public override int GetHashCode(); + public static bool IsEvenInteger(UInt128 value); + public static bool IsOddInteger(UInt128 value); + public static bool IsPow2(UInt128 value); + public static UInt128 LeadingZeroCount(UInt128 value); + public static UInt128 Log2(UInt128 value); + public static UInt128 Max(UInt128 x, UInt128 y); + public static UInt128 Min(UInt128 x, UInt128 y); + public static UInt128 operator +(UInt128 left, UInt128 right); + public static UInt128 operator &(UInt128 left, UInt128 right); + public static UInt128 operator |(UInt128 left, UInt128 right); + public static UInt128 operator checked +(UInt128 left, UInt128 right); + public static UInt128 operator checked --(UInt128 value); + public static UInt128 operator checked /(UInt128 left, UInt128 right); + public static explicit operator checked UInt128 (double value); + public static explicit operator checked UInt128 (short value); + public static explicit operator checked UInt128 (int value); + public static explicit operator checked UInt128 (long value); + public static explicit operator checked UInt128 (IntPtr value); + public static explicit operator checked UInt128 (sbyte value); + public static explicit operator checked UInt128 (float value); + public static explicit operator checked byte (UInt128 value); + public static explicit operator checked char (UInt128 value); + public static explicit operator checked short (UInt128 value); + public static explicit operator checked int (UInt128 value); + public static explicit operator checked long (UInt128 value); + public static explicit operator checked Int128 (UInt128 value); + public static explicit operator checked IntPtr (UInt128 value); + public static explicit operator checked sbyte (UInt128 value); + public static explicit operator checked ushort (UInt128 value); + public static explicit operator checked uint (UInt128 value); + public static explicit operator checked ulong (UInt128 value); + public static explicit operator checked UIntPtr (UInt128 value); + public static UInt128 operator checked ++(UInt128 value); + public static UInt128 operator checked *(UInt128 left, UInt128 right); + public static UInt128 operator checked -(UInt128 left, UInt128 right); + public static UInt128 operator checked -(UInt128 value); + public static UInt128 operator --(UInt128 value); + public static UInt128 operator /(UInt128 left, UInt128 right); + public static bool operator ==(UInt128 left, UInt128 right); + public static UInt128 operator ^(UInt128 left, UInt128 right); + public static explicit operator UInt128 (decimal value); + public static explicit operator UInt128 (double value); + public static explicit operator UInt128 (short value); + public static explicit operator UInt128 (int value); + public static explicit operator UInt128 (long value); + public static explicit operator UInt128 (IntPtr value); + public static explicit operator UInt128 (sbyte value); + public static explicit operator UInt128 (float value); + public static explicit operator byte (UInt128 value); + public static explicit operator char (UInt128 value); + public static explicit operator decimal (UInt128 value); + public static explicit operator double (UInt128 value); + public static explicit operator Half (UInt128 value); + public static explicit operator Int128 (UInt128 value); + public static explicit operator short (UInt128 value); + public static explicit operator int (UInt128 value); + public static explicit operator long (UInt128 value); + public static explicit operator IntPtr (UInt128 value); + public static explicit operator sbyte (UInt128 value); + public static explicit operator float (UInt128 value); + public static explicit operator ushort (UInt128 value); + public static explicit operator uint (UInt128 value); + public static explicit operator ulong (UInt128 value); + public static explicit operator UIntPtr (UInt128 value); + public static bool operator >(UInt128 left, UInt128 right); + public static bool operator >=(UInt128 left, UInt128 right); + public static implicit operator UInt128 (byte value); + public static implicit operator UInt128 (char value); + public static implicit operator UInt128 (ushort value); + public static implicit operator UInt128 (uint value); + public static implicit operator UInt128 (ulong value); + public static implicit operator UInt128 (UIntPtr value); + public static UInt128 operator ++(UInt128 value); + public static bool operator !=(UInt128 left, UInt128 right); + public static UInt128 operator <<(UInt128 value, int shiftAmount); + public static bool operator <(UInt128 left, UInt128 right); + public static bool operator <=(UInt128 left, UInt128 right); + public static UInt128 operator %(UInt128 left, UInt128 right); + public static UInt128 operator *(UInt128 left, UInt128 right); + public static UInt128 operator ~(UInt128 value); + public static UInt128 operator >>(UInt128 value, int shiftAmount); + public static UInt128 operator -(UInt128 left, UInt128 right); + public static UInt128 operator -(UInt128 value); + public static UInt128 operator +(UInt128 value); + public static UInt128 operator >>>(UInt128 value, int shiftAmount); + public static UInt128 Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null); + public static UInt128 Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static UInt128 Parse(string s); + public static UInt128 Parse(string s, NumberStyles style); + public static UInt128 Parse(string s, NumberStyles style, IFormatProvider? provider); + public static UInt128 Parse(string s, IFormatProvider? provider); + public static UInt128 PopCount(UInt128 value); + public static UInt128 RotateLeft(UInt128 value, int rotateAmount); + public static UInt128 RotateRight(UInt128 value, int rotateAmount); + public static int Sign(UInt128 value); + int IBinaryInteger<UInt128>.GetByteCount(); + int IBinaryInteger<UInt128>.GetShortestBitLength(); + static bool IBinaryInteger<UInt128>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UInt128 value); + static bool IBinaryInteger<UInt128>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UInt128 value); + bool IBinaryInteger<UInt128>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<UInt128>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static UInt128 INumber<UInt128>.CopySign(UInt128 value, UInt128 sign); + static UInt128 INumber<UInt128>.MaxNumber(UInt128 x, UInt128 y); + static UInt128 INumber<UInt128>.MinNumber(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.Abs(UInt128 value); + static bool INumberBase<UInt128>.IsCanonical(UInt128 value); + static bool INumberBase<UInt128>.IsComplexNumber(UInt128 value); + static bool INumberBase<UInt128>.IsFinite(UInt128 value); + static bool INumberBase<UInt128>.IsImaginaryNumber(UInt128 value); + static bool INumberBase<UInt128>.IsInfinity(UInt128 value); + static bool INumberBase<UInt128>.IsInteger(UInt128 value); + static bool INumberBase<UInt128>.IsNaN(UInt128 value); + static bool INumberBase<UInt128>.IsNegative(UInt128 value); + static bool INumberBase<UInt128>.IsNegativeInfinity(UInt128 value); + static bool INumberBase<UInt128>.IsNormal(UInt128 value); + static bool INumberBase<UInt128>.IsPositive(UInt128 value); + static bool INumberBase<UInt128>.IsPositiveInfinity(UInt128 value); + static bool INumberBase<UInt128>.IsRealNumber(UInt128 value); + static bool INumberBase<UInt128>.IsSubnormal(UInt128 value); + static bool INumberBase<UInt128>.IsZero(UInt128 value); + static UInt128 INumberBase<UInt128>.MaxMagnitude(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.MaxMagnitudeNumber(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.MinMagnitude(UInt128 x, UInt128 y); + static UInt128 INumberBase<UInt128>.MinMagnitudeNumber(UInt128 x, UInt128 y); + static bool INumberBase<UInt128>.TryConvertFromChecked<TOther>(TOther value, out UInt128 result); + static bool INumberBase<UInt128>.TryConvertFromSaturating<TOther>(TOther value, out UInt128 result); + static bool INumberBase<UInt128>.TryConvertFromTruncating<TOther>(TOther value, out UInt128 result); + static bool INumberBase<UInt128>.TryConvertToChecked<TOther>(UInt128 value, out TOther result); + static bool INumberBase<UInt128>.TryConvertToSaturating<TOther>(UInt128 value, out TOther result); + static bool INumberBase<UInt128>.TryConvertToTruncating<TOther>(UInt128 value, out TOther result); + public override string ToString(); + public string ToString(IFormatProvider? provider); + public string ToString(string? format); + public string ToString(string? format, IFormatProvider? provider); + public static UInt128 TrailingZeroCount(UInt128 value); + public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(ReadOnlySpan<char> s, out UInt128 result); + public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(string? s, IFormatProvider? provider, out UInt128 result); + public static bool TryParse(string? s, out UInt128 result); + } - public readonly struct UInt16 : IComparable, IComparable<ushort>, IConvertible, IEquatable<ushort>, IFormattable, ISpanFormattable { + public readonly struct UInt16 : IAdditionOperators<ushort, ushort, ushort>, IAdditiveIdentity<ushort, ushort>, IBinaryInteger<ushort>, IBinaryNumber<ushort>, IBitwiseOperators<ushort, ushort, ushort>, IComparable, IComparable<ushort>, IComparisonOperators<ushort, ushort, bool>, IConvertible, IDecrementOperators<ushort>, IDivisionOperators<ushort, ushort, ushort>, IEqualityOperators<ushort, ushort, bool>, IEquatable<ushort>, IFormattable, IIncrementOperators<ushort>, IMinMaxValue<ushort>, IModulusOperators<ushort, ushort, ushort>, IMultiplicativeIdentity<ushort, ushort>, IMultiplyOperators<ushort, ushort, ushort>, INumber<ushort>, INumberBase<ushort>, IParsable<ushort>, IShiftOperators<ushort, int, ushort>, ISpanFormattable, ISpanParsable<ushort>, ISubtractionOperators<ushort, ushort, ushort>, IUnaryNegationOperators<ushort, ushort>, IUnaryPlusOperators<ushort, ushort>, IUnsignedNumber<ushort> { + static ushort System.Numerics.IAdditiveIdentity<System.UInt16,System.UInt16>.AdditiveIdentity { get; } + static ushort System.Numerics.IBinaryNumber<System.UInt16>.AllBitsSet { get; } + static ushort System.Numerics.IMinMaxValue<System.UInt16>.MaxValue { get; } + static ushort System.Numerics.IMinMaxValue<System.UInt16>.MinValue { get; } + static ushort System.Numerics.IMultiplicativeIdentity<System.UInt16,System.UInt16>.MultiplicativeIdentity { get; } + static ushort System.Numerics.INumberBase<System.UInt16>.One { get; } + static int System.Numerics.INumberBase<System.UInt16>.Radix { get; } + static ushort System.Numerics.INumberBase<System.UInt16>.Zero { get; } + public static ushort Clamp(ushort value, ushort min, ushort max); + public static ushort CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ushort CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ushort CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (ushort Quotient, ushort Remainder) DivRem(ushort left, ushort right); + public static bool IsEvenInteger(ushort value); + public static bool IsOddInteger(ushort value); + public static bool IsPow2(ushort value); + public static ushort LeadingZeroCount(ushort value); + public static ushort Log2(ushort value); + public static ushort Max(ushort x, ushort y); + public static ushort Min(ushort x, ushort y); + public static ushort Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static ushort PopCount(ushort value); + public static ushort RotateLeft(ushort value, int rotateAmount); + public static ushort RotateRight(ushort value, int rotateAmount); + public static int Sign(ushort value); + static ushort IAdditionOperators<ushort, ushort, ushort>.operator +(ushort left, ushort right); + static ushort IAdditionOperators<ushort, ushort, ushort>.operator checked +(ushort left, ushort right); + int IBinaryInteger<ushort>.GetByteCount(); + int IBinaryInteger<ushort>.GetShortestBitLength(); + static bool IBinaryInteger<ushort>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ushort value); + static bool IBinaryInteger<ushort>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ushort value); + bool IBinaryInteger<ushort>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<ushort>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator &(ushort left, ushort right); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator |(ushort left, ushort right); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator ^(ushort left, ushort right); + static ushort IBitwiseOperators<ushort, ushort, ushort>.operator ~(ushort value); + static bool IComparisonOperators<ushort, ushort, bool>.operator >(ushort left, ushort right); + static bool IComparisonOperators<ushort, ushort, bool>.operator >=(ushort left, ushort right); + static bool IComparisonOperators<ushort, ushort, bool>.operator <(ushort left, ushort right); + static bool IComparisonOperators<ushort, ushort, bool>.operator <=(ushort left, ushort right); + static ushort IDecrementOperators<ushort>.operator checked --(ushort value); + static ushort IDecrementOperators<ushort>.operator --(ushort value); + static ushort IDivisionOperators<ushort, ushort, ushort>.operator /(ushort left, ushort right); + static bool IEqualityOperators<ushort, ushort, bool>.operator ==(ushort left, ushort right); + static bool IEqualityOperators<ushort, ushort, bool>.operator !=(ushort left, ushort right); + static ushort IIncrementOperators<ushort>.operator checked ++(ushort value); + static ushort IIncrementOperators<ushort>.operator ++(ushort value); + static ushort IModulusOperators<ushort, ushort, ushort>.operator %(ushort left, ushort right); + static ushort IMultiplyOperators<ushort, ushort, ushort>.operator checked *(ushort left, ushort right); + static ushort IMultiplyOperators<ushort, ushort, ushort>.operator *(ushort left, ushort right); + static ushort INumber<ushort>.CopySign(ushort value, ushort sign); + static ushort INumber<ushort>.MaxNumber(ushort x, ushort y); + static ushort INumber<ushort>.MinNumber(ushort x, ushort y); + static ushort INumberBase<ushort>.Abs(ushort value); + static bool INumberBase<ushort>.IsCanonical(ushort value); + static bool INumberBase<ushort>.IsComplexNumber(ushort value); + static bool INumberBase<ushort>.IsFinite(ushort value); + static bool INumberBase<ushort>.IsImaginaryNumber(ushort value); + static bool INumberBase<ushort>.IsInfinity(ushort value); + static bool INumberBase<ushort>.IsInteger(ushort value); + static bool INumberBase<ushort>.IsNaN(ushort value); + static bool INumberBase<ushort>.IsNegative(ushort value); + static bool INumberBase<ushort>.IsNegativeInfinity(ushort value); + static bool INumberBase<ushort>.IsNormal(ushort value); + static bool INumberBase<ushort>.IsPositive(ushort value); + static bool INumberBase<ushort>.IsPositiveInfinity(ushort value); + static bool INumberBase<ushort>.IsRealNumber(ushort value); + static bool INumberBase<ushort>.IsSubnormal(ushort value); + static bool INumberBase<ushort>.IsZero(ushort value); + static ushort INumberBase<ushort>.MaxMagnitude(ushort x, ushort y); + static ushort INumberBase<ushort>.MaxMagnitudeNumber(ushort x, ushort y); + static ushort INumberBase<ushort>.MinMagnitude(ushort x, ushort y); + static ushort INumberBase<ushort>.MinMagnitudeNumber(ushort x, ushort y); + static bool INumberBase<ushort>.TryConvertFromChecked<TOther>(TOther value, out ushort result); + static bool INumberBase<ushort>.TryConvertFromSaturating<TOther>(TOther value, out ushort result); + static bool INumberBase<ushort>.TryConvertFromTruncating<TOther>(TOther value, out ushort result); + static bool INumberBase<ushort>.TryConvertToChecked<TOther>(ushort value, out TOther result); + static bool INumberBase<ushort>.TryConvertToSaturating<TOther>(ushort value, out TOther result); + static bool INumberBase<ushort>.TryConvertToTruncating<TOther>(ushort value, out TOther result); + static ushort IShiftOperators<ushort, int, ushort>.operator <<(ushort value, int shiftAmount); + static ushort IShiftOperators<ushort, int, ushort>.operator >>(ushort value, int shiftAmount); + static ushort IShiftOperators<ushort, int, ushort>.operator >>>(ushort value, int shiftAmount); + static ushort ISubtractionOperators<ushort, ushort, ushort>.operator checked -(ushort left, ushort right); + static ushort ISubtractionOperators<ushort, ushort, ushort>.operator -(ushort left, ushort right); + static ushort IUnaryNegationOperators<ushort, ushort>.operator checked -(ushort value); + static ushort IUnaryNegationOperators<ushort, ushort>.operator -(ushort value); + static ushort IUnaryPlusOperators<ushort, ushort>.operator +(ushort value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static ushort TrailingZeroCount(ushort value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out ushort result); + public static bool TryParse(string? s, IFormatProvider? provider, out ushort result); } - public readonly struct UInt32 : IComparable, IComparable<uint>, IConvertible, IEquatable<uint>, IFormattable, ISpanFormattable { + public readonly struct UInt32 : IAdditionOperators<uint, uint, uint>, IAdditiveIdentity<uint, uint>, IBinaryInteger<uint>, IBinaryNumber<uint>, IBitwiseOperators<uint, uint, uint>, IComparable, IComparable<uint>, IComparisonOperators<uint, uint, bool>, IConvertible, IDecrementOperators<uint>, IDivisionOperators<uint, uint, uint>, IEqualityOperators<uint, uint, bool>, IEquatable<uint>, IFormattable, IIncrementOperators<uint>, IMinMaxValue<uint>, IModulusOperators<uint, uint, uint>, IMultiplicativeIdentity<uint, uint>, IMultiplyOperators<uint, uint, uint>, INumber<uint>, INumberBase<uint>, IParsable<uint>, IShiftOperators<uint, int, uint>, ISpanFormattable, ISpanParsable<uint>, ISubtractionOperators<uint, uint, uint>, IUnaryNegationOperators<uint, uint>, IUnaryPlusOperators<uint, uint>, IUnsignedNumber<uint> { + static uint System.Numerics.IAdditiveIdentity<System.UInt32,System.UInt32>.AdditiveIdentity { get; } + static uint System.Numerics.IBinaryNumber<System.UInt32>.AllBitsSet { get; } + static uint System.Numerics.IMinMaxValue<System.UInt32>.MaxValue { get; } + static uint System.Numerics.IMinMaxValue<System.UInt32>.MinValue { get; } + static uint System.Numerics.IMultiplicativeIdentity<System.UInt32,System.UInt32>.MultiplicativeIdentity { get; } + static uint System.Numerics.INumberBase<System.UInt32>.One { get; } + static int System.Numerics.INumberBase<System.UInt32>.Radix { get; } + static uint System.Numerics.INumberBase<System.UInt32>.Zero { get; } + public static uint Clamp(uint value, uint min, uint max); + public static uint CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static uint CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static uint CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (uint Quotient, uint Remainder) DivRem(uint left, uint right); + public static bool IsEvenInteger(uint value); + public static bool IsOddInteger(uint value); + public static bool IsPow2(uint value); + public static uint LeadingZeroCount(uint value); + public static uint Log2(uint value); + public static uint Max(uint x, uint y); + public static uint Min(uint x, uint y); + public static uint Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static uint PopCount(uint value); + public static uint RotateLeft(uint value, int rotateAmount); + public static uint RotateRight(uint value, int rotateAmount); + public static int Sign(uint value); + static uint IAdditionOperators<uint, uint, uint>.operator +(uint left, uint right); + static uint IAdditionOperators<uint, uint, uint>.operator checked +(uint left, uint right); + int IBinaryInteger<uint>.GetByteCount(); + int IBinaryInteger<uint>.GetShortestBitLength(); + static bool IBinaryInteger<uint>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out uint value); + static bool IBinaryInteger<uint>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out uint value); + bool IBinaryInteger<uint>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<uint>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static uint IBitwiseOperators<uint, uint, uint>.operator &(uint left, uint right); + static uint IBitwiseOperators<uint, uint, uint>.operator |(uint left, uint right); + static uint IBitwiseOperators<uint, uint, uint>.operator ^(uint left, uint right); + static uint IBitwiseOperators<uint, uint, uint>.operator ~(uint value); + static bool IComparisonOperators<uint, uint, bool>.operator >(uint left, uint right); + static bool IComparisonOperators<uint, uint, bool>.operator >=(uint left, uint right); + static bool IComparisonOperators<uint, uint, bool>.operator <(uint left, uint right); + static bool IComparisonOperators<uint, uint, bool>.operator <=(uint left, uint right); + static uint IDecrementOperators<uint>.operator checked --(uint value); + static uint IDecrementOperators<uint>.operator --(uint value); + static uint IDivisionOperators<uint, uint, uint>.operator /(uint left, uint right); + static bool IEqualityOperators<uint, uint, bool>.operator ==(uint left, uint right); + static bool IEqualityOperators<uint, uint, bool>.operator !=(uint left, uint right); + static uint IIncrementOperators<uint>.operator checked ++(uint value); + static uint IIncrementOperators<uint>.operator ++(uint value); + static uint IModulusOperators<uint, uint, uint>.operator %(uint left, uint right); + static uint IMultiplyOperators<uint, uint, uint>.operator checked *(uint left, uint right); + static uint IMultiplyOperators<uint, uint, uint>.operator *(uint left, uint right); + static uint INumber<uint>.CopySign(uint value, uint sign); + static uint INumber<uint>.MaxNumber(uint x, uint y); + static uint INumber<uint>.MinNumber(uint x, uint y); + static uint INumberBase<uint>.Abs(uint value); + static bool INumberBase<uint>.IsCanonical(uint value); + static bool INumberBase<uint>.IsComplexNumber(uint value); + static bool INumberBase<uint>.IsFinite(uint value); + static bool INumberBase<uint>.IsImaginaryNumber(uint value); + static bool INumberBase<uint>.IsInfinity(uint value); + static bool INumberBase<uint>.IsInteger(uint value); + static bool INumberBase<uint>.IsNaN(uint value); + static bool INumberBase<uint>.IsNegative(uint value); + static bool INumberBase<uint>.IsNegativeInfinity(uint value); + static bool INumberBase<uint>.IsNormal(uint value); + static bool INumberBase<uint>.IsPositive(uint value); + static bool INumberBase<uint>.IsPositiveInfinity(uint value); + static bool INumberBase<uint>.IsRealNumber(uint value); + static bool INumberBase<uint>.IsSubnormal(uint value); + static bool INumberBase<uint>.IsZero(uint value); + static uint INumberBase<uint>.MaxMagnitude(uint x, uint y); + static uint INumberBase<uint>.MaxMagnitudeNumber(uint x, uint y); + static uint INumberBase<uint>.MinMagnitude(uint x, uint y); + static uint INumberBase<uint>.MinMagnitudeNumber(uint x, uint y); + static bool INumberBase<uint>.TryConvertFromChecked<TOther>(TOther value, out uint result); + static bool INumberBase<uint>.TryConvertFromSaturating<TOther>(TOther value, out uint result); + static bool INumberBase<uint>.TryConvertFromTruncating<TOther>(TOther value, out uint result); + static bool INumberBase<uint>.TryConvertToChecked<TOther>(uint value, out TOther result); + static bool INumberBase<uint>.TryConvertToSaturating<TOther>(uint value, out TOther result); + static bool INumberBase<uint>.TryConvertToTruncating<TOther>(uint value, out TOther result); + static uint IShiftOperators<uint, int, uint>.operator <<(uint value, int shiftAmount); + static uint IShiftOperators<uint, int, uint>.operator >>(uint value, int shiftAmount); + static uint IShiftOperators<uint, int, uint>.operator >>>(uint value, int shiftAmount); + static uint ISubtractionOperators<uint, uint, uint>.operator checked -(uint left, uint right); + static uint ISubtractionOperators<uint, uint, uint>.operator -(uint left, uint right); + static uint IUnaryNegationOperators<uint, uint>.operator checked -(uint value); + static uint IUnaryNegationOperators<uint, uint>.operator -(uint value); + static uint IUnaryPlusOperators<uint, uint>.operator +(uint value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static uint TrailingZeroCount(uint value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out uint result); + public static bool TryParse(string? s, IFormatProvider? provider, out uint result); } - public readonly struct UInt64 : IComparable, IComparable<ulong>, IConvertible, IEquatable<ulong>, IFormattable, ISpanFormattable { + public readonly struct UInt64 : IAdditionOperators<ulong, ulong, ulong>, IAdditiveIdentity<ulong, ulong>, IBinaryInteger<ulong>, IBinaryNumber<ulong>, IBitwiseOperators<ulong, ulong, ulong>, IComparable, IComparable<ulong>, IComparisonOperators<ulong, ulong, bool>, IConvertible, IDecrementOperators<ulong>, IDivisionOperators<ulong, ulong, ulong>, IEqualityOperators<ulong, ulong, bool>, IEquatable<ulong>, IFormattable, IIncrementOperators<ulong>, IMinMaxValue<ulong>, IModulusOperators<ulong, ulong, ulong>, IMultiplicativeIdentity<ulong, ulong>, IMultiplyOperators<ulong, ulong, ulong>, INumber<ulong>, INumberBase<ulong>, IParsable<ulong>, IShiftOperators<ulong, int, ulong>, ISpanFormattable, ISpanParsable<ulong>, ISubtractionOperators<ulong, ulong, ulong>, IUnaryNegationOperators<ulong, ulong>, IUnaryPlusOperators<ulong, ulong>, IUnsignedNumber<ulong> { + static ulong System.Numerics.IAdditiveIdentity<System.UInt64,System.UInt64>.AdditiveIdentity { get; } + static ulong System.Numerics.IBinaryNumber<System.UInt64>.AllBitsSet { get; } + static ulong System.Numerics.IMinMaxValue<System.UInt64>.MaxValue { get; } + static ulong System.Numerics.IMinMaxValue<System.UInt64>.MinValue { get; } + static ulong System.Numerics.IMultiplicativeIdentity<System.UInt64,System.UInt64>.MultiplicativeIdentity { get; } + static ulong System.Numerics.INumberBase<System.UInt64>.One { get; } + static int System.Numerics.INumberBase<System.UInt64>.Radix { get; } + static ulong System.Numerics.INumberBase<System.UInt64>.Zero { get; } + public static ulong Clamp(ulong value, ulong min, ulong max); + public static ulong CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ulong CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static ulong CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (ulong Quotient, ulong Remainder) DivRem(ulong left, ulong right); + public static bool IsEvenInteger(ulong value); + public static bool IsOddInteger(ulong value); + public static bool IsPow2(ulong value); + public static ulong LeadingZeroCount(ulong value); + public static ulong Log2(ulong value); + public static ulong Max(ulong x, ulong y); + public static ulong Min(ulong x, ulong y); + public static ulong Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static ulong PopCount(ulong value); + public static ulong RotateLeft(ulong value, int rotateAmount); + public static ulong RotateRight(ulong value, int rotateAmount); + public static int Sign(ulong value); + static ulong IAdditionOperators<ulong, ulong, ulong>.operator +(ulong left, ulong right); + static ulong IAdditionOperators<ulong, ulong, ulong>.operator checked +(ulong left, ulong right); + int IBinaryInteger<ulong>.GetByteCount(); + int IBinaryInteger<ulong>.GetShortestBitLength(); + static bool IBinaryInteger<ulong>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ulong value); + static bool IBinaryInteger<ulong>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out ulong value); + bool IBinaryInteger<ulong>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<ulong>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator &(ulong left, ulong right); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator |(ulong left, ulong right); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator ^(ulong left, ulong right); + static ulong IBitwiseOperators<ulong, ulong, ulong>.operator ~(ulong value); + static bool IComparisonOperators<ulong, ulong, bool>.operator >(ulong left, ulong right); + static bool IComparisonOperators<ulong, ulong, bool>.operator >=(ulong left, ulong right); + static bool IComparisonOperators<ulong, ulong, bool>.operator <(ulong left, ulong right); + static bool IComparisonOperators<ulong, ulong, bool>.operator <=(ulong left, ulong right); + static ulong IDecrementOperators<ulong>.operator checked --(ulong value); + static ulong IDecrementOperators<ulong>.operator --(ulong value); + static ulong IDivisionOperators<ulong, ulong, ulong>.operator /(ulong left, ulong right); + static bool IEqualityOperators<ulong, ulong, bool>.operator ==(ulong left, ulong right); + static bool IEqualityOperators<ulong, ulong, bool>.operator !=(ulong left, ulong right); + static ulong IIncrementOperators<ulong>.operator checked ++(ulong value); + static ulong IIncrementOperators<ulong>.operator ++(ulong value); + static ulong IModulusOperators<ulong, ulong, ulong>.operator %(ulong left, ulong right); + static ulong IMultiplyOperators<ulong, ulong, ulong>.operator checked *(ulong left, ulong right); + static ulong IMultiplyOperators<ulong, ulong, ulong>.operator *(ulong left, ulong right); + static ulong INumber<ulong>.CopySign(ulong value, ulong sign); + static ulong INumber<ulong>.MaxNumber(ulong x, ulong y); + static ulong INumber<ulong>.MinNumber(ulong x, ulong y); + static ulong INumberBase<ulong>.Abs(ulong value); + static bool INumberBase<ulong>.IsCanonical(ulong value); + static bool INumberBase<ulong>.IsComplexNumber(ulong value); + static bool INumberBase<ulong>.IsFinite(ulong value); + static bool INumberBase<ulong>.IsImaginaryNumber(ulong value); + static bool INumberBase<ulong>.IsInfinity(ulong value); + static bool INumberBase<ulong>.IsInteger(ulong value); + static bool INumberBase<ulong>.IsNaN(ulong value); + static bool INumberBase<ulong>.IsNegative(ulong value); + static bool INumberBase<ulong>.IsNegativeInfinity(ulong value); + static bool INumberBase<ulong>.IsNormal(ulong value); + static bool INumberBase<ulong>.IsPositive(ulong value); + static bool INumberBase<ulong>.IsPositiveInfinity(ulong value); + static bool INumberBase<ulong>.IsRealNumber(ulong value); + static bool INumberBase<ulong>.IsSubnormal(ulong value); + static bool INumberBase<ulong>.IsZero(ulong value); + static ulong INumberBase<ulong>.MaxMagnitude(ulong x, ulong y); + static ulong INumberBase<ulong>.MaxMagnitudeNumber(ulong x, ulong y); + static ulong INumberBase<ulong>.MinMagnitude(ulong x, ulong y); + static ulong INumberBase<ulong>.MinMagnitudeNumber(ulong x, ulong y); + static bool INumberBase<ulong>.TryConvertFromChecked<TOther>(TOther value, out ulong result); + static bool INumberBase<ulong>.TryConvertFromSaturating<TOther>(TOther value, out ulong result); + static bool INumberBase<ulong>.TryConvertFromTruncating<TOther>(TOther value, out ulong result); + static bool INumberBase<ulong>.TryConvertToChecked<TOther>(ulong value, out TOther result); + static bool INumberBase<ulong>.TryConvertToSaturating<TOther>(ulong value, out TOther result); + static bool INumberBase<ulong>.TryConvertToTruncating<TOther>(ulong value, out TOther result); + static ulong IShiftOperators<ulong, int, ulong>.operator <<(ulong value, int shiftAmount); + static ulong IShiftOperators<ulong, int, ulong>.operator >>(ulong value, int shiftAmount); + static ulong IShiftOperators<ulong, int, ulong>.operator >>>(ulong value, int shiftAmount); + static ulong ISubtractionOperators<ulong, ulong, ulong>.operator checked -(ulong left, ulong right); + static ulong ISubtractionOperators<ulong, ulong, ulong>.operator -(ulong left, ulong right); + static ulong IUnaryNegationOperators<ulong, ulong>.operator checked -(ulong value); + static ulong IUnaryNegationOperators<ulong, ulong>.operator -(ulong value); + static ulong IUnaryPlusOperators<ulong, ulong>.operator +(ulong value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static ulong TrailingZeroCount(ulong value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out ulong result); + public static bool TryParse(string? s, IFormatProvider? provider, out ulong result); } - public readonly struct UIntPtr : IComparable, IComparable<UIntPtr>, IEquatable<UIntPtr>, IFormattable, ISerializable, ISpanFormattable { + public readonly struct UIntPtr : IAdditionOperators<UIntPtr, UIntPtr, UIntPtr>, IAdditiveIdentity<UIntPtr, UIntPtr>, IBinaryInteger<UIntPtr>, IBinaryNumber<UIntPtr>, IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>, IComparable, IComparable<UIntPtr>, IComparisonOperators<UIntPtr, UIntPtr, bool>, IDecrementOperators<UIntPtr>, IDivisionOperators<UIntPtr, UIntPtr, UIntPtr>, IEqualityOperators<UIntPtr, UIntPtr, bool>, IEquatable<UIntPtr>, IFormattable, IIncrementOperators<UIntPtr>, IMinMaxValue<UIntPtr>, IModulusOperators<UIntPtr, UIntPtr, UIntPtr>, IMultiplicativeIdentity<UIntPtr, UIntPtr>, IMultiplyOperators<UIntPtr, UIntPtr, UIntPtr>, INumber<UIntPtr>, INumberBase<UIntPtr>, IParsable<UIntPtr>, ISerializable, IShiftOperators<UIntPtr, int, UIntPtr>, ISpanFormattable, ISpanParsable<UIntPtr>, ISubtractionOperators<UIntPtr, UIntPtr, UIntPtr>, IUnaryNegationOperators<UIntPtr, UIntPtr>, IUnaryPlusOperators<UIntPtr, UIntPtr>, IUnsignedNumber<UIntPtr> { + static UIntPtr System.Numerics.IAdditiveIdentity<nuint,nuint>.AdditiveIdentity { get; } + static UIntPtr System.Numerics.IBinaryNumber<nuint>.AllBitsSet { get; } + static UIntPtr System.Numerics.IMinMaxValue<nuint>.MaxValue { get; } + static UIntPtr System.Numerics.IMinMaxValue<nuint>.MinValue { get; } + static UIntPtr System.Numerics.IMultiplicativeIdentity<nuint,nuint>.MultiplicativeIdentity { get; } + static UIntPtr System.Numerics.INumberBase<nuint>.One { get; } + static int System.Numerics.INumberBase<nuint>.Radix { get; } + static UIntPtr System.Numerics.INumberBase<nuint>.Zero { get; } + public static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max); + public static UIntPtr CreateChecked<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UIntPtr CreateSaturating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static UIntPtr CreateTruncating<TOther>(TOther value) where TOther : INumberBase<TOther>; + public static (UIntPtr Quotient, UIntPtr Remainder) DivRem(UIntPtr left, UIntPtr right); + public static bool IsEvenInteger(UIntPtr value); + public static bool IsOddInteger(UIntPtr value); + public static bool IsPow2(UIntPtr value); + public static UIntPtr LeadingZeroCount(UIntPtr value); + public static UIntPtr Log2(UIntPtr value); + public static UIntPtr Max(UIntPtr x, UIntPtr y); + public static UIntPtr Min(UIntPtr x, UIntPtr y); + public static UIntPtr Parse(ReadOnlySpan<char> s, IFormatProvider? provider); + public static UIntPtr PopCount(UIntPtr value); + public static UIntPtr RotateLeft(UIntPtr value, int rotateAmount); + public static UIntPtr RotateRight(UIntPtr value, int rotateAmount); + public static int Sign(UIntPtr value); + static UIntPtr IAdditionOperators<UIntPtr, UIntPtr, UIntPtr>.operator +(UIntPtr left, UIntPtr right); + static UIntPtr IAdditionOperators<UIntPtr, UIntPtr, UIntPtr>.operator checked +(UIntPtr left, UIntPtr right); + int IBinaryInteger<UIntPtr>.GetByteCount(); + int IBinaryInteger<UIntPtr>.GetShortestBitLength(); + static bool IBinaryInteger<UIntPtr>.TryReadBigEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UIntPtr value); + static bool IBinaryInteger<UIntPtr>.TryReadLittleEndian(ReadOnlySpan<byte> source, bool isUnsigned, out UIntPtr value); + bool IBinaryInteger<UIntPtr>.TryWriteBigEndian(Span<byte> destination, out int bytesWritten); + bool IBinaryInteger<UIntPtr>.TryWriteLittleEndian(Span<byte> destination, out int bytesWritten); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator &(UIntPtr left, UIntPtr right); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator |(UIntPtr left, UIntPtr right); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator ^(UIntPtr left, UIntPtr right); + static UIntPtr IBitwiseOperators<UIntPtr, UIntPtr, UIntPtr>.operator ~(UIntPtr value); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator >(UIntPtr left, UIntPtr right); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator >=(UIntPtr left, UIntPtr right); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator <(UIntPtr left, UIntPtr right); + static bool IComparisonOperators<UIntPtr, UIntPtr, bool>.operator <=(UIntPtr left, UIntPtr right); + static UIntPtr IDecrementOperators<UIntPtr>.operator checked --(UIntPtr value); + static UIntPtr IDecrementOperators<UIntPtr>.operator --(UIntPtr value); + static UIntPtr IDivisionOperators<UIntPtr, UIntPtr, UIntPtr>.operator /(UIntPtr left, UIntPtr right); + static UIntPtr IIncrementOperators<UIntPtr>.operator checked ++(UIntPtr value); + static UIntPtr IIncrementOperators<UIntPtr>.operator ++(UIntPtr value); + static UIntPtr IModulusOperators<UIntPtr, UIntPtr, UIntPtr>.operator %(UIntPtr left, UIntPtr right); + static UIntPtr IMultiplyOperators<UIntPtr, UIntPtr, UIntPtr>.operator checked *(UIntPtr left, UIntPtr right); + static UIntPtr IMultiplyOperators<UIntPtr, UIntPtr, UIntPtr>.operator *(UIntPtr left, UIntPtr right); + static UIntPtr INumber<UIntPtr>.CopySign(UIntPtr value, UIntPtr sign); + static UIntPtr INumber<UIntPtr>.MaxNumber(UIntPtr x, UIntPtr y); + static UIntPtr INumber<UIntPtr>.MinNumber(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.Abs(UIntPtr value); + static bool INumberBase<UIntPtr>.IsCanonical(UIntPtr value); + static bool INumberBase<UIntPtr>.IsComplexNumber(UIntPtr value); + static bool INumberBase<UIntPtr>.IsFinite(UIntPtr value); + static bool INumberBase<UIntPtr>.IsImaginaryNumber(UIntPtr value); + static bool INumberBase<UIntPtr>.IsInfinity(UIntPtr value); + static bool INumberBase<UIntPtr>.IsInteger(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNaN(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNegative(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNegativeInfinity(UIntPtr value); + static bool INumberBase<UIntPtr>.IsNormal(UIntPtr value); + static bool INumberBase<UIntPtr>.IsPositive(UIntPtr value); + static bool INumberBase<UIntPtr>.IsPositiveInfinity(UIntPtr value); + static bool INumberBase<UIntPtr>.IsRealNumber(UIntPtr value); + static bool INumberBase<UIntPtr>.IsSubnormal(UIntPtr value); + static bool INumberBase<UIntPtr>.IsZero(UIntPtr value); + static UIntPtr INumberBase<UIntPtr>.MaxMagnitude(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.MaxMagnitudeNumber(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.MinMagnitude(UIntPtr x, UIntPtr y); + static UIntPtr INumberBase<UIntPtr>.MinMagnitudeNumber(UIntPtr x, UIntPtr y); + static bool INumberBase<UIntPtr>.TryConvertFromChecked<TOther>(TOther value, out UIntPtr result); + static bool INumberBase<UIntPtr>.TryConvertFromSaturating<TOther>(TOther value, out UIntPtr result); + static bool INumberBase<UIntPtr>.TryConvertFromTruncating<TOther>(TOther value, out UIntPtr result); + static bool INumberBase<UIntPtr>.TryConvertToChecked<TOther>(UIntPtr value, out TOther result); + static bool INumberBase<UIntPtr>.TryConvertToSaturating<TOther>(UIntPtr value, out TOther result); + static bool INumberBase<UIntPtr>.TryConvertToTruncating<TOther>(UIntPtr value, out TOther result); + static UIntPtr IShiftOperators<UIntPtr, int, UIntPtr>.operator <<(UIntPtr value, int shiftAmount); + static UIntPtr IShiftOperators<UIntPtr, int, UIntPtr>.operator >>(UIntPtr value, int shiftAmount); + static UIntPtr IShiftOperators<UIntPtr, int, UIntPtr>.operator >>>(UIntPtr value, int shiftAmount); + static UIntPtr ISubtractionOperators<UIntPtr, UIntPtr, UIntPtr>.operator checked -(UIntPtr left, UIntPtr right); + static UIntPtr ISubtractionOperators<UIntPtr, UIntPtr, UIntPtr>.operator -(UIntPtr left, UIntPtr right); + static UIntPtr IUnaryNegationOperators<UIntPtr, UIntPtr>.operator checked -(UIntPtr value); + static UIntPtr IUnaryNegationOperators<UIntPtr, UIntPtr>.operator -(UIntPtr value); + static UIntPtr IUnaryPlusOperators<UIntPtr, UIntPtr>.operator +(UIntPtr value); public string ToString(string? format); public string ToString(string? format, IFormatProvider? provider); + public static UIntPtr TrailingZeroCount(UIntPtr value); public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default(ReadOnlySpan<char>), IFormatProvider? provider = null); + public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out UIntPtr result); + public static bool TryParse(string? s, IFormatProvider? provider, out UIntPtr result); } public class Uri : ISerializable { public Uri(string uriString); public Uri(string uriString, bool dontEscape); public Uri(string uriString, in UriCreationOptions creationOptions); public Uri(string uriString, UriKind uriKind); protected static string EscapeString(string? str); public static string EscapeUriString(string stringToEscape); public static bool IsWellFormedUriString(string? uriString, UriKind uriKind); public string MakeRelative(Uri toUri); public static bool TryCreate(string? uriString, in UriCreationOptions creationOptions, out Uri? result); public static bool TryCreate(string? uriString, UriKind uriKind, out Uri? result); } public class UriBuilder { public UriBuilder(string uri); } public struct UriCreationOptions public class UriTypeConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System"},{"location":"Microsoft.WindowsDesktop.App/7.0/","text":"API Difference 6.0 vs 7.0 API listing follows standard diff formatting. Lines preceded by a '+' are additions and a '-' indicates removal. System.Diagnostics System.Diagnostics.Eventing.Reader System.Drawing System.Drawing.Design System.Drawing.Imaging System.Drawing.Printing System.Resources.Tools System.Security.Cryptography.Pkcs System.Security.Cryptography.X509Certificates System.Security.Permissions System.Security.Policy System.Windows.Forms System.Windows.Forms.Design System.Windows.Forms.Layout System.Windows.Forms.PropertyGridInternal System.Xaml.Permissions","title":"API Difference 6.0 vs 7.0"},{"location":"Microsoft.WindowsDesktop.App/7.0/#api-difference-60-vs-70","text":"API listing follows standard diff formatting. Lines preceded by a '+' are additions and a '-' indicates removal. System.Diagnostics System.Diagnostics.Eventing.Reader System.Drawing System.Drawing.Design System.Drawing.Imaging System.Drawing.Printing System.Resources.Tools System.Security.Cryptography.Pkcs System.Security.Cryptography.X509Certificates System.Security.Permissions System.Security.Policy System.Windows.Forms System.Windows.Forms.Design System.Windows.Forms.Layout System.Windows.Forms.PropertyGridInternal System.Xaml.Permissions","title":"API Difference 6.0 vs 7.0"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Diagnostics.Eventing.Reader/","text":"System.Diagnostics.Eventing.Reader namespace System.Diagnostics.Eventing.Reader { - public class EventBookmark { + public sealed class EventBookmark { + public EventBookmark(string bookmarkXml); + public string BookmarkXml { get; } } }","title":"System.Diagnostics.Eventing.Reader"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Diagnostics.Eventing.Reader/#systemdiagnosticseventingreader","text":"namespace System.Diagnostics.Eventing.Reader { - public class EventBookmark { + public sealed class EventBookmark { + public EventBookmark(string bookmarkXml); + public string BookmarkXml { get; } } }","title":"System.Diagnostics.Eventing.Reader"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Diagnostics/","text":"System.Diagnostics namespace System.Diagnostics { - public readonly struct CounterSample + public readonly struct CounterSample : IEquatable<CounterSample> public sealed class PerformanceCounter : Component, ISupportInitialize { public static int DefaultFileMappingSize; } + public static class TraceConfiguration { + public static void Register(); + } }","title":"System.Diagnostics"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Diagnostics/#systemdiagnostics","text":"namespace System.Diagnostics { - public readonly struct CounterSample + public readonly struct CounterSample : IEquatable<CounterSample> public sealed class PerformanceCounter : Component, ISupportInitialize { public static int DefaultFileMappingSize; } + public static class TraceConfiguration { + public static void Register(); + } }","title":"System.Diagnostics"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing.Design/","text":"System.Drawing.Design namespace System.Drawing.Design { public class UITypeEditor { - public void PaintValue(object value, Graphics canvas, Rectangle rectangle); + public void PaintValue(object? value, Graphics canvas, Rectangle rectangle); } }","title":"System.Drawing.Design"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing.Design/#systemdrawingdesign","text":"namespace System.Drawing.Design { public class UITypeEditor { - public void PaintValue(object value, Graphics canvas, Rectangle rectangle); + public void PaintValue(object? value, Graphics canvas, Rectangle rectangle); } }","title":"System.Drawing.Design"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing.Imaging/","text":"System.Drawing.Imaging namespace System.Drawing.Imaging { public sealed class ImageFormat { + public static ImageFormat Heif { get; } + public static ImageFormat Webp { get; } } }","title":"System.Drawing.Imaging"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing.Imaging/#systemdrawingimaging","text":"namespace System.Drawing.Imaging { public sealed class ImageFormat { + public static ImageFormat Heif { get; } + public static ImageFormat Webp { get; } } }","title":"System.Drawing.Imaging"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing.Printing/","text":"System.Drawing.Printing namespace System.Drawing.Printing { public class MarginsConverter : ExpandableObjectConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Drawing.Printing"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing.Printing/#systemdrawingprinting","text":"namespace System.Drawing.Printing { public class MarginsConverter : ExpandableObjectConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Drawing.Printing"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing/","text":"System.Drawing namespace System.Drawing { - public struct CharacterRange { + public struct CharacterRange : IEquatable<CharacterRange> { + public bool Equals(CharacterRange other); } public class FontConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public sealed class Graphics : MarshalByRefObject, IDeviceContext, IDisposable { + public void DrawRectangle(Pen pen, RectangleF rect); + public void FillPie(Brush brush, RectangleF rect, float startAngle, float sweepAngle); public void GetContextInfo(out PointF offset); public void GetContextInfo(out PointF offset, out Region? clip); - public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData); + public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback? callbackData); } public class IconConverter : ExpandableObjectConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public sealed class ImageAnimator { - public static void UpdateFrames(Image image); + public static void UpdateFrames(Image? image); } public class ImageConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class ImageFormatConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Drawing"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Drawing/#systemdrawing","text":"namespace System.Drawing { - public struct CharacterRange { + public struct CharacterRange : IEquatable<CharacterRange> { + public bool Equals(CharacterRange other); } public class FontConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public sealed class Graphics : MarshalByRefObject, IDeviceContext, IDisposable { + public void DrawRectangle(Pen pen, RectangleF rect); + public void FillPie(Brush brush, RectangleF rect, float startAngle, float sweepAngle); public void GetContextInfo(out PointF offset); public void GetContextInfo(out PointF offset, out Region? clip); - public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData); + public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback? callbackData); } public class IconConverter : ExpandableObjectConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public sealed class ImageAnimator { - public static void UpdateFrames(Image image); + public static void UpdateFrames(Image? image); } public class ImageConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } public class ImageFormatConverter : TypeConverter { public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); } }","title":"System.Drawing"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Resources.Tools/","text":"System.Resources.Tools +namespace System.Resources.Tools { + public interface ITargetAwareCodeDomProvider { + bool SupportsProperty(Type type, string propertyName, bool isWritable); + } + public static class StronglyTypedResourceBuilder { + public static CodeCompileUnit Create(IDictionary resourceList, string baseName, string generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static CodeCompileUnit Create(IDictionary resourceList, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static string VerifyResourceName(string key, CodeDomProvider provider); + } +}","title":"System.Resources.Tools"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Resources.Tools/#systemresourcestools","text":"+namespace System.Resources.Tools { + public interface ITargetAwareCodeDomProvider { + bool SupportsProperty(Type type, string propertyName, bool isWritable); + } + public static class StronglyTypedResourceBuilder { + public static CodeCompileUnit Create(IDictionary resourceList, string baseName, string generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static CodeCompileUnit Create(IDictionary resourceList, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, out string[] unmatchable); + public static string VerifyResourceName(string key, CodeDomProvider provider); + } +}","title":"System.Resources.Tools"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Cryptography.Pkcs/","text":"System.Security.Cryptography.Pkcs namespace System.Security.Cryptography.Pkcs { public sealed class CmsSigner { - public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2? certificate); + public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate); - public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2? certificate, AsymmetricAlgorithm? privateKey); + public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate, AsymmetricAlgorithm privateKey); + public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate, RSA privateKey, RSASignaturePadding signaturePadding); - public CmsSigner(X509Certificate2? certificate); + public CmsSigner(X509Certificate2 certificate); - public X509Certificate2? Certificate { get; set; } + public X509Certificate2 Certificate { get; set; } - public AsymmetricAlgorithm? PrivateKey { get; set; } + public AsymmetricAlgorithm PrivateKey { get; set; } + public RSASignaturePadding SignaturePadding { get; set; } } }","title":"System.Security.Cryptography.Pkcs"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Cryptography.Pkcs/#systemsecuritycryptographypkcs","text":"namespace System.Security.Cryptography.Pkcs { public sealed class CmsSigner { - public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2? certificate); + public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate); - public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2? certificate, AsymmetricAlgorithm? privateKey); + public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate, AsymmetricAlgorithm privateKey); + public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate, RSA privateKey, RSASignaturePadding signaturePadding); - public CmsSigner(X509Certificate2? certificate); + public CmsSigner(X509Certificate2 certificate); - public X509Certificate2? Certificate { get; set; } + public X509Certificate2 Certificate { get; set; } - public AsymmetricAlgorithm? PrivateKey { get; set; } + public AsymmetricAlgorithm PrivateKey { get; set; } + public RSASignaturePadding SignaturePadding { get; set; } } }","title":"System.Security.Cryptography.Pkcs"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Cryptography.X509Certificates/","text":"System.Security.Cryptography.X509Certificates namespace System.Security.Cryptography.X509Certificates { public sealed class X509Certificate2UI { - public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag); + public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string? title, string? message, X509SelectionFlag selectionFlag); - public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag, IntPtr hwndParent); + public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string? title, string? message, X509SelectionFlag selectionFlag, IntPtr hwndParent); } }","title":"System.Security.Cryptography.X509Certificates"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Cryptography.X509Certificates/#systemsecuritycryptographyx509certificates","text":"namespace System.Security.Cryptography.X509Certificates { public sealed class X509Certificate2UI { - public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag); + public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string? title, string? message, X509SelectionFlag selectionFlag); - public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string title, string message, X509SelectionFlag selectionFlag, IntPtr hwndParent); + public static X509Certificate2Collection SelectFromCollection(X509Certificate2Collection certificates, string? title, string? message, X509SelectionFlag selectionFlag, IntPtr hwndParent); } }","title":"System.Security.Cryptography.X509Certificates"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Permissions/","text":"System.Security.Permissions namespace System.Security.Permissions { public sealed class ReflectionPermissionAttribute : CodeAccessSecurityAttribute { public bool ReflectionEmit { get; set; } public bool TypeInformation { get; set; } } public enum ReflectionPermissionFlag { AllFlags = 7, ReflectionEmit = 4, TypeInformation = 1, } public sealed class RegistryPermissionAttribute : CodeAccessSecurityAttribute { public string All { get; set; } } }","title":"System.Security.Permissions"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Permissions/#systemsecuritypermissions","text":"namespace System.Security.Permissions { public sealed class ReflectionPermissionAttribute : CodeAccessSecurityAttribute { public bool ReflectionEmit { get; set; } public bool TypeInformation { get; set; } } public enum ReflectionPermissionFlag { AllFlags = 7, ReflectionEmit = 4, TypeInformation = 1, } public sealed class RegistryPermissionAttribute : CodeAccessSecurityAttribute { public string All { get; set; } } }","title":"System.Security.Permissions"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Policy/","text":"System.Security.Policy namespace System.Security.Policy { public sealed class PolicyLevel { public IList FullTrustAssemblies { get; } public void AddFullTrustAssembly(StrongName sn); public void AddFullTrustAssembly(StrongNameMembershipCondition snMC); public void RemoveFullTrustAssembly(StrongName sn); public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC); } }","title":"System.Security.Policy"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Security.Policy/#systemsecuritypolicy","text":"namespace System.Security.Policy { public sealed class PolicyLevel { public IList FullTrustAssemblies { get; } public void AddFullTrustAssembly(StrongName sn); public void AddFullTrustAssembly(StrongNameMembershipCondition snMC); public void RemoveFullTrustAssembly(StrongName sn); public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC); } }","title":"System.Security.Policy"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.Design/","text":"System.Windows.Forms.Design namespace System.Windows.Forms.Design { public class ComponentEditorForm : Form { - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; - protected virtual void OnSelChangeSelector(object source, TreeViewEventArgs e); + protected virtual void OnSelChangeSelector(object? source, TreeViewEventArgs e); - public virtual DialogResult ShowForm(IWin32Window owner); + public virtual DialogResult ShowForm(IWin32Window? owner); - public virtual DialogResult ShowForm(IWin32Window owner, int page); + public virtual DialogResult ShowForm(IWin32Window? owner, int page); } public abstract class ComponentEditorPage : Panel { public Icon Icon { get; set; } } public interface IWindowsFormsEditorService { - void DropDownControl(Control control); + void DropDownControl(Control? control); } public abstract class PropertyTab : IExtenderProvider { - public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object component, Attribute[]? attributes); + public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[]? attributes); - public virtual PropertyDescriptorCollection GetProperties(object component); + public virtual PropertyDescriptorCollection? GetProperties(object component); - public abstract PropertyDescriptorCollection GetProperties(object component, Attribute[]? attributes); + public abstract PropertyDescriptorCollection? GetProperties(object component, Attribute[]? attributes); } public sealed class ToolStripItemDesignerAvailabilityAttribute : Attribute { - public override bool Equals(object obj); + public override bool Equals(object? obj); } public abstract class WindowsFormsComponentEditor : ComponentEditor { - public override bool EditComponent(ITypeDescriptorContext context, object component); + public override bool EditComponent(ITypeDescriptorContext? context, object component); - public virtual bool EditComponent(ITypeDescriptorContext context, object component, IWin32Window owner); + public virtual bool EditComponent(ITypeDescriptorContext? context, object component, IWin32Window? owner); - public bool EditComponent(object component, IWin32Window owner); + public bool EditComponent(object component, IWin32Window? owner); - protected virtual Type[] GetComponentEditorPages(); + protected virtual Type[]? GetComponentEditorPages(); } }","title":"System.Windows.Forms.Design"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.Design/#systemwindowsformsdesign","text":"namespace System.Windows.Forms.Design { public class ComponentEditorForm : Form { - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; - protected virtual void OnSelChangeSelector(object source, TreeViewEventArgs e); + protected virtual void OnSelChangeSelector(object? source, TreeViewEventArgs e); - public virtual DialogResult ShowForm(IWin32Window owner); + public virtual DialogResult ShowForm(IWin32Window? owner); - public virtual DialogResult ShowForm(IWin32Window owner, int page); + public virtual DialogResult ShowForm(IWin32Window? owner, int page); } public abstract class ComponentEditorPage : Panel { public Icon Icon { get; set; } } public interface IWindowsFormsEditorService { - void DropDownControl(Control control); + void DropDownControl(Control? control); } public abstract class PropertyTab : IExtenderProvider { - public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object component, Attribute[]? attributes); + public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[]? attributes); - public virtual PropertyDescriptorCollection GetProperties(object component); + public virtual PropertyDescriptorCollection? GetProperties(object component); - public abstract PropertyDescriptorCollection GetProperties(object component, Attribute[]? attributes); + public abstract PropertyDescriptorCollection? GetProperties(object component, Attribute[]? attributes); } public sealed class ToolStripItemDesignerAvailabilityAttribute : Attribute { - public override bool Equals(object obj); + public override bool Equals(object? obj); } public abstract class WindowsFormsComponentEditor : ComponentEditor { - public override bool EditComponent(ITypeDescriptorContext context, object component); + public override bool EditComponent(ITypeDescriptorContext? context, object component); - public virtual bool EditComponent(ITypeDescriptorContext context, object component, IWin32Window owner); + public virtual bool EditComponent(ITypeDescriptorContext? context, object component, IWin32Window? owner); - public bool EditComponent(object component, IWin32Window owner); + public bool EditComponent(object component, IWin32Window? owner); - protected virtual Type[] GetComponentEditorPages(); + protected virtual Type[]? GetComponentEditorPages(); } }","title":"System.Windows.Forms.Design"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.Layout/","text":"System.Windows.Forms.Layout namespace System.Windows.Forms.Layout { public class ArrangedElementCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public override bool Equals(object obj); + public override bool Equals(object? obj); - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object value); + bool IList.Contains(object? value); - int IList.IndexOf(object value); + int IList.IndexOf(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class TableLayoutSettingsTypeConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override bool CanConvertTo(ITypeDescriptorContext? context, Type? destinationType); - public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); } }","title":"System.Windows.Forms.Layout"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.Layout/#systemwindowsformslayout","text":"namespace System.Windows.Forms.Layout { public class ArrangedElementCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public override bool Equals(object obj); + public override bool Equals(object? obj); - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object value); + bool IList.Contains(object? value); - int IList.IndexOf(object value); + int IList.IndexOf(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class TableLayoutSettingsTypeConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override bool CanConvertTo(ITypeDescriptorContext? context, Type? destinationType); - public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); } }","title":"System.Windows.Forms.Layout"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.PropertyGridInternal/","text":"System.Windows.Forms.PropertyGridInternal namespace System.Windows.Forms.PropertyGridInternal { public class PropertiesTab : PropertyTab { - public override PropertyDescriptor GetDefaultProperty(object obj); + public override PropertyDescriptor? GetDefaultProperty(object obj); - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attributes); + public override PropertyDescriptorCollection? GetProperties(ITypeDescriptorContext? context, object component, Attribute[]? attributes); - public override PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes); + public override PropertyDescriptorCollection? GetProperties(object component, Attribute[]? attributes); } }","title":"System.Windows.Forms.PropertyGridInternal"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms.PropertyGridInternal/#systemwindowsformspropertygridinternal","text":"namespace System.Windows.Forms.PropertyGridInternal { public class PropertiesTab : PropertyTab { - public override PropertyDescriptor GetDefaultProperty(object obj); + public override PropertyDescriptor? GetDefaultProperty(object obj); - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attributes); + public override PropertyDescriptorCollection? GetProperties(ITypeDescriptorContext? context, object component, Attribute[]? attributes); - public override PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes); + public override PropertyDescriptorCollection? GetProperties(object component, Attribute[]? attributes); } }","title":"System.Windows.Forms.PropertyGridInternal"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms/","text":"System.Windows.Forms namespace System.Windows.Forms { public class AccessibleObject : StandardOleMarshalObject, IAccessible, Interop.Ole32.IOleWindow, Interop.Ole32.IServiceProvider, Interop.Oleaut32.IEnumVariant, Interop.UiaCore.IAccessibleEx, Interop.UiaCore.IExpandCollapseProvider, Interop.UiaCore.IGridItemProvider, Interop.UiaCore.IGridProvider, Interop.UiaCore.IInvokeProvider, Interop.UiaCore.ILegacyIAccessibleProvider, Interop.UiaCore.IMultipleViewProvider, Interop.UiaCore.IRangeValueProvider, Interop.UiaCore.IRawElementProviderFragment, Interop.UiaCore.IRawElementProviderFragmentRoot, Interop.UiaCore.IRawElementProviderHwndOverride, Interop.UiaCore.IRawElementProviderSimple, Interop.UiaCore.IScrollItemProvider, Interop.UiaCore.ISelectionItemProvider, Interop.UiaCore.ISelectionProvider, Interop.UiaCore.ITableItemProvider, Interop.UiaCore.ITableProvider, Interop.UiaCore.ITextProvider, Interop.UiaCore.ITextProvider2, Interop.UiaCore.IToggleProvider, Interop.UiaCore.IValueProvider, IReflect { FieldInfo? IReflect.GetField(string name, BindingFlags bindingAttr); FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr); MemberInfo[] IReflect.GetMember(string name, BindingFlags bindingAttr); MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr); MethodInfo? IReflect.GetMethod(string name, BindingFlags bindingAttr); MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers); MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr); PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr); PropertyInfo? IReflect.GetProperty(string name, BindingFlags bindingAttr); PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers); object IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[]? namedParameters); } public abstract class AxHost : Control, ICustomTypeDescriptor, ISupportInitialize { TypeConverter ICustomTypeDescriptor.GetConverter(); EventDescriptor ICustomTypeDescriptor.GetDefaultEvent(); PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty(); object ICustomTypeDescriptor.GetEditor(Type editorBaseType); EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes); PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(); PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes); public class AxComponentEditor : WindowsFormsComponentEditor { - public override bool EditComponent(ITypeDescriptorContext context, object obj, IWin32Window parent); + public override bool EditComponent(ITypeDescriptorContext? context, object obj, IWin32Window? parent); } public sealed class ClsidAttribute : Attribute { public string Value { get; } } public class State : ISerializable { - public State(Stream ms, int storageType, bool manualUpdate, string licKey); + public State(Stream ms, int storageType, bool manualUpdate, string? licKey); } public class StateConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); } public sealed class TypeLibraryTimeStampAttribute : Attribute { public DateTime Value { get; } } } + public abstract class BindableComponent : Component, IBindableComponent, IComponent, IDisposable { + protected BindableComponent(); + public BindingContext? BindingContext { get; set; } + public ControlBindingsCollection DataBindings { get; } + public event EventHandler BindingContextChanged; + protected virtual void OnBindingContextChanged(EventArgs e); + } public abstract class BindingManagerBase { - protected EventHandler onCurrentChangedHandler; + protected EventHandler? onCurrentChangedHandler; - protected EventHandler onPositionChangedHandler; + protected EventHandler? onPositionChangedHandler; - protected internal virtual PropertyDescriptorCollection GetItemProperties(ArrayList dataSources, ArrayList listAccessors); + protected internal virtual PropertyDescriptorCollection? GetItemProperties(ArrayList dataSources, ArrayList listAccessors); - protected virtual PropertyDescriptorCollection GetItemProperties(Type listType, int offset, ArrayList dataSources, ArrayList listAccessors); + protected virtual PropertyDescriptorCollection? GetItemProperties(Type listType, int offset, ArrayList dataSources, ArrayList listAccessors); - protected internal abstract string GetListName(ArrayList listAccessors); + protected internal abstract string GetListName(ArrayList? listAccessors); } - public struct BindingMemberInfo { + public struct BindingMemberInfo : IEquatable<BindingMemberInfo> { + public bool Equals(BindingMemberInfo other); } public class BindingSource : Component, IBindingList, IBindingListView, ICancelAddNew, ICollection, ICurrencyManagerProvider, IEnumerable, IList, ISupportInitialize, ISupportInitializeNotification, ITypedList { public virtual string Filter { get; set; } } public class Button : ButtonBase, IButtonControl { - public new event EventHandler DoubleClick; + public new event EventHandler? DoubleClick; - public new event MouseEventHandler MouseDoubleClick; + public new event MouseEventHandler? MouseDoubleClick; } public abstract class ButtonBase : Control { + public ICommand? Command { get; set; } + public object? CommandParameter { get; set; } - public Image Image { get; set; } + public Image? Image { get; set; } - public ImageList ImageList { get; set; } + public ImageList? ImageList { get; set; } public override string Text { get; set; } - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; + public event EventHandler? CommandCanExecuteChanged; + public event EventHandler? CommandChanged; + public event EventHandler? CommandParameterChanged; - public new event EventHandler ImeModeChanged; + public new event EventHandler? ImeModeChanged; + protected override void OnClick(EventArgs e); + protected virtual void OnCommandCanExecuteChanged(EventArgs e); + protected virtual void OnCommandChanged(EventArgs e); + protected virtual void OnCommandParameterChanged(EventArgs e); + protected virtual void OnRequestCommandExecute(EventArgs e); } public static class ButtonRenderer { - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, bool focused, PushButtonState state); - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, Image image, Rectangle imageBounds, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, Image image, Rectangle imageBounds, bool focused, PushButtonState state); - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, TextFormatFlags flags, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, TextFormatFlags flags, bool focused, PushButtonState state); - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, PushButtonState state); } public class CheckBox : ButtonBase { - public event EventHandler AppearanceChanged; + public event EventHandler? AppearanceChanged; - public event EventHandler CheckedChanged; + public event EventHandler? CheckedChanged; - public event EventHandler CheckStateChanged; + public event EventHandler? CheckStateChanged; - public new event EventHandler DoubleClick; + public new event EventHandler? DoubleClick; - public new event MouseEventHandler MouseDoubleClick; + public new event MouseEventHandler? MouseDoubleClick; } public static class CheckBoxRenderer { - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, bool focused, CheckBoxState state); - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, TextFormatFlags flags, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, TextFormatFlags flags, bool focused, CheckBoxState state); - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); } public class CheckedListBox : ListBox { - public new object DataSource { get; set; } + public new object? DataSource { get; set; } - public new event EventHandler Click; + public new event EventHandler? Click; - public new event EventHandler DataSourceChanged; + public new event EventHandler? DataSourceChanged; - public new event EventHandler DisplayMemberChanged; + public new event EventHandler? DisplayMemberChanged; - public new event DrawItemEventHandler DrawItem; + public new event DrawItemEventHandler? DrawItem; - public event ItemCheckEventHandler ItemCheck; + public event ItemCheckEventHandler? ItemCheck; - public new event MeasureItemEventHandler MeasureItem; + public new event MeasureItemEventHandler? MeasureItem; - public new event MouseEventHandler MouseClick; + public new event MouseEventHandler? MouseClick; - public new event EventHandler ValueMemberChanged; + public new event EventHandler? ValueMemberChanged; public class CheckedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object index); + bool IList.Contains(object? index); - int IList.IndexOf(object index); + int IList.IndexOf(object? index); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class CheckedItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - public object this[int index] { get; set; } + public object? this[int index] { get; set; } - public bool Contains(object item); + public bool Contains(object? item); - public int IndexOf(object item); + public int IndexOf(object? item); - int IList.Add(object value); + int IList.Add(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } } public static class Clipboard { - public static bool ContainsData(string format); + public static bool ContainsData(string? format); - public static Stream GetAudioStream(); + public static Stream? GetAudioStream(); - public static object GetData(string format); + public static object? GetData(string format); - public static IDataObject GetDataObject(); + public static IDataObject? GetDataObject(); - public static Image GetImage(); + public static Image? GetImage(); } public class ColorDialog : CommonDialog { public int[] CustomColors { get; set; } } public class ColumnHeader : Component, ICloneable { public string Text { get; set; } } public class ComboBox : ListControl { public class ChildAccessibleObject : AccessibleObject { - public override string Name { get; } + public override string? Name { get; } } } public static class ComboBoxRenderer { - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, Rectangle textBounds, TextFormatFlags flags, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, Rectangle textBounds, TextFormatFlags flags, ComboBoxState state); - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, Rectangle textBounds, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, Rectangle textBounds, ComboBoxState state); - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, TextFormatFlags flags, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, TextFormatFlags flags, ComboBoxState state); - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, ComboBoxState state); } public class ContainerControl : ScrollableControl, IContainerControl { - public Control ActiveControl { get; set; } + public Control? ActiveControl { get; set; } - public override BindingContext BindingContext { get; set; } + public override BindingContext? BindingContext { get; set; } - public Form ParentForm { get; } + public Form? ParentForm { get; } - public event EventHandler AutoValidateChanged; + public event EventHandler? AutoValidateChanged; + protected override void OnMove(EventArgs e); + protected override void OnResize(EventArgs e); + protected virtual void ScaleMinMaxSize(float xScaleFactor, float yScaleFactor, bool updateContainerSize = true); } public class ContextMenuStrip : ToolStripDropDownMenu { - public Control SourceControl { get; } + public Control? SourceControl { get; } } public class Control : Component, IArrangedElement, IBindableComponent, IComponent, IDisposable, IDropTarget, IHandle, IKeyboardToolTip, Interop.Ole32.IOleControl, Interop.Ole32.IOleInPlaceActiveObject, Interop.Ole32.IOleInPlaceObject, Interop.Ole32.IOleObject, Interop.Ole32.IOleWindow, Interop.Ole32.IPersist, Interop.Ole32.IPersistStorage, Interop.Ole32.IPersistStreamInit, Interop.Ole32.IQuickActivate, Interop.Ole32.IViewObject, Interop.Ole32.IViewObject2, Interop.Oleaut32.IPersistPropertyBag, ISupportOleDropSource, ISynchronizeInvoke, IWin32Window { public virtual Cursor Cursor { get; set; } + public virtual object DataContext { get; set; } public virtual Font Font { get; set; } public string Name { get; set; } public virtual string Text { get; set; } + public event EventHandler DataContextChanged; - public IAsyncResult BeginInvoke(Delegate method, params object[] args); + public IAsyncResult BeginInvoke(Delegate method, params object?[]? args); + public DragDropEffects DoDragDrop(object data, DragDropEffects allowedEffects, Bitmap? dragImage, Point cursorOffset, bool useDefaultDragImage); - public object EndInvoke(IAsyncResult asyncResult); + public object? EndInvoke(IAsyncResult asyncResult); - public object Invoke(Delegate method, params object[] args); + public object Invoke(Delegate method, params object?[]? args); + protected virtual void OnDataContextChanged(EventArgs e); + protected virtual void OnParentDataContextChanged(EventArgs e); public class ControlCollection : ArrangedElementCollection, ICloneable, ICollection, IEnumerable, IList { - public virtual Control this[string key] { get; } + public virtual Control? this[string? key] { get; } - public virtual void Add(Control value); + public virtual void Add(Control? value); - public bool Contains(Control control); + public bool Contains(Control? control); - public virtual bool ContainsKey(string key); + public virtual bool ContainsKey(string? key); - public int IndexOf(Control control); + public int IndexOf(Control? control); - public virtual int IndexOfKey(string key); + public virtual int IndexOfKey(string? key); - public virtual void Remove(Control value); + public virtual void Remove(Control? value); - public virtual void RemoveByKey(string key); + public virtual void RemoveByKey(string? key); - int IList.Add(object control); + int IList.Add(object? control); - void IList.Remove(object control); + void IList.Remove(object? control); } } public sealed class Cursor : IDisposable, IHandle, ISerializable { - public static Cursor? Current { get; set; } + public static Cursor Current { get; set; } - public object? Tag { get; set; } + public object Tag { get; set; } - public override bool Equals(object? obj); + public override bool Equals(object obj); } public class CursorConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class DataGridView : Control, ISupportInitialize { protected class DataGridViewTopRowAccessibleObject : AccessibleObject { - public DataGridView Owner { get; set; } + public DataGridView? Owner { get; set; } - public override AccessibleObject GetChild(int index); + public override AccessibleObject? GetChild(int index); - public override AccessibleObject Navigate(AccessibleNavigation navigationDirection); + public override AccessibleObject? Navigate(AccessibleNavigation navigationDirection); } } public sealed class DataGridViewAdvancedBorderStyle : ICloneable { - public override bool Equals(object other); + public override bool Equals(object? other); } public class DataGridViewBand : DataGridViewElement, ICloneable, IDisposable public class DataGridViewButtonCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewButtonColumn : DataGridViewColumn public abstract class DataGridViewCell : DataGridViewElement, ICloneable, IDisposable, IKeyboardToolTip { public virtual Type EditType { get; } } public class DataGridViewCheckBoxCell : DataGridViewCell, IDataGridViewEditingCell { public override Type EditType { get; } } public class DataGridViewColumn : DataGridViewBand, IComponent, IDisposable public class DataGridViewComboBoxCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewComboBoxColumn : DataGridViewColumn public class DataGridViewImageCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewImageColumn : DataGridViewColumn public class DataGridViewLinkCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewLinkColumn : DataGridViewColumn public class DataGridViewTextBoxEditingControl : TextBox, IDataGridViewEditingControl { - public virtual DataGridView EditingControlDataGridView { get; set; } + public virtual DataGridView? EditingControlDataGridView { get; set; } } public class DataObject : IDataObject, IDataObject { - public virtual Stream GetAudioStream(); + public virtual Stream? GetAudioStream(); - public virtual object GetData(string format); + public virtual object? GetData(string format); - public virtual object GetData(string format, bool autoConvert); + public virtual object? GetData(string format, bool autoConvert); - public virtual object GetData(Type format); + public virtual object? GetData(Type format); - public virtual Image GetImage(); + public virtual Image? GetImage(); - public virtual void SetData(object data); + public virtual void SetData(object? data); - public virtual void SetData(string format, bool autoConvert, object data); + public virtual void SetData(string format, bool autoConvert, object? data); - public virtual void SetData(string format, object data); + public virtual void SetData(string format, object? data); - public virtual void SetData(Type format, object data); + public virtual void SetData(Type format, object? data); - int IDataObject.EnumDAdvise(out IEnumSTATDATA enumAdvise); + int IDataObject.EnumDAdvise(out IEnumSTATDATA? enumAdvise); } public class DateTimePicker : Control { public Font CalendarFont { get; set; } public override string Text { get; set; } + protected override void OnGotFocus(EventArgs e); public class DateTimePickerAccessibleObject : Control.ControlAccessibleObject { + public override string DefaultAction { get; } - public override string KeyboardShortcut { get; } + public override string? KeyboardShortcut { get; } + public override string Name { get; } + public override void DoDefaultAction(); } } public sealed class DockingAttribute : Attribute { - public override bool Equals(object obj); + public override bool Equals(object? obj); } public class DomainUpDown : UpDownBase { - protected override void OnChanged(object source, EventArgs e); + protected override void OnChanged(object? source, EventArgs e); - protected void OnSelectedItemChanged(object source, EventArgs e); + protected void OnSelectedItemChanged(object? source, EventArgs e); - protected override void OnTextBoxKeyPress(object source, KeyPressEventArgs e); + protected override void OnTextBoxKeyPress(object? source, KeyPressEventArgs e); public class DomainItemAccessibleObject : AccessibleObject { - public DomainItemAccessibleObject(string name, AccessibleObject parent); + public DomainItemAccessibleObject(string? name, AccessibleObject parent); } public class DomainUpDownAccessibleObject : Control.ControlAccessibleObject { - public override AccessibleObject GetChild(int index); + public override AccessibleObject? GetChild(int index); } } public class DragEventArgs : EventArgs { + public DragEventArgs(IDataObject? data, int keyState, int x, int y, DragDropEffects allowedEffect, DragDropEffects effect, DropImageType dropImageType, string message, string messageReplacementToken); + public DropImageType DropImageType { get; set; } + public string Message { get; set; } + public string MessageReplacementToken { get; set; } } + public enum DropImageType { + Copy = 1, + Invalid = -1, + Label = 6, + Link = 4, + Move = 2, + NoImage = 8, + None = 0, + Warning = 7, + } public class ErrorProvider : Component, IExtenderProvider, ISupportInitialize { + public bool HasErrors { get; } } public abstract class FeatureSupport : IFeatureSupport { - public abstract Version GetVersionPresent(object feature); + public abstract Version? GetVersionPresent(object feature); - public static Version GetVersionPresent(string featureClassName, string featureConstName); + public static Version? GetVersionPresent(string featureClassName, string featureConstName); } public abstract class FileDialog : CommonDialog { + public bool AddToRecent { get; set; } public string DefaultExt { get; set; } public string FileName { get; set; } public string Filter { get; set; } public string InitialDirectory { get; set; } + public bool OkRequiresInteraction { get; set; } + public bool ShowHiddenFiles { get; set; } + public bool ShowPinnedPlaces { get; set; } public string Title { get; set; } } public sealed class FolderBrowserDialog : CommonDialog { + public bool AddToRecent { get; set; } + public bool OkRequiresInteraction { get; set; } + public bool ShowHiddenFiles { get; set; } + public bool ShowPinnedPlaces { get; set; } - public new event EventHandler HelpRequest; + public new event EventHandler? HelpRequest; public override void Reset(); } public class FontDialog : CommonDialog { - public event EventHandler Apply; + public event EventHandler? Apply; } public class Form : ContainerControl { public bool IsMdiChild { get; } public bool IsMdiContainer { get; set; } public override string Text { get; set; } + protected override void OnGotFocus(EventArgs e); + protected override void ScaleMinMaxSize(float xScaleFactor, float yScaleFactor, bool updateContainerSize = true); public new class ControlCollection : Control.ControlCollection { - public override void Add(Control value); + public override void Add(Control? value); - public override void Remove(Control value); + public override void Remove(Control? value); } } public class FormCollection : ReadOnlyCollectionBase { - public virtual Form this[int index] { get; } + public virtual Form? this[int index] { get; } - public virtual Form this[string name] { get; } + public virtual Form? this[string? name] { get; } } public class GiveFeedbackEventArgs : EventArgs { + public GiveFeedbackEventArgs(DragDropEffects effect, bool useDefaultCursors, Bitmap dragImage, Point cursorOffset, bool useDefaultDragImage); + public Point CursorOffset { get; set; } + public Bitmap DragImage { get; set; } + public bool UseDefaultDragImage { get; set; } } public class GroupBox : Control { public override string Text { get; set; } } public interface IDataGridViewEditingControl { - DataGridView EditingControlDataGridView { get; set; } + DataGridView? EditingControlDataGridView { get; set; } } public interface IDataObject { - object GetData(string format); + object? GetData(string format); - object GetData(string format, bool autoConvert); + object? GetData(string format, bool autoConvert); - object GetData(Type format); + object? GetData(Type format); - void SetData(object data); + void SetData(object? data); - void SetData(string format, bool autoConvert, object data); + void SetData(string format, bool autoConvert, object? data); - void SetData(string format, object data); + void SetData(string format, object? data); - void SetData(Type format, object data); + void SetData(Type format, object? data); } public interface IFeatureSupport { - Version GetVersionPresent(object feature); + Version? GetVersionPresent(object feature); } public class ImageIndexConverter : Int32Converter { - public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); - public override bool GetStandardValuesExclusive(ITypeDescriptorContext context); + public override bool GetStandardValuesExclusive(ITypeDescriptorContext? context); - public override bool GetStandardValuesSupported(ITypeDescriptorContext context); + public override bool GetStandardValuesSupported(ITypeDescriptorContext? context); } public class ImageKeyConverter : StringConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); - public override bool GetStandardValuesExclusive(ITypeDescriptorContext context); + public override bool GetStandardValuesExclusive(ITypeDescriptorContext? context); - public override bool GetStandardValuesSupported(ITypeDescriptorContext context); + public override bool GetStandardValuesSupported(ITypeDescriptorContext? context); } public sealed class ImageList : Component, IHandle { public bool HandleCreated { get; } - public ImageListStreamer ImageStream { get; set; } + public ImageListStreamer? ImageStream { get; set; } - public object Tag { get; set; } + public object? Tag { get; set; } - public event EventHandler RecreateHandle; + public event EventHandler? RecreateHandle; public sealed class ImageCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public Image this[string key] { get; } + public Image? this[string key] { get; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object value); + bool IList.Contains(object? value); - int IList.IndexOf(object value); + int IList.IndexOf(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } } public class KeysConverter : TypeConverter, IComparer { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class Label : Control, IAutomationLiveRegion { public override string Text { get; set; } } - public struct LinkArea { + public struct LinkArea : IEquatable<LinkArea> { - public override bool Equals(object o); + public override bool Equals(object? o); + public bool Equals(LinkArea other); public class LinkAreaConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues); + public override object CreateInstance(ITypeDescriptorContext? context, IDictionary propertyValues); - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes); + public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); } } public class LinkConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); } - public delegate void LinkLabelLinkClickedEventHandler(object sender, LinkLabelLinkClickedEventArgs e); + public delegate void LinkLabelLinkClickedEventHandler(object? sender, LinkLabelLinkClickedEventArgs e); public class ListBindingConverter : TypeConverter { - public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override bool CanConvertTo(ITypeDescriptorContext? context, Type? destinationType); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); - public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues); + public override object CreateInstance(ITypeDescriptorContext? context, IDictionary propertyValues); - public override bool GetCreateInstanceSupported(ITypeDescriptorContext context); + public override bool GetCreateInstanceSupported(ITypeDescriptorContext? context); } public class ListBox : ListControl { - public override Image BackgroundImage { get; set; } + public override Image? BackgroundImage { get; set; } public override Font Font { get; set; } - public object SelectedItem { get; set; } + public object? SelectedItem { get; set; } public override string Text { get; set; } - public new event EventHandler BackgroundImageChanged; + public new event EventHandler? BackgroundImageChanged; - public new event EventHandler BackgroundImageLayoutChanged; + public new event EventHandler? BackgroundImageLayoutChanged; - public new event EventHandler Click; + public new event EventHandler? Click; - public event DrawItemEventHandler DrawItem; + public event DrawItemEventHandler? DrawItem; - public event MeasureItemEventHandler MeasureItem; + public event MeasureItemEventHandler? MeasureItem; - public new event MouseEventHandler MouseClick; + public new event MouseEventHandler? MouseClick; - public new event EventHandler PaddingChanged; + public new event EventHandler? PaddingChanged; - public new event PaintEventHandler Paint; + public new event PaintEventHandler? Paint; - public event EventHandler SelectedIndexChanged; + public event EventHandler? SelectedIndexChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; public class IntegerCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - bool System.Collections.IList.IsReadOnly { get; } + bool IList.IsReadOnly { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object item); + int IList.Add(object? item); - bool IList.Contains(object item); + bool IList.Contains(object? item); - int IList.IndexOf(object item); + int IList.IndexOf(object? item); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class SelectedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object selectedIndex); + bool IList.Contains(object? selectedIndex); - int IList.IndexOf(object selectedIndex); + int IList.IndexOf(object? selectedIndex); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class SelectedObjectCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - public object this[int index] { get; set; } + public object? this[int index] { get; set; } - public bool Contains(object selectedObject); + public bool Contains(object? selectedObject); - public int IndexOf(object selectedObject); + public int IndexOf(object? selectedObject); - int IList.Add(object value); + int IList.Add(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } } public class ListView : Control { public override string Text { get; set; } - public event EventHandler<ListViewGroupEventArgs> GroupCollapsedStateChanged; + public event EventHandler<ListViewGroupEventArgs>? GroupCollapsedStateChanged; - public event EventHandler<ListViewGroupEventArgs> GroupTaskLinkClick; + public event EventHandler<ListViewGroupEventArgs>? GroupTaskLinkClick; - public ListViewItem FindItemWithText(string text); + public ListViewItem? FindItemWithText(string text); - public ListViewItem FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex); + public ListViewItem? FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex); - public ListViewItem FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex, bool isPrefixSearch); + public ListViewItem? FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex, bool isPrefixSearch); public class CheckedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object checkedIndex); + bool IList.Contains(object? checkedIndex); - int IList.IndexOf(object checkedIndex); + int IList.IndexOf(object? checkedIndex); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class CheckedListViewItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } } public class ColumnHeaderCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } - public virtual ColumnHeader Add(string text); + public virtual ColumnHeader Add(string? text); - public virtual ColumnHeader Add(string text, int width); + public virtual ColumnHeader Add(string? text, int width); - public virtual ColumnHeader Add(string text, int width, HorizontalAlignment textAlign); + public virtual ColumnHeader Add(string? text, int width, HorizontalAlignment textAlign); - public virtual ColumnHeader Add(string key, string text, int width, HorizontalAlignment textAlign, string imageKey); + public virtual ColumnHeader Add(string? key, string? text, int width, HorizontalAlignment textAlign, string imageKey); } public class SelectedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object selectedIndex); + bool IList.Contains(object? selectedIndex); - int IList.IndexOf(object selectedIndex); + int IList.IndexOf(object? selectedIndex); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class SelectedListViewItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } } } public class ListViewGroupCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - bool System.Collections.IList.IsReadOnly { get; } + bool IList.IsReadOnly { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public ListViewGroup this[string key] { get; set; } + public ListViewGroup? this[string key] { get; set; } - public ListViewGroup Add(string key, string headerText); + public ListViewGroup Add(string? key, string? headerText); - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object value); + bool IList.Contains(object? value); - int IList.IndexOf(object value); + int IList.IndexOf(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class ListViewHitTestInfo { public ListViewItem Item { get; } public ListViewHitTestLocations Location { get; } public ListViewItem.ListViewSubItem SubItem { get; } } public class ListViewItem : ICloneable, IKeyboardToolTip, ISerializable { public class ListViewSubItem { - public ListViewSubItem(ListViewItem owner, string text); + public ListViewSubItem(ListViewItem owner, string? text); - public ListViewSubItem(ListViewItem owner, string text, Color foreColor, Color backColor, Font font); + public ListViewSubItem(ListViewItem owner, string? text, Color foreColor, Color backColor, Font font); public string Name { get; set; } - public object Tag { get; set; } + public object? Tag { get; set; } public string Text { get; set; } } public class ListViewSubItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public virtual ListViewItem.ListViewSubItem this[string key] { get; } + public virtual ListViewItem.ListViewSubItem? this[string key] { get; } - public ListViewItem.ListViewSubItem Add(string text); + public ListViewItem.ListViewSubItem Add(string? text); - public ListViewItem.ListViewSubItem Add(string text, Color foreColor, Color backColor, Font font); + public ListViewItem.ListViewSubItem Add(string? text, Color foreColor, Color backColor, Font font); - public bool Contains(ListViewItem.ListViewSubItem subItem); + public bool Contains(ListViewItem.ListViewSubItem? subItem); - public virtual bool ContainsKey(string key); + public virtual bool ContainsKey(string? key); - public int IndexOf(ListViewItem.ListViewSubItem subItem); + public int IndexOf(ListViewItem.ListViewSubItem? subItem); - public virtual int IndexOfKey(string key); + public virtual int IndexOfKey(string? key); - public void Remove(ListViewItem.ListViewSubItem item); + public void Remove(ListViewItem.ListViewSubItem? item); - public virtual void RemoveByKey(string key); + public virtual void RemoveByKey(string? key); - int IList.Add(object item); + int IList.Add(object? item); - bool IList.Contains(object item); + bool IList.Contains(object? item); - int IList.IndexOf(object subItem); + int IList.IndexOf(object? subItem); - void IList.Insert(int index, object item); + void IList.Insert(int index, object? item); - void IList.Remove(object item); + void IList.Remove(object? item); } } public class ListViewItemStateImageIndexConverter : ImageIndexConverter { - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class MaskedTextBox : TextBoxBase { - public IFormatProvider FormatProvider { get; set; } + public IFormatProvider? FormatProvider { get; set; } public new string[] Lines { get; set; } public string Mask { get; set; } - public MaskedTextProvider MaskedTextProvider { get; } + public MaskedTextProvider? MaskedTextProvider { get; } public override string SelectedText { get; set; } public override string Text { get; set; } - public Type ValidatingType { get; set; } + public Type? ValidatingType { get; set; } - public new event EventHandler AcceptsTabChanged; + public new event EventHandler? AcceptsTabChanged; - public event EventHandler IsOverwriteModeChanged; + public event EventHandler? IsOverwriteModeChanged; - public event EventHandler MaskChanged; + public event EventHandler? MaskChanged; - public event MaskInputRejectedEventHandler MaskInputRejected; + public event MaskInputRejectedEventHandler? MaskInputRejected; - public new event EventHandler MultilineChanged; + public new event EventHandler? MultilineChanged; - public event EventHandler TextAlignChanged; + public event EventHandler? TextAlignChanged; - public event TypeValidationEventHandler TypeValidationCompleted; + public event TypeValidationEventHandler? TypeValidationCompleted; - public object ValidateText(); + public object? ValidateText(); } public sealed class MdiClient : Control { - public override Image BackgroundImage { get; set; } + public override Image? BackgroundImage { get; set; } } - public struct Message { + public struct Message : IEquatable<Message> { public IntPtr LParam { get; set; } public int Msg { get; set; } public IntPtr Result { get; set; } public IntPtr WParam { get; set; } + public bool Equals(Message other); public object? GetLParam(Type cls); } public class MonthCalendar : Control { - protected override void Dispose(bool disposing); } public class NativeWindow : MarshalByRefObject, IHandle, IWin32Window { - public static NativeWindow FromHandle(IntPtr handle); + public static NativeWindow? FromHandle(IntPtr handle); } public sealed class NotifyIcon : Component { public string Text { get; set; } } public class NumericUpDown : UpDownBase, ISupportInitialize { public override string Text { get; set; } - public new event EventHandler PaddingChanged; + public new event EventHandler? PaddingChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; - public event EventHandler ValueChanged; + public event EventHandler? ValueChanged; - protected override AccessibleObject CreateAccessibilityInstance(); - protected override void OnTextBoxKeyPress(object source, KeyPressEventArgs e); + protected override void OnTextBoxKeyPress(object? source, KeyPressEventArgs e); } public class OpacityConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); } public sealed class OpenFileDialog : FileDialog { + public bool SelectReadOnly { get; set; } + public bool ShowPreview { get; set; } } public class OSFeature : FeatureSupport { - public override Version GetVersionPresent(object feature); + public override Version? GetVersionPresent(object feature); } - public struct Padding { + public struct Padding : IEquatable<Padding> { + public bool Equals(Padding other); } public class PaddingConverter : TypeConverter { public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); } public class Panel : ScrollableControl { public override string Text { get; set; } + protected override AccessibleObject CreateAccessibilityInstance(); } public class PrintControllerWithStatusDialog : PrintController { - public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e); + public override Graphics? OnStartPage(PrintDocument document, PrintPageEventArgs e); } public sealed class PrintDialog : CommonDialog { - public PrintDocument Document { get; set; } + public PrintDocument? Document { get; set; } public PrinterSettings PrinterSettings { get; set; } } public class PrintPreviewControl : Control { - public PrintDocument Document { get; set; } + public PrintDocument? Document { get; set; } public override string Text { get; set; } - public event EventHandler StartPageChanged; + public event EventHandler? StartPageChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; + protected override AccessibleObject CreateAccessibilityInstance(); } public class PrintPreviewDialog : Form { public override Cursor Cursor { get; set; } public override Font Font { get; set; } public override string Text { get; set; } } public class ProgressBar : Control { public override Font Font { get; set; } public override string Text { get; set; } } public class PropertyGrid : ContainerControl, IComPropertyBrowser, Interop.Ole32.IPropertyNotifySink { - void IComPropertyBrowser.LoadState(RegistryKey optRoot); + void IComPropertyBrowser.LoadState(RegistryKey key); - void IComPropertyBrowser.SaveState(RegistryKey optRoot); + void IComPropertyBrowser.SaveState(RegistryKey key); } public class RadioButton : ButtonBase { - public event EventHandler AppearanceChanged; + public event EventHandler? AppearanceChanged; - public event EventHandler CheckedChanged; + public event EventHandler? CheckedChanged; - public new event EventHandler DoubleClick; + public new event EventHandler? DoubleClick; - public new event MouseEventHandler MouseDoubleClick; + public new event MouseEventHandler? MouseDoubleClick; } public static class RadioButtonRenderer { - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, bool focused, RadioButtonState state); - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, TextFormatFlags flags, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, TextFormatFlags flags, bool focused, RadioButtonState state); - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); } public sealed class SaveFileDialog : FileDialog { + public bool CheckWriteAccess { get; set; } + public bool ExpandedMode { get; set; } } public class Screen { - public static Screen PrimaryScreen { get; } + public static Screen? PrimaryScreen { get; } - public override bool Equals(object obj); + public override bool Equals(object? obj); } public class ScrollableControl : Control, IArrangedElement, IComponent, IDisposable { - public event ScrollEventHandler Scroll; + public event ScrollEventHandler? Scroll; - public void ScrollControlIntoView(Control activeControl); + public void ScrollControlIntoView(Control? activeControl); public class DockPaddingEdges : ICloneable { - public override bool Equals(object other); + public override bool Equals(object? other); } public class DockPaddingEdgesConverter : TypeConverter { - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes); + public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); - public override bool GetPropertiesSupported(ITypeDescriptorContext context); + public override bool GetPropertiesSupported(ITypeDescriptorContext? context); } } public abstract class ScrollBar : Control { public override Font Font { get; set; } public override string Text { get; set; } } public class SelectionRangeConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues); + public override object CreateInstance(ITypeDescriptorContext? context, IDictionary propertyValues); - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes); + public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); } public class SplitContainer : ContainerControl, ISupportInitialize { public override string Text { get; set; } + protected override AccessibleObject CreateAccessibilityInstance(); } public class Splitter : Control { public override Font Font { get; set; } public override string Text { get; set; } } public sealed class SplitterPanel : Panel { public new string Name { get; set; } } public class TabControl : Control { public class TabPageCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } } } public class TableLayoutPanel : Panel, IExtenderProvider { - public event TableLayoutCellPaintEventHandler CellPaint; + public event TableLayoutCellPaintEventHandler? CellPaint; - public Control GetControlFromPosition(int column, int row); + public Control? GetControlFromPosition(int column, int row); - public TableLayoutPanelCellPosition GetPositionFromControl(Control control); + public TableLayoutPanelCellPosition GetPositionFromControl(Control? control); } - public struct TableLayoutPanelCellPosition { + public struct TableLayoutPanelCellPosition : IEquatable<TableLayoutPanelCellPosition> { + public bool Equals(TableLayoutPanelCellPosition other); } public class TabPage : Panel { public string ImageKey { get; set; } public override string Text { get; set; } public string ToolTipText { get; set; } public class TabPageControlCollection : Control.ControlCollection { - public override void Add(Control value); + public override void Add(Control? value); } } public static class TabRenderer { - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, Image image, Rectangle imageRectangle, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, Image image, Rectangle imageRectangle, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, TextFormatFlags flags, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, TextFormatFlags flags, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, TextFormatFlags flags, Image image, Rectangle imageRectangle, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, TextFormatFlags flags, Image image, Rectangle imageRectangle, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, TabItemState state); } public class TextBox : TextBoxBase { public AutoCompleteStringCollection AutoCompleteCustomSource { get; set; } public virtual string PlaceholderText { get; set; } public override string Text { get; set; } - public event EventHandler TextAlignChanged; + public event EventHandler? TextAlignChanged; - public void Paste(string text); + public void Paste(string? text); } public abstract class TextBoxBase : Control { public string[] Lines { get; set; } public virtual string SelectedText { get; set; } public override string Text { get; set; } } public class ThreadExceptionDialog : Form { - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; } public class Timer : Component { - public object Tag { get; set; } + public object? Tag { get; set; } } public class ToolStrip : ScrollableControl, IArrangedElement, IComponent, IDisposable, ISupportToolStripPanel { public class ToolStripAccessibleObject : Control.ControlAccessibleObject { - public override AccessibleObject GetChild(int index); + public override AccessibleObject? GetChild(int index); - public override AccessibleObject HitTest(int x, int y); + public override AccessibleObject? HitTest(int x, int y); } } public class ToolStripArrowRenderEventArgs : EventArgs { - public ToolStripArrowRenderEventArgs(Graphics g, ToolStripItem toolStripItem, Rectangle arrowRectangle, Color arrowColor, ArrowDirection arrowDirection); + public ToolStripArrowRenderEventArgs(Graphics g, ToolStripItem? toolStripItem, Rectangle arrowRectangle, Color arrowColor, ArrowDirection arrowDirection); - public ToolStripItem Item { get; } + public ToolStripItem? Item { get; } } public class ToolStripContainer : ContainerControl { public override Cursor Cursor { get; set; } + protected override AccessibleObject CreateAccessibilityInstance(); } public class ToolStripContentPanel : Panel { public new string Name { get; set; } } public class ToolStripDropDownMenu : ToolStripDropDown { + protected override AccessibleObject CreateAccessibilityInstance(); } - public abstract class ToolStripItem : Component, IArrangedElement, IComponent, IDisposable, IDropTarget, IKeyboardToolTip, ISupportOleDropSource { + public abstract class ToolStripItem : BindableComponent, IArrangedElement, ICommandBindingTargetProvider, IComponent, IDisposable, IDropTarget, IKeyboardToolTip, ISupportOleDropSource { + public ICommand Command { get; set; } + public object CommandParameter { get; set; } + public event EventHandler CommandCanExecuteChanged; + public event EventHandler CommandChanged; + public event EventHandler CommandParameterChanged; + public DragDropEffects DoDragDrop(object data, DragDropEffects allowedEffects, Bitmap dragImage, Point cursorOffset, bool useDefaultDragImage); + protected virtual void OnCommandCanExecuteChanged(EventArgs e); + protected virtual void OnCommandChanged(EventArgs e); + protected virtual void OnCommandParameterChanged(EventArgs e); + protected virtual void OnRequestCommandExecute(EventArgs e); } public class ToolStripItemImageRenderEventArgs : ToolStripItemRenderEventArgs { - public ToolStripItemImageRenderEventArgs(Graphics g, ToolStripItem item, Image image, Rectangle imageRectangle); + public ToolStripItemImageRenderEventArgs(Graphics g, ToolStripItem item, Image? image, Rectangle imageRectangle); } public class ToolStripItemRenderEventArgs : EventArgs { - public ToolStrip ToolStrip { get; } + public ToolStrip? ToolStrip { get; } } public class ToolStripItemTextRenderEventArgs : ToolStripItemRenderEventArgs { - public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string text, Rectangle textRectangle, Color textColor, Font textFont, ContentAlignment textAlign); + public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string? text, Rectangle textRectangle, Color textColor, Font? textFont, ContentAlignment textAlign); - public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string text, Rectangle textRectangle, Color textColor, Font textFont, TextFormatFlags format); + public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string? text, Rectangle textRectangle, Color textColor, Font? textFont, TextFormatFlags format); } public class ToolStripPanel : ContainerControl, IArrangedElement, IComponent, IDisposable { public override string Text { get; set; } - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; - public event EventHandler RendererChanged; + public event EventHandler? RendererChanged; - public new event EventHandler TabIndexChanged; + public new event EventHandler? TabIndexChanged; - public new event EventHandler TabStopChanged; + public new event EventHandler? TabStopChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; + protected override AccessibleObject CreateAccessibilityInstance(); - public ToolStripPanelRow PointToRow(Point clientLocation); + public ToolStripPanelRow? PointToRow(Point clientLocation); } public class TrackBar : Control, ISupportInitialize { public override Font Font { get; set; } public override string Text { get; set; } } public class TreeNode : MarshalByRefObject, ICloneable, IKeyboardToolTip, ISerializable public class TreeView : Control { + protected override AccessibleObject CreateAccessibilityInstance(); } public class TreeViewImageIndexConverter : ImageIndexConverter { - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class TreeViewImageKeyConverter : ImageKeyConverter { - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); } public abstract class UpDownBase : ContainerControl { - public override Image BackgroundImage { get; set; } + public override Image? BackgroundImage { get; set; } - public override ContextMenuStrip ContextMenuStrip { get; set; } + public override ContextMenuStrip? ContextMenuStrip { get; set; } public override string Text { get; set; } - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; - public new event EventHandler BackgroundImageChanged; + public new event EventHandler? BackgroundImageChanged; - public new event EventHandler BackgroundImageLayoutChanged; + public new event EventHandler? BackgroundImageLayoutChanged; - public new event EventHandler MouseEnter; + public new event EventHandler? MouseEnter; - public new event EventHandler MouseHover; + public new event EventHandler? MouseHover; - public new event EventHandler MouseLeave; + public new event EventHandler? MouseLeave; - public new event MouseEventHandler MouseMove; + public new event MouseEventHandler? MouseMove; + protected override AccessibleObject CreateAccessibilityInstance(); - protected virtual void OnChanged(object source, EventArgs e); + protected virtual void OnChanged(object? source, EventArgs e); - protected virtual void OnTextBoxKeyDown(object source, KeyEventArgs e); + protected virtual void OnTextBoxKeyDown(object? source, KeyEventArgs e); - protected virtual void OnTextBoxKeyPress(object source, KeyPressEventArgs e); + protected virtual void OnTextBoxKeyPress(object? source, KeyPressEventArgs e); - protected virtual void OnTextBoxLostFocus(object source, EventArgs e); + protected virtual void OnTextBoxLostFocus(object? source, EventArgs e); - protected virtual void OnTextBoxResize(object source, EventArgs e); + protected virtual void OnTextBoxResize(object? source, EventArgs e); - protected virtual void OnTextBoxTextChanged(object source, EventArgs e); + protected virtual void OnTextBoxTextChanged(object? source, EventArgs e); } public class UserControl : ContainerControl { public override string Text { get; set; } } public class WebBrowser : WebBrowserBase { + protected override AccessibleObject CreateAccessibilityInstance(); } public class WebBrowserNavigatingEventArgs : CancelEventArgs { public string TargetFrameName { get; } public Uri Url { get; } } }","title":"System.Windows.Forms"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Windows.Forms/#systemwindowsforms","text":"namespace System.Windows.Forms { public class AccessibleObject : StandardOleMarshalObject, IAccessible, Interop.Ole32.IOleWindow, Interop.Ole32.IServiceProvider, Interop.Oleaut32.IEnumVariant, Interop.UiaCore.IAccessibleEx, Interop.UiaCore.IExpandCollapseProvider, Interop.UiaCore.IGridItemProvider, Interop.UiaCore.IGridProvider, Interop.UiaCore.IInvokeProvider, Interop.UiaCore.ILegacyIAccessibleProvider, Interop.UiaCore.IMultipleViewProvider, Interop.UiaCore.IRangeValueProvider, Interop.UiaCore.IRawElementProviderFragment, Interop.UiaCore.IRawElementProviderFragmentRoot, Interop.UiaCore.IRawElementProviderHwndOverride, Interop.UiaCore.IRawElementProviderSimple, Interop.UiaCore.IScrollItemProvider, Interop.UiaCore.ISelectionItemProvider, Interop.UiaCore.ISelectionProvider, Interop.UiaCore.ITableItemProvider, Interop.UiaCore.ITableProvider, Interop.UiaCore.ITextProvider, Interop.UiaCore.ITextProvider2, Interop.UiaCore.IToggleProvider, Interop.UiaCore.IValueProvider, IReflect { FieldInfo? IReflect.GetField(string name, BindingFlags bindingAttr); FieldInfo[] IReflect.GetFields(BindingFlags bindingAttr); MemberInfo[] IReflect.GetMember(string name, BindingFlags bindingAttr); MemberInfo[] IReflect.GetMembers(BindingFlags bindingAttr); MethodInfo? IReflect.GetMethod(string name, BindingFlags bindingAttr); MethodInfo IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers); MethodInfo[] IReflect.GetMethods(BindingFlags bindingAttr); PropertyInfo[] IReflect.GetProperties(BindingFlags bindingAttr); PropertyInfo? IReflect.GetProperty(string name, BindingFlags bindingAttr); PropertyInfo IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers); object IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[]? namedParameters); } public abstract class AxHost : Control, ICustomTypeDescriptor, ISupportInitialize { TypeConverter ICustomTypeDescriptor.GetConverter(); EventDescriptor ICustomTypeDescriptor.GetDefaultEvent(); PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty(); object ICustomTypeDescriptor.GetEditor(Type editorBaseType); EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes); PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(); PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes); public class AxComponentEditor : WindowsFormsComponentEditor { - public override bool EditComponent(ITypeDescriptorContext context, object obj, IWin32Window parent); + public override bool EditComponent(ITypeDescriptorContext? context, object obj, IWin32Window? parent); } public sealed class ClsidAttribute : Attribute { public string Value { get; } } public class State : ISerializable { - public State(Stream ms, int storageType, bool manualUpdate, string licKey); + public State(Stream ms, int storageType, bool manualUpdate, string? licKey); } public class StateConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); } public sealed class TypeLibraryTimeStampAttribute : Attribute { public DateTime Value { get; } } } + public abstract class BindableComponent : Component, IBindableComponent, IComponent, IDisposable { + protected BindableComponent(); + public BindingContext? BindingContext { get; set; } + public ControlBindingsCollection DataBindings { get; } + public event EventHandler BindingContextChanged; + protected virtual void OnBindingContextChanged(EventArgs e); + } public abstract class BindingManagerBase { - protected EventHandler onCurrentChangedHandler; + protected EventHandler? onCurrentChangedHandler; - protected EventHandler onPositionChangedHandler; + protected EventHandler? onPositionChangedHandler; - protected internal virtual PropertyDescriptorCollection GetItemProperties(ArrayList dataSources, ArrayList listAccessors); + protected internal virtual PropertyDescriptorCollection? GetItemProperties(ArrayList dataSources, ArrayList listAccessors); - protected virtual PropertyDescriptorCollection GetItemProperties(Type listType, int offset, ArrayList dataSources, ArrayList listAccessors); + protected virtual PropertyDescriptorCollection? GetItemProperties(Type listType, int offset, ArrayList dataSources, ArrayList listAccessors); - protected internal abstract string GetListName(ArrayList listAccessors); + protected internal abstract string GetListName(ArrayList? listAccessors); } - public struct BindingMemberInfo { + public struct BindingMemberInfo : IEquatable<BindingMemberInfo> { + public bool Equals(BindingMemberInfo other); } public class BindingSource : Component, IBindingList, IBindingListView, ICancelAddNew, ICollection, ICurrencyManagerProvider, IEnumerable, IList, ISupportInitialize, ISupportInitializeNotification, ITypedList { public virtual string Filter { get; set; } } public class Button : ButtonBase, IButtonControl { - public new event EventHandler DoubleClick; + public new event EventHandler? DoubleClick; - public new event MouseEventHandler MouseDoubleClick; + public new event MouseEventHandler? MouseDoubleClick; } public abstract class ButtonBase : Control { + public ICommand? Command { get; set; } + public object? CommandParameter { get; set; } - public Image Image { get; set; } + public Image? Image { get; set; } - public ImageList ImageList { get; set; } + public ImageList? ImageList { get; set; } public override string Text { get; set; } - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; + public event EventHandler? CommandCanExecuteChanged; + public event EventHandler? CommandChanged; + public event EventHandler? CommandParameterChanged; - public new event EventHandler ImeModeChanged; + public new event EventHandler? ImeModeChanged; + protected override void OnClick(EventArgs e); + protected virtual void OnCommandCanExecuteChanged(EventArgs e); + protected virtual void OnCommandChanged(EventArgs e); + protected virtual void OnCommandParameterChanged(EventArgs e); + protected virtual void OnRequestCommandExecute(EventArgs e); } public static class ButtonRenderer { - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, bool focused, PushButtonState state); - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, Image image, Rectangle imageBounds, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, Image image, Rectangle imageBounds, bool focused, PushButtonState state); - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, TextFormatFlags flags, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, TextFormatFlags flags, bool focused, PushButtonState state); - public static void DrawButton(Graphics g, Rectangle bounds, string buttonText, Font font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, PushButtonState state); + public static void DrawButton(Graphics g, Rectangle bounds, string? buttonText, Font? font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, PushButtonState state); } public class CheckBox : ButtonBase { - public event EventHandler AppearanceChanged; + public event EventHandler? AppearanceChanged; - public event EventHandler CheckedChanged; + public event EventHandler? CheckedChanged; - public event EventHandler CheckStateChanged; + public event EventHandler? CheckStateChanged; - public new event EventHandler DoubleClick; + public new event EventHandler? DoubleClick; - public new event MouseEventHandler MouseDoubleClick; + public new event MouseEventHandler? MouseDoubleClick; } public static class CheckBoxRenderer { - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, bool focused, CheckBoxState state); - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, TextFormatFlags flags, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, TextFormatFlags flags, bool focused, CheckBoxState state); - public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string checkBoxText, Font font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); + public static void DrawCheckBox(Graphics g, Point glyphLocation, Rectangle textBounds, string? checkBoxText, Font? font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, CheckBoxState state); } public class CheckedListBox : ListBox { - public new object DataSource { get; set; } + public new object? DataSource { get; set; } - public new event EventHandler Click; + public new event EventHandler? Click; - public new event EventHandler DataSourceChanged; + public new event EventHandler? DataSourceChanged; - public new event EventHandler DisplayMemberChanged; + public new event EventHandler? DisplayMemberChanged; - public new event DrawItemEventHandler DrawItem; + public new event DrawItemEventHandler? DrawItem; - public event ItemCheckEventHandler ItemCheck; + public event ItemCheckEventHandler? ItemCheck; - public new event MeasureItemEventHandler MeasureItem; + public new event MeasureItemEventHandler? MeasureItem; - public new event MouseEventHandler MouseClick; + public new event MouseEventHandler? MouseClick; - public new event EventHandler ValueMemberChanged; + public new event EventHandler? ValueMemberChanged; public class CheckedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object index); + bool IList.Contains(object? index); - int IList.IndexOf(object index); + int IList.IndexOf(object? index); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class CheckedItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - public object this[int index] { get; set; } + public object? this[int index] { get; set; } - public bool Contains(object item); + public bool Contains(object? item); - public int IndexOf(object item); + public int IndexOf(object? item); - int IList.Add(object value); + int IList.Add(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } } public static class Clipboard { - public static bool ContainsData(string format); + public static bool ContainsData(string? format); - public static Stream GetAudioStream(); + public static Stream? GetAudioStream(); - public static object GetData(string format); + public static object? GetData(string format); - public static IDataObject GetDataObject(); + public static IDataObject? GetDataObject(); - public static Image GetImage(); + public static Image? GetImage(); } public class ColorDialog : CommonDialog { public int[] CustomColors { get; set; } } public class ColumnHeader : Component, ICloneable { public string Text { get; set; } } public class ComboBox : ListControl { public class ChildAccessibleObject : AccessibleObject { - public override string Name { get; } + public override string? Name { get; } } } public static class ComboBoxRenderer { - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, Rectangle textBounds, TextFormatFlags flags, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, Rectangle textBounds, TextFormatFlags flags, ComboBoxState state); - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, Rectangle textBounds, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, Rectangle textBounds, ComboBoxState state); - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, TextFormatFlags flags, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, TextFormatFlags flags, ComboBoxState state); - public static void DrawTextBox(Graphics g, Rectangle bounds, string comboBoxText, Font font, ComboBoxState state); + public static void DrawTextBox(Graphics g, Rectangle bounds, string? comboBoxText, Font? font, ComboBoxState state); } public class ContainerControl : ScrollableControl, IContainerControl { - public Control ActiveControl { get; set; } + public Control? ActiveControl { get; set; } - public override BindingContext BindingContext { get; set; } + public override BindingContext? BindingContext { get; set; } - public Form ParentForm { get; } + public Form? ParentForm { get; } - public event EventHandler AutoValidateChanged; + public event EventHandler? AutoValidateChanged; + protected override void OnMove(EventArgs e); + protected override void OnResize(EventArgs e); + protected virtual void ScaleMinMaxSize(float xScaleFactor, float yScaleFactor, bool updateContainerSize = true); } public class ContextMenuStrip : ToolStripDropDownMenu { - public Control SourceControl { get; } + public Control? SourceControl { get; } } public class Control : Component, IArrangedElement, IBindableComponent, IComponent, IDisposable, IDropTarget, IHandle, IKeyboardToolTip, Interop.Ole32.IOleControl, Interop.Ole32.IOleInPlaceActiveObject, Interop.Ole32.IOleInPlaceObject, Interop.Ole32.IOleObject, Interop.Ole32.IOleWindow, Interop.Ole32.IPersist, Interop.Ole32.IPersistStorage, Interop.Ole32.IPersistStreamInit, Interop.Ole32.IQuickActivate, Interop.Ole32.IViewObject, Interop.Ole32.IViewObject2, Interop.Oleaut32.IPersistPropertyBag, ISupportOleDropSource, ISynchronizeInvoke, IWin32Window { public virtual Cursor Cursor { get; set; } + public virtual object DataContext { get; set; } public virtual Font Font { get; set; } public string Name { get; set; } public virtual string Text { get; set; } + public event EventHandler DataContextChanged; - public IAsyncResult BeginInvoke(Delegate method, params object[] args); + public IAsyncResult BeginInvoke(Delegate method, params object?[]? args); + public DragDropEffects DoDragDrop(object data, DragDropEffects allowedEffects, Bitmap? dragImage, Point cursorOffset, bool useDefaultDragImage); - public object EndInvoke(IAsyncResult asyncResult); + public object? EndInvoke(IAsyncResult asyncResult); - public object Invoke(Delegate method, params object[] args); + public object Invoke(Delegate method, params object?[]? args); + protected virtual void OnDataContextChanged(EventArgs e); + protected virtual void OnParentDataContextChanged(EventArgs e); public class ControlCollection : ArrangedElementCollection, ICloneable, ICollection, IEnumerable, IList { - public virtual Control this[string key] { get; } + public virtual Control? this[string? key] { get; } - public virtual void Add(Control value); + public virtual void Add(Control? value); - public bool Contains(Control control); + public bool Contains(Control? control); - public virtual bool ContainsKey(string key); + public virtual bool ContainsKey(string? key); - public int IndexOf(Control control); + public int IndexOf(Control? control); - public virtual int IndexOfKey(string key); + public virtual int IndexOfKey(string? key); - public virtual void Remove(Control value); + public virtual void Remove(Control? value); - public virtual void RemoveByKey(string key); + public virtual void RemoveByKey(string? key); - int IList.Add(object control); + int IList.Add(object? control); - void IList.Remove(object control); + void IList.Remove(object? control); } } public sealed class Cursor : IDisposable, IHandle, ISerializable { - public static Cursor? Current { get; set; } + public static Cursor Current { get; set; } - public object? Tag { get; set; } + public object Tag { get; set; } - public override bool Equals(object? obj); + public override bool Equals(object obj); } public class CursorConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class DataGridView : Control, ISupportInitialize { protected class DataGridViewTopRowAccessibleObject : AccessibleObject { - public DataGridView Owner { get; set; } + public DataGridView? Owner { get; set; } - public override AccessibleObject GetChild(int index); + public override AccessibleObject? GetChild(int index); - public override AccessibleObject Navigate(AccessibleNavigation navigationDirection); + public override AccessibleObject? Navigate(AccessibleNavigation navigationDirection); } } public sealed class DataGridViewAdvancedBorderStyle : ICloneable { - public override bool Equals(object other); + public override bool Equals(object? other); } public class DataGridViewBand : DataGridViewElement, ICloneable, IDisposable public class DataGridViewButtonCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewButtonColumn : DataGridViewColumn public abstract class DataGridViewCell : DataGridViewElement, ICloneable, IDisposable, IKeyboardToolTip { public virtual Type EditType { get; } } public class DataGridViewCheckBoxCell : DataGridViewCell, IDataGridViewEditingCell { public override Type EditType { get; } } public class DataGridViewColumn : DataGridViewBand, IComponent, IDisposable public class DataGridViewComboBoxCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewComboBoxColumn : DataGridViewColumn public class DataGridViewImageCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewImageColumn : DataGridViewColumn public class DataGridViewLinkCell : DataGridViewCell { public override Type EditType { get; } } public class DataGridViewLinkColumn : DataGridViewColumn public class DataGridViewTextBoxEditingControl : TextBox, IDataGridViewEditingControl { - public virtual DataGridView EditingControlDataGridView { get; set; } + public virtual DataGridView? EditingControlDataGridView { get; set; } } public class DataObject : IDataObject, IDataObject { - public virtual Stream GetAudioStream(); + public virtual Stream? GetAudioStream(); - public virtual object GetData(string format); + public virtual object? GetData(string format); - public virtual object GetData(string format, bool autoConvert); + public virtual object? GetData(string format, bool autoConvert); - public virtual object GetData(Type format); + public virtual object? GetData(Type format); - public virtual Image GetImage(); + public virtual Image? GetImage(); - public virtual void SetData(object data); + public virtual void SetData(object? data); - public virtual void SetData(string format, bool autoConvert, object data); + public virtual void SetData(string format, bool autoConvert, object? data); - public virtual void SetData(string format, object data); + public virtual void SetData(string format, object? data); - public virtual void SetData(Type format, object data); + public virtual void SetData(Type format, object? data); - int IDataObject.EnumDAdvise(out IEnumSTATDATA enumAdvise); + int IDataObject.EnumDAdvise(out IEnumSTATDATA? enumAdvise); } public class DateTimePicker : Control { public Font CalendarFont { get; set; } public override string Text { get; set; } + protected override void OnGotFocus(EventArgs e); public class DateTimePickerAccessibleObject : Control.ControlAccessibleObject { + public override string DefaultAction { get; } - public override string KeyboardShortcut { get; } + public override string? KeyboardShortcut { get; } + public override string Name { get; } + public override void DoDefaultAction(); } } public sealed class DockingAttribute : Attribute { - public override bool Equals(object obj); + public override bool Equals(object? obj); } public class DomainUpDown : UpDownBase { - protected override void OnChanged(object source, EventArgs e); + protected override void OnChanged(object? source, EventArgs e); - protected void OnSelectedItemChanged(object source, EventArgs e); + protected void OnSelectedItemChanged(object? source, EventArgs e); - protected override void OnTextBoxKeyPress(object source, KeyPressEventArgs e); + protected override void OnTextBoxKeyPress(object? source, KeyPressEventArgs e); public class DomainItemAccessibleObject : AccessibleObject { - public DomainItemAccessibleObject(string name, AccessibleObject parent); + public DomainItemAccessibleObject(string? name, AccessibleObject parent); } public class DomainUpDownAccessibleObject : Control.ControlAccessibleObject { - public override AccessibleObject GetChild(int index); + public override AccessibleObject? GetChild(int index); } } public class DragEventArgs : EventArgs { + public DragEventArgs(IDataObject? data, int keyState, int x, int y, DragDropEffects allowedEffect, DragDropEffects effect, DropImageType dropImageType, string message, string messageReplacementToken); + public DropImageType DropImageType { get; set; } + public string Message { get; set; } + public string MessageReplacementToken { get; set; } } + public enum DropImageType { + Copy = 1, + Invalid = -1, + Label = 6, + Link = 4, + Move = 2, + NoImage = 8, + None = 0, + Warning = 7, + } public class ErrorProvider : Component, IExtenderProvider, ISupportInitialize { + public bool HasErrors { get; } } public abstract class FeatureSupport : IFeatureSupport { - public abstract Version GetVersionPresent(object feature); + public abstract Version? GetVersionPresent(object feature); - public static Version GetVersionPresent(string featureClassName, string featureConstName); + public static Version? GetVersionPresent(string featureClassName, string featureConstName); } public abstract class FileDialog : CommonDialog { + public bool AddToRecent { get; set; } public string DefaultExt { get; set; } public string FileName { get; set; } public string Filter { get; set; } public string InitialDirectory { get; set; } + public bool OkRequiresInteraction { get; set; } + public bool ShowHiddenFiles { get; set; } + public bool ShowPinnedPlaces { get; set; } public string Title { get; set; } } public sealed class FolderBrowserDialog : CommonDialog { + public bool AddToRecent { get; set; } + public bool OkRequiresInteraction { get; set; } + public bool ShowHiddenFiles { get; set; } + public bool ShowPinnedPlaces { get; set; } - public new event EventHandler HelpRequest; + public new event EventHandler? HelpRequest; public override void Reset(); } public class FontDialog : CommonDialog { - public event EventHandler Apply; + public event EventHandler? Apply; } public class Form : ContainerControl { public bool IsMdiChild { get; } public bool IsMdiContainer { get; set; } public override string Text { get; set; } + protected override void OnGotFocus(EventArgs e); + protected override void ScaleMinMaxSize(float xScaleFactor, float yScaleFactor, bool updateContainerSize = true); public new class ControlCollection : Control.ControlCollection { - public override void Add(Control value); + public override void Add(Control? value); - public override void Remove(Control value); + public override void Remove(Control? value); } } public class FormCollection : ReadOnlyCollectionBase { - public virtual Form this[int index] { get; } + public virtual Form? this[int index] { get; } - public virtual Form this[string name] { get; } + public virtual Form? this[string? name] { get; } } public class GiveFeedbackEventArgs : EventArgs { + public GiveFeedbackEventArgs(DragDropEffects effect, bool useDefaultCursors, Bitmap dragImage, Point cursorOffset, bool useDefaultDragImage); + public Point CursorOffset { get; set; } + public Bitmap DragImage { get; set; } + public bool UseDefaultDragImage { get; set; } } public class GroupBox : Control { public override string Text { get; set; } } public interface IDataGridViewEditingControl { - DataGridView EditingControlDataGridView { get; set; } + DataGridView? EditingControlDataGridView { get; set; } } public interface IDataObject { - object GetData(string format); + object? GetData(string format); - object GetData(string format, bool autoConvert); + object? GetData(string format, bool autoConvert); - object GetData(Type format); + object? GetData(Type format); - void SetData(object data); + void SetData(object? data); - void SetData(string format, bool autoConvert, object data); + void SetData(string format, bool autoConvert, object? data); - void SetData(string format, object data); + void SetData(string format, object? data); - void SetData(Type format, object data); + void SetData(Type format, object? data); } public interface IFeatureSupport { - Version GetVersionPresent(object feature); + Version? GetVersionPresent(object feature); } public class ImageIndexConverter : Int32Converter { - public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); - public override bool GetStandardValuesExclusive(ITypeDescriptorContext context); + public override bool GetStandardValuesExclusive(ITypeDescriptorContext? context); - public override bool GetStandardValuesSupported(ITypeDescriptorContext context); + public override bool GetStandardValuesSupported(ITypeDescriptorContext? context); } public class ImageKeyConverter : StringConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value); + public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); - public override bool GetStandardValuesExclusive(ITypeDescriptorContext context); + public override bool GetStandardValuesExclusive(ITypeDescriptorContext? context); - public override bool GetStandardValuesSupported(ITypeDescriptorContext context); + public override bool GetStandardValuesSupported(ITypeDescriptorContext? context); } public sealed class ImageList : Component, IHandle { public bool HandleCreated { get; } - public ImageListStreamer ImageStream { get; set; } + public ImageListStreamer? ImageStream { get; set; } - public object Tag { get; set; } + public object? Tag { get; set; } - public event EventHandler RecreateHandle; + public event EventHandler? RecreateHandle; public sealed class ImageCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public Image this[string key] { get; } + public Image? this[string key] { get; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object value); + bool IList.Contains(object? value); - int IList.IndexOf(object value); + int IList.IndexOf(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } } public class KeysConverter : TypeConverter, IComparer { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class Label : Control, IAutomationLiveRegion { public override string Text { get; set; } } - public struct LinkArea { + public struct LinkArea : IEquatable<LinkArea> { - public override bool Equals(object o); + public override bool Equals(object? o); + public bool Equals(LinkArea other); public class LinkAreaConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues); + public override object CreateInstance(ITypeDescriptorContext? context, IDictionary propertyValues); - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes); + public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); } } public class LinkConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); } - public delegate void LinkLabelLinkClickedEventHandler(object sender, LinkLabelLinkClickedEventArgs e); + public delegate void LinkLabelLinkClickedEventHandler(object? sender, LinkLabelLinkClickedEventArgs e); public class ListBindingConverter : TypeConverter { - public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType); + public override bool CanConvertTo(ITypeDescriptorContext? context, Type? destinationType); - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); - public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues); + public override object CreateInstance(ITypeDescriptorContext? context, IDictionary propertyValues); - public override bool GetCreateInstanceSupported(ITypeDescriptorContext context); + public override bool GetCreateInstanceSupported(ITypeDescriptorContext? context); } public class ListBox : ListControl { - public override Image BackgroundImage { get; set; } + public override Image? BackgroundImage { get; set; } public override Font Font { get; set; } - public object SelectedItem { get; set; } + public object? SelectedItem { get; set; } public override string Text { get; set; } - public new event EventHandler BackgroundImageChanged; + public new event EventHandler? BackgroundImageChanged; - public new event EventHandler BackgroundImageLayoutChanged; + public new event EventHandler? BackgroundImageLayoutChanged; - public new event EventHandler Click; + public new event EventHandler? Click; - public event DrawItemEventHandler DrawItem; + public event DrawItemEventHandler? DrawItem; - public event MeasureItemEventHandler MeasureItem; + public event MeasureItemEventHandler? MeasureItem; - public new event MouseEventHandler MouseClick; + public new event MouseEventHandler? MouseClick; - public new event EventHandler PaddingChanged; + public new event EventHandler? PaddingChanged; - public new event PaintEventHandler Paint; + public new event PaintEventHandler? Paint; - public event EventHandler SelectedIndexChanged; + public event EventHandler? SelectedIndexChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; public class IntegerCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - bool System.Collections.IList.IsReadOnly { get; } + bool IList.IsReadOnly { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object item); + int IList.Add(object? item); - bool IList.Contains(object item); + bool IList.Contains(object? item); - int IList.IndexOf(object item); + int IList.IndexOf(object? item); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class SelectedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object selectedIndex); + bool IList.Contains(object? selectedIndex); - int IList.IndexOf(object selectedIndex); + int IList.IndexOf(object? selectedIndex); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class SelectedObjectCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - public object this[int index] { get; set; } + public object? this[int index] { get; set; } - public bool Contains(object selectedObject); + public bool Contains(object? selectedObject); - public int IndexOf(object selectedObject); + public int IndexOf(object? selectedObject); - int IList.Add(object value); + int IList.Add(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } } public class ListView : Control { public override string Text { get; set; } - public event EventHandler<ListViewGroupEventArgs> GroupCollapsedStateChanged; + public event EventHandler<ListViewGroupEventArgs>? GroupCollapsedStateChanged; - public event EventHandler<ListViewGroupEventArgs> GroupTaskLinkClick; + public event EventHandler<ListViewGroupEventArgs>? GroupTaskLinkClick; - public ListViewItem FindItemWithText(string text); + public ListViewItem? FindItemWithText(string text); - public ListViewItem FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex); + public ListViewItem? FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex); - public ListViewItem FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex, bool isPrefixSearch); + public ListViewItem? FindItemWithText(string text, bool includeSubItemsInSearch, int startIndex, bool isPrefixSearch); public class CheckedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object checkedIndex); + bool IList.Contains(object? checkedIndex); - int IList.IndexOf(object checkedIndex); + int IList.IndexOf(object? checkedIndex); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class CheckedListViewItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } } public class ColumnHeaderCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } - public virtual ColumnHeader Add(string text); + public virtual ColumnHeader Add(string? text); - public virtual ColumnHeader Add(string text, int width); + public virtual ColumnHeader Add(string? text, int width); - public virtual ColumnHeader Add(string text, int width, HorizontalAlignment textAlign); + public virtual ColumnHeader Add(string? text, int width, HorizontalAlignment textAlign); - public virtual ColumnHeader Add(string key, string text, int width, HorizontalAlignment textAlign, string imageKey); + public virtual ColumnHeader Add(string? key, string? text, int width, HorizontalAlignment textAlign, string imageKey); } public class SelectedIndexCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object selectedIndex); + bool IList.Contains(object? selectedIndex); - int IList.IndexOf(object selectedIndex); + int IList.IndexOf(object? selectedIndex); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class SelectedListViewItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } } } public class ListViewGroupCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - bool System.Collections.IList.IsReadOnly { get; } + bool IList.IsReadOnly { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public ListViewGroup this[string key] { get; set; } + public ListViewGroup? this[string key] { get; set; } - public ListViewGroup Add(string key, string headerText); + public ListViewGroup Add(string? key, string? headerText); - int IList.Add(object value); + int IList.Add(object? value); - bool IList.Contains(object value); + bool IList.Contains(object? value); - int IList.IndexOf(object value); + int IList.IndexOf(object? value); - void IList.Insert(int index, object value); + void IList.Insert(int index, object? value); - void IList.Remove(object value); + void IList.Remove(object? value); } public class ListViewHitTestInfo { public ListViewItem Item { get; } public ListViewHitTestLocations Location { get; } public ListViewItem.ListViewSubItem SubItem { get; } } public class ListViewItem : ICloneable, IKeyboardToolTip, ISerializable { public class ListViewSubItem { - public ListViewSubItem(ListViewItem owner, string text); + public ListViewSubItem(ListViewItem owner, string? text); - public ListViewSubItem(ListViewItem owner, string text, Color foreColor, Color backColor, Font font); + public ListViewSubItem(ListViewItem owner, string? text, Color foreColor, Color backColor, Font font); public string Name { get; set; } - public object Tag { get; set; } + public object? Tag { get; set; } public string Text { get; set; } } public class ListViewSubItemCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object? IList.this[int index] { get; set; } - public virtual ListViewItem.ListViewSubItem this[string key] { get; } + public virtual ListViewItem.ListViewSubItem? this[string key] { get; } - public ListViewItem.ListViewSubItem Add(string text); + public ListViewItem.ListViewSubItem Add(string? text); - public ListViewItem.ListViewSubItem Add(string text, Color foreColor, Color backColor, Font font); + public ListViewItem.ListViewSubItem Add(string? text, Color foreColor, Color backColor, Font font); - public bool Contains(ListViewItem.ListViewSubItem subItem); + public bool Contains(ListViewItem.ListViewSubItem? subItem); - public virtual bool ContainsKey(string key); + public virtual bool ContainsKey(string? key); - public int IndexOf(ListViewItem.ListViewSubItem subItem); + public int IndexOf(ListViewItem.ListViewSubItem? subItem); - public virtual int IndexOfKey(string key); + public virtual int IndexOfKey(string? key); - public void Remove(ListViewItem.ListViewSubItem item); + public void Remove(ListViewItem.ListViewSubItem? item); - public virtual void RemoveByKey(string key); + public virtual void RemoveByKey(string? key); - int IList.Add(object item); + int IList.Add(object? item); - bool IList.Contains(object item); + bool IList.Contains(object? item); - int IList.IndexOf(object subItem); + int IList.IndexOf(object? subItem); - void IList.Insert(int index, object item); + void IList.Insert(int index, object? item); - void IList.Remove(object item); + void IList.Remove(object? item); } } public class ListViewItemStateImageIndexConverter : ImageIndexConverter { - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class MaskedTextBox : TextBoxBase { - public IFormatProvider FormatProvider { get; set; } + public IFormatProvider? FormatProvider { get; set; } public new string[] Lines { get; set; } public string Mask { get; set; } - public MaskedTextProvider MaskedTextProvider { get; } + public MaskedTextProvider? MaskedTextProvider { get; } public override string SelectedText { get; set; } public override string Text { get; set; } - public Type ValidatingType { get; set; } + public Type? ValidatingType { get; set; } - public new event EventHandler AcceptsTabChanged; + public new event EventHandler? AcceptsTabChanged; - public event EventHandler IsOverwriteModeChanged; + public event EventHandler? IsOverwriteModeChanged; - public event EventHandler MaskChanged; + public event EventHandler? MaskChanged; - public event MaskInputRejectedEventHandler MaskInputRejected; + public event MaskInputRejectedEventHandler? MaskInputRejected; - public new event EventHandler MultilineChanged; + public new event EventHandler? MultilineChanged; - public event EventHandler TextAlignChanged; + public event EventHandler? TextAlignChanged; - public event TypeValidationEventHandler TypeValidationCompleted; + public event TypeValidationEventHandler? TypeValidationCompleted; - public object ValidateText(); + public object? ValidateText(); } public sealed class MdiClient : Control { - public override Image BackgroundImage { get; set; } + public override Image? BackgroundImage { get; set; } } - public struct Message { + public struct Message : IEquatable<Message> { public IntPtr LParam { get; set; } public int Msg { get; set; } public IntPtr Result { get; set; } public IntPtr WParam { get; set; } + public bool Equals(Message other); public object? GetLParam(Type cls); } public class MonthCalendar : Control { - protected override void Dispose(bool disposing); } public class NativeWindow : MarshalByRefObject, IHandle, IWin32Window { - public static NativeWindow FromHandle(IntPtr handle); + public static NativeWindow? FromHandle(IntPtr handle); } public sealed class NotifyIcon : Component { public string Text { get; set; } } public class NumericUpDown : UpDownBase, ISupportInitialize { public override string Text { get; set; } - public new event EventHandler PaddingChanged; + public new event EventHandler? PaddingChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; - public event EventHandler ValueChanged; + public event EventHandler? ValueChanged; - protected override AccessibleObject CreateAccessibilityInstance(); - protected override void OnTextBoxKeyPress(object source, KeyPressEventArgs e); + protected override void OnTextBoxKeyPress(object? source, KeyPressEventArgs e); } public class OpacityConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); } public sealed class OpenFileDialog : FileDialog { + public bool SelectReadOnly { get; set; } + public bool ShowPreview { get; set; } } public class OSFeature : FeatureSupport { - public override Version GetVersionPresent(object feature); + public override Version? GetVersionPresent(object feature); } - public struct Padding { + public struct Padding : IEquatable<Padding> { + public bool Equals(Padding other); } public class PaddingConverter : TypeConverter { public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); } public class Panel : ScrollableControl { public override string Text { get; set; } + protected override AccessibleObject CreateAccessibilityInstance(); } public class PrintControllerWithStatusDialog : PrintController { - public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e); + public override Graphics? OnStartPage(PrintDocument document, PrintPageEventArgs e); } public sealed class PrintDialog : CommonDialog { - public PrintDocument Document { get; set; } + public PrintDocument? Document { get; set; } public PrinterSettings PrinterSettings { get; set; } } public class PrintPreviewControl : Control { - public PrintDocument Document { get; set; } + public PrintDocument? Document { get; set; } public override string Text { get; set; } - public event EventHandler StartPageChanged; + public event EventHandler? StartPageChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; + protected override AccessibleObject CreateAccessibilityInstance(); } public class PrintPreviewDialog : Form { public override Cursor Cursor { get; set; } public override Font Font { get; set; } public override string Text { get; set; } } public class ProgressBar : Control { public override Font Font { get; set; } public override string Text { get; set; } } public class PropertyGrid : ContainerControl, IComPropertyBrowser, Interop.Ole32.IPropertyNotifySink { - void IComPropertyBrowser.LoadState(RegistryKey optRoot); + void IComPropertyBrowser.LoadState(RegistryKey key); - void IComPropertyBrowser.SaveState(RegistryKey optRoot); + void IComPropertyBrowser.SaveState(RegistryKey key); } public class RadioButton : ButtonBase { - public event EventHandler AppearanceChanged; + public event EventHandler? AppearanceChanged; - public event EventHandler CheckedChanged; + public event EventHandler? CheckedChanged; - public new event EventHandler DoubleClick; + public new event EventHandler? DoubleClick; - public new event MouseEventHandler MouseDoubleClick; + public new event MouseEventHandler? MouseDoubleClick; } public static class RadioButtonRenderer { - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, bool focused, RadioButtonState state); - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, TextFormatFlags flags, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, TextFormatFlags flags, bool focused, RadioButtonState state); - public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string radioButtonText, Font font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); + public static void DrawRadioButton(Graphics g, Point glyphLocation, Rectangle textBounds, string? radioButtonText, Font? font, TextFormatFlags flags, Image image, Rectangle imageBounds, bool focused, RadioButtonState state); } public sealed class SaveFileDialog : FileDialog { + public bool CheckWriteAccess { get; set; } + public bool ExpandedMode { get; set; } } public class Screen { - public static Screen PrimaryScreen { get; } + public static Screen? PrimaryScreen { get; } - public override bool Equals(object obj); + public override bool Equals(object? obj); } public class ScrollableControl : Control, IArrangedElement, IComponent, IDisposable { - public event ScrollEventHandler Scroll; + public event ScrollEventHandler? Scroll; - public void ScrollControlIntoView(Control activeControl); + public void ScrollControlIntoView(Control? activeControl); public class DockPaddingEdges : ICloneable { - public override bool Equals(object other); + public override bool Equals(object? other); } public class DockPaddingEdgesConverter : TypeConverter { - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes); + public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); - public override bool GetPropertiesSupported(ITypeDescriptorContext context); + public override bool GetPropertiesSupported(ITypeDescriptorContext? context); } } public abstract class ScrollBar : Control { public override Font Font { get; set; } public override string Text { get; set; } } public class SelectionRangeConverter : TypeConverter { - public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType); + public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType); - public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues); + public override object CreateInstance(ITypeDescriptorContext? context, IDictionary propertyValues); - public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes); + public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext? context, object value, Attribute[]? attributes); } public class SplitContainer : ContainerControl, ISupportInitialize { public override string Text { get; set; } + protected override AccessibleObject CreateAccessibilityInstance(); } public class Splitter : Control { public override Font Font { get; set; } public override string Text { get; set; } } public sealed class SplitterPanel : Panel { public new string Name { get; set; } } public class TabControl : Control { public class TabPageCollection : ICollection, IEnumerable, IList { - bool System.Collections.ICollection.IsSynchronized { get; } + bool ICollection.IsSynchronized { get; } - object System.Collections.ICollection.SyncRoot { get; } + object ICollection.SyncRoot { get; } - bool System.Collections.IList.IsFixedSize { get; } + bool IList.IsFixedSize { get; } - object System.Collections.IList.this[int index] { get; set; } + object IList.this[int index] { get; set; } } } public class TableLayoutPanel : Panel, IExtenderProvider { - public event TableLayoutCellPaintEventHandler CellPaint; + public event TableLayoutCellPaintEventHandler? CellPaint; - public Control GetControlFromPosition(int column, int row); + public Control? GetControlFromPosition(int column, int row); - public TableLayoutPanelCellPosition GetPositionFromControl(Control control); + public TableLayoutPanelCellPosition GetPositionFromControl(Control? control); } - public struct TableLayoutPanelCellPosition { + public struct TableLayoutPanelCellPosition : IEquatable<TableLayoutPanelCellPosition> { + public bool Equals(TableLayoutPanelCellPosition other); } public class TabPage : Panel { public string ImageKey { get; set; } public override string Text { get; set; } public string ToolTipText { get; set; } public class TabPageControlCollection : Control.ControlCollection { - public override void Add(Control value); + public override void Add(Control? value); } } public static class TabRenderer { - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, Image image, Rectangle imageRectangle, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, Image image, Rectangle imageRectangle, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, TextFormatFlags flags, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, TextFormatFlags flags, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, TextFormatFlags flags, Image image, Rectangle imageRectangle, bool focused, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, TextFormatFlags flags, Image image, Rectangle imageRectangle, bool focused, TabItemState state); - public static void DrawTabItem(Graphics g, Rectangle bounds, string tabItemText, Font font, TabItemState state); + public static void DrawTabItem(Graphics g, Rectangle bounds, string? tabItemText, Font? font, TabItemState state); } public class TextBox : TextBoxBase { public AutoCompleteStringCollection AutoCompleteCustomSource { get; set; } public virtual string PlaceholderText { get; set; } public override string Text { get; set; } - public event EventHandler TextAlignChanged; + public event EventHandler? TextAlignChanged; - public void Paste(string text); + public void Paste(string? text); } public abstract class TextBoxBase : Control { public string[] Lines { get; set; } public virtual string SelectedText { get; set; } public override string Text { get; set; } } public class ThreadExceptionDialog : Form { - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; } public class Timer : Component { - public object Tag { get; set; } + public object? Tag { get; set; } } public class ToolStrip : ScrollableControl, IArrangedElement, IComponent, IDisposable, ISupportToolStripPanel { public class ToolStripAccessibleObject : Control.ControlAccessibleObject { - public override AccessibleObject GetChild(int index); + public override AccessibleObject? GetChild(int index); - public override AccessibleObject HitTest(int x, int y); + public override AccessibleObject? HitTest(int x, int y); } } public class ToolStripArrowRenderEventArgs : EventArgs { - public ToolStripArrowRenderEventArgs(Graphics g, ToolStripItem toolStripItem, Rectangle arrowRectangle, Color arrowColor, ArrowDirection arrowDirection); + public ToolStripArrowRenderEventArgs(Graphics g, ToolStripItem? toolStripItem, Rectangle arrowRectangle, Color arrowColor, ArrowDirection arrowDirection); - public ToolStripItem Item { get; } + public ToolStripItem? Item { get; } } public class ToolStripContainer : ContainerControl { public override Cursor Cursor { get; set; } + protected override AccessibleObject CreateAccessibilityInstance(); } public class ToolStripContentPanel : Panel { public new string Name { get; set; } } public class ToolStripDropDownMenu : ToolStripDropDown { + protected override AccessibleObject CreateAccessibilityInstance(); } - public abstract class ToolStripItem : Component, IArrangedElement, IComponent, IDisposable, IDropTarget, IKeyboardToolTip, ISupportOleDropSource { + public abstract class ToolStripItem : BindableComponent, IArrangedElement, ICommandBindingTargetProvider, IComponent, IDisposable, IDropTarget, IKeyboardToolTip, ISupportOleDropSource { + public ICommand Command { get; set; } + public object CommandParameter { get; set; } + public event EventHandler CommandCanExecuteChanged; + public event EventHandler CommandChanged; + public event EventHandler CommandParameterChanged; + public DragDropEffects DoDragDrop(object data, DragDropEffects allowedEffects, Bitmap dragImage, Point cursorOffset, bool useDefaultDragImage); + protected virtual void OnCommandCanExecuteChanged(EventArgs e); + protected virtual void OnCommandChanged(EventArgs e); + protected virtual void OnCommandParameterChanged(EventArgs e); + protected virtual void OnRequestCommandExecute(EventArgs e); } public class ToolStripItemImageRenderEventArgs : ToolStripItemRenderEventArgs { - public ToolStripItemImageRenderEventArgs(Graphics g, ToolStripItem item, Image image, Rectangle imageRectangle); + public ToolStripItemImageRenderEventArgs(Graphics g, ToolStripItem item, Image? image, Rectangle imageRectangle); } public class ToolStripItemRenderEventArgs : EventArgs { - public ToolStrip ToolStrip { get; } + public ToolStrip? ToolStrip { get; } } public class ToolStripItemTextRenderEventArgs : ToolStripItemRenderEventArgs { - public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string text, Rectangle textRectangle, Color textColor, Font textFont, ContentAlignment textAlign); + public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string? text, Rectangle textRectangle, Color textColor, Font? textFont, ContentAlignment textAlign); - public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string text, Rectangle textRectangle, Color textColor, Font textFont, TextFormatFlags format); + public ToolStripItemTextRenderEventArgs(Graphics g, ToolStripItem item, string? text, Rectangle textRectangle, Color textColor, Font? textFont, TextFormatFlags format); } public class ToolStripPanel : ContainerControl, IArrangedElement, IComponent, IDisposable { public override string Text { get; set; } - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; - public event EventHandler RendererChanged; + public event EventHandler? RendererChanged; - public new event EventHandler TabIndexChanged; + public new event EventHandler? TabIndexChanged; - public new event EventHandler TabStopChanged; + public new event EventHandler? TabStopChanged; - public new event EventHandler TextChanged; + public new event EventHandler? TextChanged; + protected override AccessibleObject CreateAccessibilityInstance(); - public ToolStripPanelRow PointToRow(Point clientLocation); + public ToolStripPanelRow? PointToRow(Point clientLocation); } public class TrackBar : Control, ISupportInitialize { public override Font Font { get; set; } public override string Text { get; set; } } public class TreeNode : MarshalByRefObject, ICloneable, IKeyboardToolTip, ISerializable public class TreeView : Control { + protected override AccessibleObject CreateAccessibilityInstance(); } public class TreeViewImageIndexConverter : ImageIndexConverter { - public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context); + public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext? context); } public class TreeViewImageKeyConverter : ImageKeyConverter { - public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType); + public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType); } public abstract class UpDownBase : ContainerControl { - public override Image BackgroundImage { get; set; } + public override Image? BackgroundImage { get; set; } - public override ContextMenuStrip ContextMenuStrip { get; set; } + public override ContextMenuStrip? ContextMenuStrip { get; set; } public override string Text { get; set; } - public new event EventHandler AutoSizeChanged; + public new event EventHandler? AutoSizeChanged; - public new event EventHandler BackgroundImageChanged; + public new event EventHandler? BackgroundImageChanged; - public new event EventHandler BackgroundImageLayoutChanged; + public new event EventHandler? BackgroundImageLayoutChanged; - public new event EventHandler MouseEnter; + public new event EventHandler? MouseEnter; - public new event EventHandler MouseHover; + public new event EventHandler? MouseHover; - public new event EventHandler MouseLeave; + public new event EventHandler? MouseLeave; - public new event MouseEventHandler MouseMove; + public new event MouseEventHandler? MouseMove; + protected override AccessibleObject CreateAccessibilityInstance(); - protected virtual void OnChanged(object source, EventArgs e); + protected virtual void OnChanged(object? source, EventArgs e); - protected virtual void OnTextBoxKeyDown(object source, KeyEventArgs e); + protected virtual void OnTextBoxKeyDown(object? source, KeyEventArgs e); - protected virtual void OnTextBoxKeyPress(object source, KeyPressEventArgs e); + protected virtual void OnTextBoxKeyPress(object? source, KeyPressEventArgs e); - protected virtual void OnTextBoxLostFocus(object source, EventArgs e); + protected virtual void OnTextBoxLostFocus(object? source, EventArgs e); - protected virtual void OnTextBoxResize(object source, EventArgs e); + protected virtual void OnTextBoxResize(object? source, EventArgs e); - protected virtual void OnTextBoxTextChanged(object source, EventArgs e); + protected virtual void OnTextBoxTextChanged(object? source, EventArgs e); } public class UserControl : ContainerControl { public override string Text { get; set; } } public class WebBrowser : WebBrowserBase { + protected override AccessibleObject CreateAccessibilityInstance(); } public class WebBrowserNavigatingEventArgs : CancelEventArgs { public string TargetFrameName { get; } public Uri Url { get; } } }","title":"System.Windows.Forms"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Xaml.Permissions/","text":"System.Xaml.Permissions namespace System.Xaml.Permissions { public class XamlAccessLevel { - public string PrivateAccessToTypeName { get; } + public string? PrivateAccessToTypeName { get; } } }","title":"System.Xaml.Permissions"},{"location":"Microsoft.WindowsDesktop.App/7.0_System.Xaml.Permissions/#systemxamlpermissions","text":"namespace System.Xaml.Permissions { public class XamlAccessLevel { - public string PrivateAccessToTypeName { get; } + public string? PrivateAccessToTypeName { get; } } }","title":"System.Xaml.Permissions"}]}